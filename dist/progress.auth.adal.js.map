{"version":3,"sources":["webpack/bootstrap 4bab5e00db894aadbb51","C:/Users/roh/repos/jsdo.adal.js/lib\\progress.auth.extension.js","C:\\Users\\roh\\repos\\jsdo.adal.js\\node_modules\\jsdo\\lib\\progress.jsdo.js"],"names":["Object","defineProperty","data","Session","value","enumerable","AUTH_TYPE_ADAL","authProviderBase","AuthenticationProvider","initObject","authProv","authModel","authenticationModel","toLowerCase","adalConfig","AuthenticationProviderAdal","call","sessionBase","options","that","get","_authenticationModel","set","newval","AUTH_TYPE_FORM","AUTH_TYPE_BASIC","AUTH_TYPE_ANON","storeSessionInfo","Error","configurable","baseSession","prototype"],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;;;;;ACtDA;;AAEA;AACA,IAAK,OAAOA,OAAOC,cAAf,IAAkC,UAAtC,EACID,OAAOC,cAAP,CAAsB,eAASC,IAAT,CAAcC,OAApC,EAA6C,gBAA7C,EAA+D;AAC3DC,WAAO,MADoD,EAC5CC,YAAY;AADgC,CAA/D,EADJ,KAIK,eAASH,IAAT,CAAcC,OAAd,CAAsBG,cAAtB,GAAuC,MAAvC;;AAEL;AAhBA;;;;;;;AAiBA,IAAIC,mBAAmB,eAASL,IAAT,CAAcM,sBAArC;AACA,eAASN,IAAT,CAAcM,sBAAd,GAAuC,UAAUC,UAAV,EAAsB;AACzD,QAAIC,QAAJ;AAAA,QAAcC,YAAaF,cAAcA,WAAWG,mBAAX,CAA+BC,WAA/B,EAAzC;AAAA,QACIC,aAAcL,cAAcA,WAAWK,UAD3C;AAEA,YAAQH,SAAR;AACI,aAAK,eAAST,IAAT,CAAcC,OAAd,CAAsBG,cAA3B;AACII,uBAAW,IAAI,eAASR,IAAT,CAAca,0BAAlB,CAA6CD,UAA7C,CAAX;AACA;AACJ;AACIJ,uBAAWH,iBAAiBS,IAAjB,CAAsB,IAAtB,EAA4BP,UAA5B,CAAX;AALR;;AAQA,WAAOC,QAAP;AACH,CAZD;;AAcA,IAAIO,cAAc,eAASf,IAAT,CAAcC,OAAhC;AACA,eAASD,IAAT,CAAcC,OAAd,GAAwB,SAASA,OAAT,CAAiBe,OAAjB,EAA0B;AAC9C,QAAIC,OAAO,IAAX;;AAEJ;AACI,QAAK,OAAOnB,OAAOC,cAAf,IAAkC,UAAtC,EAAkD;;AAE9CD,eAAOC,cAAP,CAAsBkB,IAAtB,EAA4B,qBAA5B,EACI;AACIC,iBAAK,eAAY;AACb,uBAAOD,KAAKE,oBAAZ;AACH,aAHL;AAIIC,iBAAK,aAAUC,MAAV,EAAkB;AACnB,oBAAIA,MAAJ,EAAY;AACRA,6BAASA,OAAOV,WAAP,EAAT;AACH;AACD,wBAAQU,MAAR;AACI,yBAAK,eAASrB,IAAT,CAAcC,OAAd,CAAsBqB,cAA3B;AACA,yBAAK,eAAStB,IAAT,CAAcC,OAAd,CAAsBsB,eAA3B;AACA,yBAAK,eAASvB,IAAT,CAAcC,OAAd,CAAsBuB,cAA3B;AACA,yBAAK,eAASxB,IAAT,CAAcC,OAAd,CAAsBG,cAA3B;AACA,yBAAK,IAAL;AACIa,6BAAKE,oBAAL,GAA4BE,MAA5B;AACAI,yCAAiB,qBAAjB,EAAwCJ,MAAxC;;AAEA;AACJ;AACI,8BAAM,IAAIK,KAAJ,CAAU,iDACZL,MADY,GACH,wBADP,CAAN;AAXR;AAcH,aAtBL;AAuBIlB,wBAAY,IAvBhB;AAwBIwB,0BAAc;AAxBlB,SADJ;AA2BH;;AAED,QAAIC,cAAcb,YAAYD,IAAZ,CAAiBG,IAAjB,EAAuBD,OAAvB,CAAlB;;AAEA,WAAOC,IAAP;AACH,CAtCD;;AAwCA,eAASjB,IAAT,CAAcC,OAAd,CAAsB4B,SAAtB,GAAkCd,YAAYc,SAA9C;;;;;;;;ACzEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,kCAAkC;AAClC;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,MAAM;;;AAGN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8CAA8C,cAAc;AAC5D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,a;;AAEA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,oCAAoC,EAAE;AACtC;AACA,qB;AACA;AACA;AACA;AACA,4CAA4C,eAAe;AAC3D;AACA;AACA;AACA,mDAAmD,qCAAqC;AACxF;AACA;AACA,gDAAgD,gCAAgC;AAChF;AACA,qB;AACA;AACA,mCAAmC,EAAE;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,EAAE,OAAO,EAAE;AAClD;AACA;AACA,uCAAuC,EAAE,OAAO,EAAE;AAClD;AACA;AACA;AACA,uCAAuC,EAAE,YAAY,EAAE;AACvD;AACA;AACA;AACA,mCAAmC,EAAE,EAAE,EAAE;AACzC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,8CAA8C,cAAc;AAC5D;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,EAAE;AACtC;AACA,qB;AACA;AACA;AACA;AACA,wCAAwC,aAAa;AACrD;AACA;AACA,uCAAuC,YAAY;AACnD;AACA;AACA,wCAAwC,MAAM;AAC9C,yB;AACA,qB;AACA;AACA,mCAAmC,EAAE;AACrC;;AAEA;AACA,+FAA+F;AAC/F;AACA,oCAAoC,EAAE;AACtC;AACA,8D;AACA,qCAAqC,EAAE;AACvC;AACA;AACA,qCAAqC,EAAE;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA,+BAA+B,EAAE,EAAE,EAAE;AACrC;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA,oD;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,gEAAgE,EAAE,OAAO,EAAE;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,WAAW,MAAM;AAC/C;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,a;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,a;AACA;AACA;AACA,a;AACA;AACA;AACA,a;AACA;AACA;AACA,a;AACA;AACA;AACA,a;AACA;AACA;AACA,a;AACA;AACA;AACA,a;AACA;AACA;AACA;AACA;AACA;AACA,a;AACA;AACA;AACA,a;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC,I;;;;AAID;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA,kDAAkD,EAAE;AACpD,uEAAuE,EAAE;AACzE,sDAAsD,EAAE;AACxD,kCAAkC,EAAE;AACpC,2DAA2D,EAAE;AAC7D,kDAAkD,EAAE;AACpD;AACA,mDAAmD,EAAE;AACrD;AACA,4CAA4C,EAAE;AAC9C,yCAAyC,EAAE;AAC3C;AACA,qBAAqB,EAAE;AACvB,8CAA8C,EAAE,eAAe,EAAE;AACjE;AACA;AACA;AACA;AACA,4BAA4B,EAAE,mCAAmC,EAAE;AACnE,4BAA4B,EAAE,iCAAiC,EAAE;AACjE;AACA;AACA,0CAA0C,EAAE,YAAY,EAAE;AAC1D,6DAA6D,EAAE;AAC/D;AACA,4BAA4B,EAAE,yBAAyB,EAAE,GAAG,EAAE;AAC9D,sCAAsC,EAAE;AACxC,sCAAsC,EAAE;AACxC,mCAAmC,EAAE;AACrC,4BAA4B,EAAE,mCAAmC,EAAE;AACnE,sEAAsE,EAAE;AACxE;AACA;AACA;AACA,6BAA6B,EAAE;AAC/B,4BAA4B,EAAE;AAC9B,yBAAyB,EAAE;AAC3B,sCAAsC,EAAE,aAAa,EAAE,aAAa,EAAE;AACtE,kCAAkC,EAAE,YAAY,EAAE,aAAa,EAAE,Y;AACjE,kCAAkC,EAAE;AACpC,4BAA4B,EAAE;AAC9B,4BAA4B,EAAE,GAAG,EAAE,uBAAuB,EAAE,6BAA6B,EAAE;AAC3F,4BAA4B,EAAE,oCAAoC,EAAE;AACpE;AACA,4BAA4B,EAAE;AAC9B,4BAA4B,EAAE;;AAE9B;AACA;AACA;;AAEA;AACA,kFAAkF,EAAE;AACpF,iCAAiC,EAAE;AACnC,mDAAmD,EAAE;AACrD,6DAA6D,EAAE,gCAAgC,EAAE;AACjG,wDAAwD,EAAE,yBAAyB,EAAE;AACrF,yBAAyB,EAAE;AAC3B,8CAA8C,EAAE,oBAAoB,EAAE;AACtE,8DAA8D,EAAE;AAChE,kCAAkC,EAAE,gCAAgC,EAAE;AACtE,4DAA4D,EAAE;AAC9D,uCAAuC,EAAE;AACzC;AACA;AACA,0CAA0C,EAAE,wBAAwB,EAAE;AACtE,4BAA4B,EAAE,YAAY,EAAE,kBAAkB,EAAE,KAAK,EAAE;AACvE,4BAA4B,EAAE,oCAAoC,EAAE,wBAAwB,EAAE;AAC9F,4BAA4B,EAAE,0CAA0C,EAAE;AAC1E;AACA;AACA;;AAEA;AACA,4BAA4B,EAAE,IAAI,EAAE,2BAA2B,EAAE;AACjE,4BAA4B,EAAE,IAAI,EAAE;AACpC,4BAA4B,EAAE,eAAe,EAAE,gCAAgC,EAAE;AACjF,4BAA4B,EAAE,IAAI,EAAE,oBAAoB,EAAE;AAC1D,4BAA4B,EAAE,GAAG,EAAE,gCAAgC,EAAE,a;;AAErE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC,+CAA+C,YAAY;AAC3D;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,wCAAwC;AACnE;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2CAA2C,uBAAuB;AAClE;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2CAA2C,0BAA0B;AACrE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B,4DAA4D;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,oCAAoC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kC;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B,wBAAwB;AACvD;AACA;AACA;AACA;AACA;AACA,qB;;AAEA;AACA;AACA;AACA;AACA;AACA,qB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,2BAA2B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;;AAEA,6B;AACA,U;;AAEA;AACA;AACA;;AAEA;;AAEA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;;AAEA,6B;AACA,U;;;;AAIA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA,uCAAuC,wBAAwB;AAC/D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qB;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wBAAwB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,0E;AACA;AACA;AACA;AACA;AACA,iC;AACA,6D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mCAAmC,+BAA+B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,uBAAuB;AAC1D,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uBAAuB;AACtD;AACA;;AAEA;AACA,mCAAmC,+BAA+B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;;AAEA;AACA;AACA,mCAAmC,2BAA2B;AAC9D;;AAEA;AACA;AACA,2CAA2C,2BAA2B;AACtE;AACA;;AAEA;AACA,+CAA+C,mCAAmC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,6BAA6B,YAAY;;AAEzC;AACA;AACA;AACA;AACA;;;AAGA,yBAAyB;AACzB;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,mCAAmC,uBAAuB;AAC1D;AACA;;AAEA;AACA;AACA,uCAAuC,+BAA+B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uBAAuB;AACtD;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mCAAmC,2BAA2B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,+BAA+B,uBAAuB;AACtD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,uCAAuC;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kCAAkC;AACjE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,0BAA0B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,0BAA0B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,2BAA2B;AAC1D;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,uCAAuC,mBAAmB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iCAAiC;AACpE,uEAAuE;AACvE,iDAAiD;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,wBAAwB;AAC3D;AACA;AACA;AACA;AACA,kF;AACA;AACA;AACA;AACA;AACA,qC;AACA;AACA;AACA;AACA;AACA,qB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,kCAAkC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oCAAoC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,kCAAkC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oCAAoC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+D;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA,2BAA2B;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gCAAgC;;AAEhC,qCAAqC;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA,oC;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,mBAAmB;AAClD,yF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,uCAAuC;AAC1E;AACA,sE;AACA;AACA;AACA;AACA;AACA,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,O;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uCAAuC;AACtE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,qCAAqC;AAChE;;AAEA;AACA;AACA;AACA,uCAAuC,wCAAwC;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,S;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,a;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,uEAAuE;AACvE;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA,mDAAmD;;AAEnD;AACA;AACA,2CAA2C,6BAA6B;AACxE;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,yBAAyB;AAChE;;AAEA,2CAA2C,6BAA6B;AACxE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mCAAmC,qBAAqB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,8F;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gB;AACjB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,6E;AACA;AACA;AACA,8DAA8D,oBAAoB;AAClF;AACA;AACA;AACA,O;AACA;AACA;AACA;AACA;AACA;AACA,8B;AACA;AACA;AACA;AACA;AACA,iB;AACA;AACA;AACA,0B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,EAAE;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2C;AACA,wC;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,mBAAmB;AAC9C;AACA,yEAAyE;AACzE,oGAAoG;AACpG;AACA;AACA;AACA;AACA;AACA;AACA,a;AACA;;AAEA;AACA;AACA,2B;;AAEA;AACA;AACA;;AAEA;AACA,wC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wF;AACA,yB;AACA;AACA;AACA,6C;AACA;AACA;AACA;AACA,a;AACA;;AAEA;AACA;;AAEA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;;AAEA,4D;AACA;AACA;;AAEA,uBAAuB,6CAA6C;AACpE;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,kBAAkB;AACjD,2E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,+D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iB;AACA;;AAEA;AACA;;;AAGA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,mC;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wC;;AAEA;AACA;AACA;AACA,uD;;AAEA;AACA;AACA;AACA;AACA,gE;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,EAAE,4B;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kF;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA2B,EAAE;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA,mCAAmC,4BAA4B;AAC/D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,+BAA+B;AAC1D;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,+BAA+B,8BAA8B;AAC7D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,wCAAwC;AACrE;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA,a;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,a;;AAEA;;AAEA;AACA;AACA;AACA,2BAA2B,4BAA4B;AACvD;AACA;AACA;AACA,2BAA2B,8BAA8B;AACzD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,8BAA8B;AACzD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2BAA2B,4BAA4B;AACvD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2EAA2E;AAC3E;;AAEA;AACA;AACA,qB;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E;;AAE3E;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kD;;AAEA;AACA;AACA;AACA;AACA,a;;AAEA,mC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qF;AACA,uDAAuD;AACvD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kDAAkD,qCAAqC;AACvF;AACA;AACA;AACA;;AAEA;AACA,kDAAkD,qCAAqC;AACvF;AACA;AACA;AACA;;AAEA;AACA,kDAAkD,qCAAqC;AACvF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,2BAA2B,4BAA4B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iB;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B,2BAA2B;AACtD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,2BAA2B,4BAA4B;AACvD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA2B,8BAA8B;AACzD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4BAA4B;AACvD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,0C;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,sBAAsB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,uBAAuB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2CAA2C,2CAA2C;AACtF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA,uCAAuC,uBAAuB;AAC9D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,2CAA2C;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,2BAA2B,kCAAkC;AAC7D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,oBAAoB;AACnE;AACA,uDAAuD,4BAA4B;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC,4BAA4B;AAC/D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC,iBAAiB;AACpD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,mCAAmC,4BAA4B;;AAE/D;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yCAAyC,wBAAwB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,kCAAkC;;AAEzE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,gCAAgC;AAC7D;AACA;;AAEA,6BAA6B,gCAAgC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+BAA+B,4BAA4B;;AAE3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,2B;;AAEA,8DAA8D;AAC9D;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,wFAAwF,oBAAoB;AAC5G,iB;AACA,a;;AAEA;AACA,mD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oE;AACA;AACA;AACA;;AAEA;AACA,8B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wE;AACA,qB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0E;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iCAAiC,gCAAgC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uCAAuC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,mCAAmC,uBAAuB;AAC1D;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,2CAA2C,gCAAgC,U;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,6BAA6B;AACxD;AACA;AACA;AACA;AACA,mDAAmD,gDAAgD;AACnG;AACA;AACA;AACA;AACA,8EAA8E;AAC9E,yB;AACA;AACA;AACA;AACA,uCAAuC,mBAAmB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,uBAAuB,E;AAC1E;AACA;AACA;AACA;AACA;AACA,2BAA2B,oBAAoB;AAC/C;AACA,+CAA+C,iDAAiD;AAChG;AACA;AACA;AACA,2EAA2E;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,uBAAuB;AAC9D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6BAA6B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6BAA6B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0CAA0C;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,6BAA6B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,EAAE,oCAAoC,EAAE,wBAAwB,EAAE;AACtF,qG;AACA;AACA;AACA,oBAAoB,EAAE,oCAAoC,EAAE,6BAA6B,EAAE;AAC3F,qG;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,EAAE,aAAa,EAAE,kBAAkB,EAAE,KAAK,EAAE;AAChE;AACA,4E;AACA;AACA;;AAEA;AACA;AACA,0E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,EAAE,oCAAoC,EAAE,wBAAwB,EAAE;AACtF;AACA,8E;AACA;AACA;AACA,oBAAoB,EAAE,oCAAoC,EAAE,6BAA6B,EAAE;AAC3F;AACA,6E;AACA;AACA;AACA,oBAAoB,EAAE,aAAa,EAAE,kBAAkB,EAAE,KAAK,EAAE;AAChE;AACA,0E;AACA;;AAEA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,EAAE,oCAAoC,EAAE,wBAAwB,EAAE;AACtF,qG;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,EAAE,oCAAoC,EAAE,wBAAwB,EAAE;AACtF,mG;AACA;AACA;AACA,oBAAoB,EAAE,oCAAoC,EAAE,6BAA6B,EAAE;AAC3F,mG;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,a;AACA;AACA;AACA;AACA,6BAA6B,wCAAwC;AACrE;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS,E;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,2DAA2D;AACpF,yBAAyB,yCAAyC;AAClE,yBAAyB,0CAA0C;AACnE,yBAAyB,wCAAwC;AACjE,yBAAyB;AACzB,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,6BAA6B;AAChE;AACA;AACA;AACA;AACA;AACA,uCAAuC,+CAA+C;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,iE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yB;AACA,M;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,M;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,E;;AAEN,cAAc;AACd;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,6CAA6C,WAAW;AACxD,6CAA6C,OAAO;AACpD,6CAA6C,SAAS;;AAEtD;AACA;AACA,iDAAiD,cAAc;AAC/D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uCAAuC,6BAA6B;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mBAAmB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,mCAAmC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,UAAU;AAC3D,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mCAAmC,mCAAmC;AACtE;;AAEA;AACA;AACA,yCAAyC,kBAAkB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,OAAO;AAC1E;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,yC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8EAA8E,OAAO;AACrF,oBAAoB,SAAS,2CAA2C,WAAW;AACnF;AACA,sBAAsB,SAAS,GAAG,UAAU;AAC5C,qBAAqB,SAAS,SAAS,SAAS;AAChD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gBAAgB;AAC3C,uCAAuC;AACvC;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,qBAAqB;AAChD;AACA;AACA;;AAEA;;AAEA;AACA,mCAAmC,sBAAsB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,qBAAqB;AAChD;AACA,+DAA+D;AAC/D;AACA;AACA;AACA,mCAAmC,sBAAsB;AACzD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,kCAAkC;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iEAAiE;AACjE,qEAAqE;AACrE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA,uDAAuD,iCAAiC;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,aAAa;AACnF;AACA;AACA;AACA;AACA;AACA,qEAAqE,aAAa;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0DAA0D;AAC1D;AACA,2DAA2D,0BAA0B;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,aAAa;AAC9E;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,gCAAgC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA;;AAEA,iDAAiD;AACjD;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA,qB;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,EAAE,oCAAoC,EAAE,wBAAwB,EAAE;AACtF;AACA,qF;AACA;AACA;AACA,oBAAoB,EAAE,oCAAoC,EAAE,6BAA6B,EAAE;AAC3F;AACA,oF;AACA;AACA;AACA,oBAAoB,EAAE,aAAa,EAAE,kBAAkB,EAAE,KAAK,EAAE;AAChE;AACA,iF;AACA;;AAEA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA,iCAAiC;AACjC;;AAEA;AACA;;AAEA;AACA,oBAAoB,EAAE,oCAAoC,EAAE,wBAAwB,EAAE;AACtF,qG;AACA;AACA;AACA,oBAAoB,EAAE,oCAAoC,EAAE,6BAA6B,EAAE;AAC3F,qG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,EAAE,aAAa,EAAE,kBAAkB,EAAE,KAAK,EAAE;AAChE;AACA,iF;AACA;AACA,iCAAiC;AACjC;;AAEA;AACA;AACA,oBAAoB,EAAE,oCAAoC,EAAE,wBAAwB,EAAE;AACtF,qG;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,EAAE,oCAAoC,EAAE,wBAAwB,EAAE;AACtF,6G;AACA;AACA;AACA,oBAAoB,EAAE,oCAAoC,EAAE,6BAA6B,EAAE;AAC3F,6G;AACA;AACA;AACA;;AAEA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA,oC;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;;AAGA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,8CAA8C;;AAE9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sDAAsD;AACtD;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;;AAE9B,0BAA0B;AAC1B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mDAAmD;AACnD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F,UAAU;AACpG;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uD;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA,mDAAmD;AACnD,6CAA6C;AAC7C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,kD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD,uDAAuD;;AAEvD;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;;AAEtC;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,+C;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA,iB;;AAEA;AACA;AACA,yC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wBAAwB;AACvD;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,4C;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA,4D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F,UAAU;AACpG;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,2D;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,yBAAyB,YAAY;AACrC;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,EAAE,yCAAyC,EAAE;AACxE;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA,S;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,6BAA6B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8E;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa,E;;AAEb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa,E;;AAEb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa,E;;AAEb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa,E;;AAEb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa,E;;AAEb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa,E;;AAEb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa,E;;AAEb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa,E;;AAEb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa,E;;AAEb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa,E;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa,E;;AAEb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa,E;;AAEb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa,E;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,yDAAyD;AACzD;AACA;AACA;AACA;AACA,6CAA6C;AAC7C,wDAAwD;AACxD;AACA,a;AACA;;AAEA;AACA;;AAEA,uC;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,uDAAuD;AACvD;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,sDAAsD;AACtD;AACA,a;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,uDAAuD;AACvD;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,uDAAuD;AACvD;AACA,a;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,+DAA+D;;AAE/D;AACA;AACA;AACA,a;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6E;;AAEA;AACA,gD;AACA,+C;AACA,mC;AACA,mD;;AAEA,mCAAmC,4BAA4B;AAC/D;AACA;AACA,qB;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,GAAG;AACrE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+F;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oCAAoC;AACpC;AACA,uDAAuD;AACvD,a;AACA;AACA;AACA;;AAEA;AACA,U;;AAEA;AACA;;AAEA;AACA,kCAAkC;AAClC;AACA;AACA,iEAAiE;AACjE;AACA;AACA,0F;AACA;;AAEA,sC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,0D;AACA,U;;AAEA;AACA,0E;AACA,U;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yG;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kE;AACA,S;;;AAGA;AACA;AACA;AACA;;AAEA;AACA,gDAAgD;AAChD;AACA,+EAA+E;;AAE/E;AACA;AACA;AACA;;AAEA;AACA,iD;AACA;AACA;AACA;AACA,SAAS;AACT,mCAAmC;AACnC;AACA;;AAEA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,6BAA6B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oEAAoE,iBAAiB;AACrF;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA,iB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA","file":"./dist/progress.auth.adal.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 4bab5e00db894aadbb51","/*\r\n * progress.auth.extension.js\r\n * http://github.com/RobinHerbots/jsdo.adal\r\n * Copyright (c) 2018 -\tRobin Herbots\r\n * Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)\r\n * Version: 0.0.0-dev\r\n */\r\nimport {progress} from 'jsdo';\r\n\r\n//define azure session\r\nif ((typeof Object.defineProperty) == 'function')\r\n    Object.defineProperty(progress.data.Session, 'AUTH_TYPE_ADAL', {\r\n        value: \"adal\", enumerable: true\r\n    });\r\nelse progress.data.Session.AUTH_TYPE_ADAL = \"adal\";\r\n\r\n//extend the AuthenticationProvider\r\nvar authProviderBase = progress.data.AuthenticationProvider;\r\nprogress.data.AuthenticationProvider = function (initObject) {\r\n    var authProv, authModel = (initObject && initObject.authenticationModel.toLowerCase()),\r\n        adalConfig = (initObject && initObject.adalConfig);\r\n    switch (authModel) {\r\n        case progress.data.Session.AUTH_TYPE_ADAL:\r\n            authProv = new progress.data.AuthenticationProviderAdal(adalConfig);\r\n            break;\r\n        default:\r\n            authProv = authProviderBase.call(this, initObject);\r\n    }\r\n\r\n    return authProv;\r\n};\r\n\r\nvar sessionBase = progress.data.Session;\r\nprogress.data.Session = function Session(options) {\r\n    var that = this;\r\n\r\n//redefine authenticationModel property\r\n    if ((typeof Object.defineProperty) == 'function') {\r\n\r\n        Object.defineProperty(that, 'authenticationModel',\r\n            {\r\n                get: function () {\r\n                    return that._authenticationModel;\r\n                },\r\n                set: function (newval) {\r\n                    if (newval) {\r\n                        newval = newval.toLowerCase();\r\n                    }\r\n                    switch (newval) {\r\n                        case progress.data.Session.AUTH_TYPE_FORM :\r\n                        case progress.data.Session.AUTH_TYPE_BASIC :\r\n                        case progress.data.Session.AUTH_TYPE_ANON :\r\n                        case progress.data.Session.AUTH_TYPE_ADAL :\r\n                        case null :\r\n                            that._authenticationModel = newval;\r\n                            storeSessionInfo(\"authenticationModel\", newval);\r\n\r\n                            break;\r\n                        default:\r\n                            throw new Error(\"Error setting Session.authenticationModel. '\" +\r\n                                newval + \"' is an invalid value.\");\r\n                    }\r\n                },\r\n                enumerable: true,\r\n                configurable: true\r\n            });\r\n    }\r\n\r\n    var baseSession = sessionBase.call(that, options);\r\n\r\n    return that;\r\n}\r\n\r\nprogress.data.Session.prototype = sessionBase.prototype;\r\n\r\nexport default progress;\n\n\n// WEBPACK FOOTER //\n// ./lib/progress.auth.extension.js","/*\nProgress JSDO Version: 4.3.1\n\nCopyright 2012-2016 Progress Software Corporation and/or its subsidiaries or affiliates.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n/* \nprogress.util.js    Version: 4.3.1-4\n\nCopyright (c) 2014-2016 Progress Software Corporation and/or its subsidiaries or affiliates.\n\nContains support objects used by the jsdo and/or session object\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n \n    http://www.apache.org/licenses/LICENSE-2.0\n \nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n */\n\n(function () {\n    \n     /* Define these if not defined yet - they may already be defined if\n      * progress.js was included first */\n    if (typeof progress === \"undefined\") {\n        progress = {};\n    }\n    \n    if (typeof progress.data === \"undefined\") {\n        progress.data = {};\n    }\n\n    progress.util = {};\n    \n    var STRING_OBJECT_TYPE = \"String\",\n        DATE_OBJECT_TYPE = \"Date\";\n    \n    \n    /**\n     * Utility class that allows subscribing and unsubscribing from named events.\n     *\n     * @returns {progress.util.Observable}\n     */\n    progress.util.Observable = function () {\n        /*\n         * Example format of the events object.  Some event delegates may only\n         * have a function setup, others may optionally have scope, and possibly an operation filter\n         *\n         * var  events = {\n         *   afterfill : [{\n         *     scope : {},  // this is optional\n         *     fn : function () {},\n         *     operation : 'getCustomers'  // this is optional\n         *   }, ...]\n         *\n         * }\n         *\n         *\n         *\n         */\n\n        /*\n         * remove the given function from the array of observers\n         */\n        function _filterObservers(observers, fn, scope, operation) {\n            return observers.filter(function (el) {\n                if (el.fn !== fn || el.scope !== scope || el.operation !== operation) {\n                    return el;\n                }\n            }, this);\n        }\n\n        /*\n         * validate the arguments passed to the subscribe function\n         */\n        this.validateSubscribe = function (args, evt, listenerData) {\n\n            if (args.length >= 2 && (typeof args[0] === 'string') && (typeof args[1] === 'string')) {\n                listenerData.operation = args[1];\n                listenerData.fn = args[2];\n                listenerData.scope = args[3];\n\n            } else if (args.length >= 2 && (typeof args[0] === 'string') && (typeof args[1] === 'function')) {\n                listenerData.operation = undefined;\n                listenerData.scope = args[2];\n                listenerData.fn = args[1];\n            } else {\n                throw new Error();\n            }\n\n        };\n\n\n        /*\n         * bind the specified function so it receives callbacks when the\n         * specified event name is called. Event name is not case sensitive.\n         * An optional scope can be provided so that the function is executed\n         * in the given scope.  If no scope is given, then the function will be\n         * called without scope.\n         *\n         * If the same function is registered for the same event a second time with\n         * the same scope the original subscription is removed and replaced with the new function\n         * to be called in the new scope.\n         *\n         * This method has two signatures.\n         *\n         * Signature 1:\n         * @param evt    The name of the event to bind a handler to. String. Not case sensitive.\n         * @param fn     The function callback for the event . Function.\n         * @param scope  The scope the function is to be run in. Object. Optional.\n         *\n         * Signature 2:\n         *\n         * @param evt        The name of the event to bind a handler to. String. Not case sensitive\n         * @param operation  The name of the operation to bind to. String. Case sensitive.\n         * @param fn         The function callback for the event . Function.\n         * @param scope      The scope the function is to be run in. Object. Optional.\n\n         */\n        this.subscribe = function (evt, operation, fn, scope) {\n            var listenerData,\n                observers;\n                \n            if (!evt) {\n                throw new Error(progress.data._getMsgText(\"jsdoMSG037\", this.toString(), \"subscribe\"));\n            }\n\n            if (typeof evt !== 'string') {\n                throw new Error(progress.data._getMsgText(\"jsdoMSG033\", this.toString(), \n                    \"subscribe\", progress.data._getMsgText(\"jsdoMSG039\")));\n            }\n\n            this._events = this._events || {};\n            evt = evt.toLowerCase();\n            listenerData = {fn: undefined, scope: undefined, operation: undefined};\n\n            try {\n                this.validateSubscribe(arguments, evt, listenerData);\n            }\n            catch (e) {\n                throw new Error(progress.data._getMsgText(\"jsdoMSG033\", this.toString(), \n                                            \"subscribe\", e.message));\n            }\n\n            observers = this._events[evt] || [];\n\n            // make sure we don't add duplicates\n            observers = _filterObservers(observers, listenerData.fn, \n                listenerData.scope, listenerData.operation);\n            observers.push(listenerData);\n            this._events[evt] = observers;\n\n            return this;\n        };\n\n        /*\n         * remove the specified function so it no longer receives events from\n         * the given name. event name is not case sensitive.\n         *\n         * This method has two signaturues.\n         * Signature 1:\n         * @param evt    Required. The name of the event for which to unbind the given function. String.\n         * @param fn     Required. The function to remove from the named event. Function.\n         * @param scope  Optional. The function scope in which to remove the listener. Object.\n         *\n         * Signature 2:\n         *\n         * @param evt       Required. The name of the event for which to unbind the given function. \n                            String. Not case sensitive\n         * @param operation Required.  The name of the operation to receive events. String. Case Sensitive\n         * @param fn        Required. The function to remove from the named event. Function.\n         * @param scope     Optional. The function scope in which to remove the listener. Object.\n         *\n         */\n        this.unsubscribe = function (evt, operation, fn, scope) {\n            var listenerData,\n                observers;\n\n            if (!evt) {\n                throw new Error(progress.data._getMsgText(\"jsdoMSG037\", this.toString(), \"unsubscribe\"));\n            }\n\n            if (typeof evt !== 'string') {\n                throw new Error(progress.data._getMsgText(\"jsdoMSG033\", this.toString(), \n                    \"unsubscribe\", progress.data._getMsgText(\"jsdoMSG037\")));\n            }\n\n            this._events = this._events || {};\n            evt = evt.toLowerCase();\n            listenerData = {fn: undefined, scope: undefined, operation: undefined};\n            try {\n                this.validateSubscribe(arguments, evt, listenerData);\n            }\n            catch (e) {\n            //  throw new Error(\"Invalid signature for unsubscribe. \" + e.message);\n                throw new Error(progress.data._getMsgText(\"jsdoMSG033\", this.toString(), \n                                        \"unsubscribe\", e.message));\n            }\n\n            observers = this._events[evt] || [];\n            if (observers.length > 0) {\n                this._events[evt] = _filterObservers(observers, listenerData.fn, \n                    listenerData.scope, listenerData.operation);\n            }\n\n            return this;\n        };\n\n        /*\n         * trigger an event of the given name, and pass the specified data to\n         * the subscribers of the event. Event name is not case sensitive.\n         * A variable numbers of arguments can be passed as arguments to the event handler.\n         *\n         * This method has two signatures\n         * Signature 1:\n         * @param evt  The name of the event to fire.  String.  Not case sensitive.\n         * @param operation The name of the operation. String.  Case sensitive\n         * @param args Optional.  A variable number of arguments to pass to the event handlers.\n         *\n         * Signature 2:\n         * @param evt  The name of the event to fire. String.  Not case sensitive\n         * @param args Optional.  A variable number of arguments to pass to the event handlers.\n         */\n        this.trigger = function (evt, operation, args) {\n            var observers,\n                op;\n            \n            if (!evt) {\n                throw new Error(progress.data._getMsgText(\"jsdoMSG037\", this.toString(), \"trigger\"));\n            }\n\n            this._events = this._events || {};\n            evt = evt.toLowerCase();\n            observers = this._events[evt] || [];\n            if (observers.length > 0) {\n                args = Array.prototype.slice.call(arguments);\n\n                if ((arguments.length >= 2) \n                    && (typeof evt === 'string') \n                    && (typeof operation === 'string')) {\n                    // in alt format the second argument is the event name, \n                    // and the first is the operation name\n                    op = operation;\n                    args = args.length > 2 ? args.slice(2) : [];\n                } else if (arguments.length >= 1 && (typeof evt === 'string')) {\n                    op = undefined;\n                    args = args.length > 1 ? args.slice(1) : [];\n                } else {\n                    throw new Error(progress.data._getMsgText(\"jsdoMSG033\", this.toString(), \"trigger\"));\n                }\n\n                observers.forEach(function (el) {\n                    if (el.operation === op) {\n                        el.fn.apply(el.scope, args);\n                    }\n                });\n\n            }\n\n            return this;\n        };\n\n        // unbind all listeners from the given event. If the\n        // evt is undefined, then all listeners for all events are unbound\n        // evnt name is not case sensitive\n        // @param evt  Optional. The name of the event to unbind.  If not passed, then all events are unbound\n        this.unsubscribeAll = function (evt, operation) {\n            var observers;\n            \n            if (evt) {\n                this._events = this._events || {};\n                if (typeof evt === 'string') {\n                    evt = evt.toLowerCase();\n                    observers = this._events[evt] || [];\n\n                    observers.forEach(function (el) {\n                        if (el.operation) {\n                            this.unsubscribe(evt, el.operation, el.fn, el.scope);\n                        } else {\n                            this.unsubscribe(evt, el.fn, el.scope);\n                        }\n                    }, this);\n                }\n            } else {\n                this._events = {};\n            }\n\n            return this;\n        };\n    };\n\n\n    /**\n     * Utility class that saves/reads data to localStorage\n     *\n     * @returns {progress.data.LocalStorage}\n     */\n    progress.data.LocalStorage = function LocalStorage() {\n\n        /*global localStorage */\n        if (typeof localStorage === \"undefined\") {\n            throw new Error(progress.data._getMsgText(\"jsdoMSG002\", this._name));\n        }\n\n\n        // \"Methods\"\n\n        this.saveToLocalStorage = function (name, dataObj) {\n            localStorage.setItem(name, JSON.stringify(dataObj));\n        };\n\n        this.readFromLocalStorage = function (name) {\n\n            var jsonStr = localStorage.getItem(name),\n                dataObj = null;\n                \n            if (jsonStr !== null) {\n                try {\n                    dataObj = JSON.parse(jsonStr);\n                }\n                catch (e) {\n                    dataObj = null;\n                }\n            }\n            return dataObj;\n        };\n\n        this.clearLocalStorage = function (name) {\n            localStorage.removeItem(name);\n        };\n\n    }; // End of LocalStorage\n\n    \n    /////////////////////////////////////////////////////////////////////////////////////////\n    //        Utility Functions\n    \n    /*\n     * Converts the specified filter object to an OpenEdge ABL Where String.\n     *\n     * @param tableRef  - handle to the table in jsdo, where string is applied to.\n     * @param filter - the filter object to convert.\n     *\n     * @returns - translated OE where string.\n     */\n    progress.util._convertToABLWhereString = function (tableRef, filter) {\n        var result = [],\n            logic = filter.logic || \"and\",\n            idx,\n            length,\n            field,\n            fieldInfo,\n            type,\n            format,\n            operator,\n            value,\n            ablType,\n            filters = (filter.filters) ?  filter.filters : [filter],\n\t\t\t\n            whereOperators = {\n                eq: \"=\",\n                neq: \"<>\",\n                gt: \">\",\n                gte: \">=\",\n                lt: \"<\",\n                lte: \"<=\",\n                contains : \"INDEX\", \n                doesnotcontain: \"INDEX\",\n                endswith: \"R-INDEX\", \n                startswith: \"BEGINS\"\n        };\n        \n        for (idx = 0, length = filters.length; idx < length; idx=idx+1) {\n            filter = filters[idx];\n            field = filter.field;\n            value = filter.value;\n\n            if (tableRef._name) {\n                // Use original field name instead of serialized name\n                fieldInfo = tableRef._jsdo[tableRef._name]._fields[field.toLowerCase()];\n                if (fieldInfo && fieldInfo.origName) {\n                    field = fieldInfo.origName;\n                }\n            }            \n\n            if (filter.filters) {\n                filter = progress.util._convertToABLWhereString(tableRef, filter);\n            } else {\n                operator = whereOperators[filter.operator];\n                \n                if (operator === undefined) {\n                    throw new Error(\"The operator \" + filter.operator + \" is not valid.\");\n                }\n\n                if (operator && value !== undefined) {\n                    type = progress.util._getObjectType(value);\n  \n                    // We need to build a template format string for the where string. \n                    // We'll first add positional info for the value\n                    if (type === STRING_OBJECT_TYPE) {\n                        format = \"'{1}'\";\n                        value = value.replace(/'/g, \"~'\");\n                    } \n                    else if (type === DATE_OBJECT_TYPE) {\n                        ablType = tableRef._getABLType(field);\n                        if (ablType === \"DATE\") {\n                            format = \"DATE({1:MM, dd, yyyy})\";\n                        }\n                        else if (ablType === \"DATETIME-TZ\") {\n                            // zzz here means to translate timezone offset into minutes\n                            format = \"DATETIME-TZ({1:MM, dd, yyyy, hh, mm, ss, fff, zzz})\";\n                        }\n                        else {\n                            format = \"DATETIME({1:MM, dd, yyyy, hh, mm, ss, fff})\";\n                        }\n                    } \n\t\t\t\t\telse {\n                        format = \"{1}\";\n                    }\n                    \n                    // Most where strings are in the format: field operator value. Ex. custnum < 100\n                    // An exception to this is INDEX() and R-INDEX() which have format: operator field value\n                    // Ex. R-INDEX(name, \"LTD\")\n                    if (operator === \"INDEX\" || operator === \"R-INDEX\") {\n                        if (type !== STRING_OBJECT_TYPE) {\n                            throw new Error(\"Error parsing filter object. The operator \" + filter.operator + \n                                            \" requires a string value\");\n                        }\n                        if (filter.operator === \"doesnotcontain\") {\n                            format = \"{0}(\" + \"{2}, \" + format + \") = 0\";\n                        }\n                        else if (filter.operator === \"contains\") {\n                            format = \"{0}(\" + \"{2}, \" + format + \") > 0\";\n                        }\n                        // else filter.operator = \"endswith\"\n                        else  {\n                            format = \"{2} MATCHES '*{1}'\";\n                        }\n                    }\n                    else {\n                        format = \"{2} {0} \" + format;\n                    }\n\n                    filter = progress.util._format(format, operator, value, field);\n                }\n            }\n\n            result.push(filter);\n        }\n\n        filter = result.join(\" \" + logic + \" \");\n\n        if (result.length > 1) {\n            filter = \"(\" + filter + \")\";\n        }\n\n        return filter;\n    };\n\n    \n    /*\n     * Converts the specified filter object to an SQL Query String.\n     *\n     * @param tableName  - tableName of table in jsdo, where clause is applied to.\n     * @param filter - the filter object to convert.\n     *\n     * @returns - translated SQL where clause.\n     */\n    progress.util._convertToSQLQueryString = function (tableRef, filter, addSelect) {\n        var result = [],\n            logic = filter.logic || \"and\",\n            idx,\n            length,\n            field,\n            type,\n            format,\n            operator,\n            value,\n            fieldFormat,\n            filters = (filter.filters) ?  filter.filters : [filter],\n            filterStr,\n            usingLike = true,\n\t\t\t\n            whereOperators = {\n                eq: \"=\",\n                neq: \"!=\",\n                gt: \">\",\n                gte: \">=\",\n                lt: \"<\",\n                lte: \"<=\",\n                contains : \"LIKE\", \n                doesnotcontain: \"NOT LIKE\",\n                endswith: \"LIKE\", \n                startswith: \"LIKE\"\n        };\n        \n        if (typeof addSelect === \"undefined\") {\n            addSelect = false;\n        }\n\n        for (idx = 0, length = filters.length; idx < length; idx=idx+1) {\n            filter = filters[idx];\n            field = filter.field;\n            value = filter.value;\n\n            if (filter.filters) {\n                filterStr = progress.util._convertToSQLQueryString(tableRef, filter, false);\n            } else {\n                operator = whereOperators[filter.operator];\n                \n                if (operator === undefined) {\n                    throw new Error(\"The operator \" + filter.operator + \" is not valid.\");\n                }\n                \n                if (operator && value !== undefined) {\n                    type = progress.util._getObjectType(value);\n                    \n                    if (operator === \"LIKE\" || operator === \"NOT LIKE\") {\n                        if (type !== STRING_OBJECT_TYPE) {\n                            throw new Error(\"Error parsing filter object. The operator \" + filter.operator + \n                                            \" requires a string value\");\n                        }\n                    }\n                    \n                     if (type === STRING_OBJECT_TYPE) {\n                        format = \"'{1}'\";\n                        value = value.replace(/'/g, \"''\");\n                    } \n                    else if (type === DATE_OBJECT_TYPE) {\n                        fieldFormat = tableRef._getFormat(field);\n                        if (fieldFormat === \"date\") {\n                            format = \"'{1:yyyy-MM-dd}'\";\n                        }\n                        else if (fieldFormat === \"date-time\") {\n                            format = \"{1:#ISO(iso)}\";\n                        }\n                        else if (fieldFormat === \"time\") {\n                            format = \"'{1:FFF}'\";\n                        } \n                    } \n\t\t\t\t\telse {\n                        format = \"{1}\";\n                    }\n                    \n                    // We need to build a template format string for the where string. \n                    // We'll first add positional info for the value, which is represented by {1}\n                    if (filter.operator === \"startswith\") {\n                        format = \"'{1}%'\";\n                    }\n                    else if (filter.operator === \"endswith\") { \n                        format = \"'%{1}'\";\n                    }\n                    else if (filter.operator === \"contains\" || filter.operator === \"doesnotcontain\") {\n                        format = \"'%{1}%'\";\n                    }\n                    else {\n                       usingLike = false;\n                    }\n                    \n                    if (usingLike) {\n                        value = value.replace(/%/g, '\\\\%');\n                        value = value.replace(/_/g, '\\\\_');\n                    }\n\n                   \n                    format = \"{2} {0} \" + format;\n                    filterStr = progress.util._format(format, operator, value, field);\n                }\n            }\n\n            result.push(filterStr);\n        }\n\n        filterStr = result.join(\" \" + logic + \" \");\n\n        if (result.length > 1) {\n            filterStr = \"(\" + filterStr + \")\";\n        }\n        \n        if (addSelect === true) {\n            filterStr = \"SELECT * FROM \" + tableRef._name + \" WHERE \" + filterStr;\n        }\n\n        return filterStr;\n    };\n    \n    \n    /*\n     * Returns the object type; Example \"String\", \"Date\"\n     * Constants for object type values are defined above.\n     *\n     * @param value - the object whose type is returned\n     */\n    progress.util._getObjectType = function(value) {    \n        // Returns [object xxx]. Removing [object ]\n        return Object.prototype.toString.call(value).slice(8, -1);\n    };\n    \n    \n    /*\n     * Substitutes in a variable number of arguments into specified format string (with place-holders)\n     *\n     * @param fmt - the format string with place-holders, eg. \"{0} text {1}\".\n     *\n     * @returns - formatted string.\n     */\n    progress.util._format = function(fmt) {\n        /*jslint regexp: true*/\n        var values = arguments,\n            formatRegExp = /\\{(\\d+)(:[^\\}]+)?\\}/g;\n        /*jslint regexp: false*/\n\n        return fmt.replace(formatRegExp, function(match, index, placeholderFormat) {\n            var value = values[parseInt(index, 10) + 1];\n\n            return progress.util._toString(value, placeholderFormat ? placeholderFormat.substring(1) : \"\");\n        });\n         \n    };\n    \n    /*\n     * Converts the specified value param to a string.\n     *\n     * @param value  - object to convert\n     * @param fmt - optional format string with place-holders, eg. \"MM dd yyyy\".\n     *\n     * @returns - converted string.\n     */\n    progress.util._toString = function(value, fmt) {\n        var str;\n                    \n        if (fmt) {\n            if (progress.util._getObjectType(value) === \"Date\") {\n                return progress.util._formatDate(value, fmt);\n            } \n        }\n\n        if (typeof value === \"number\") {\n            str =  value.toString();\n        }\n        else {\n            str = (value !== undefined ? value : \"\");\n        }\n            \n        return str;\n    };\n    \n    /*\n     * Accepts string representing number and optionally pads it with \"0\"'s to conform to \n     * specified number of digits.\n     *\n     * @param number  - string representing number to pad.\n     * @param digit - number of digits desired for padded string. If not specified, default is 2.\n     *\n     * @returns - padded string representing number.\n     */\n    progress.util._pad = function (number, digits) {\n        var zeros = [\"\", \"0\", \"00\", \"000\", \"0000\"],\n            end;\n        \n        number = String(number);\n        digits = digits || 2;\n        end = digits - number.length;\n\n        if (end) {\n            return zeros[digits].substring(0, end) + number;\n        }\n        return number;\n    };\n    \n    /*\n     * Converts the specified date param to a string.\n     *\n     * @param date  - date object to convert\n     * @param fmt - format string with place-holders, eg. \"MM dd yyyy\".\n     *\n     * @returns - converted string.\n     */\n    progress.util._formatDate = function (date, format) {\n        /*jslint regexp: true*/\n        var dateFormatRegExp = \n            /dd|MM|yyyy|hh|mm|fff|FFF|ss|zzz|iso|\"[^\"]*\"|'[^']*'/g;\n        /*jslint regexp: false*/\n       \n        return format.replace(dateFormatRegExp, function (match) {\n            var minutes,\n                result,\n                sign;\n\n            if (match === \"dd\") {\n                result = progress.util._pad(date.getDate());\n            }\n            else if (match === \"MM\") {\n                result = progress.util._pad(date.getMonth() + 1);\n            } \n            else if (match === \"yyyy\") {\n                result = progress.util._pad(date.getFullYear(), 4);\n            } \n            else if (match === \"hh\") {\n                result = progress.util._pad(date.getHours());\n            } \n            else if (match === \"mm\") {\n                result = progress.util._pad(date.getMinutes());\n            } \n            else if (match === \"ss\") {\n                result = progress.util._pad(date.getSeconds());\n            } \n            else if (match === \"fff\") {\n                result = progress.util._pad(date.getMilliseconds(), 3);\n            } \n            else if (match === \"FFF\") {\n                result = String(date.getTime());\n            } \n            else if (match === \"zzz\") {\n                // timezone is returned in minutes\n                minutes = date.getTimezoneOffset();\n                sign = minutes < 0;\n                result = (sign ? \"+\" : \"-\") + minutes;\n            } \n            else if (match === \"iso\") {\n                result = date.toISOString();\n            } \n\n            return result !== undefined ? result : match.slice(1, match.length - 1);\n        });\n    };\n\n    /*\n     * Processes settings in a jsdoSettings object.\n     * This method is used by project templates.\n     */\n    progress.util.jsdoSettingsProcessor = function jsdoSettingsProcessor(jsdoSettings) {\n        if (typeof jsdoSettings === 'object') {\n            if (jsdoSettings.authenticationModel  === undefined || jsdoSettings.authenticationModel  === \"\") {\n                jsdoSettings.authenticationModel = \"ANONYMOUS\";\n            }\n        }\n    };\n\n}()); \n\n\n\n//# sourceURL=progress.jsdo.js\n\n/* \nprogress.js    Version: 4.3.1-27\n\nCopyright (c) 2012-2016 Progress Software Corporation and/or its subsidiaries or affiliates.\n \nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n \n    http://www.apache.org/licenses/LICENSE-2.0\n  \nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n */\n\n(function () {\n\n    // \"use strict\";\n    \n    var PROGRESS_JSDO_PCT_MAX_EMPTY_BLOCKS = 20,\n        PROGRESS_JSDO_OP_STRING = [\"none\", \"create\", \"read\", \"update\", \"delete\", \"submit\"],\n        PROGRESS_JSDO_ROW_STATE_STRING = [\"\", \"created\", \"\", \"modified\", \"deleted\"];\n    \n    /* define these if not defined yet - they may already be defined if\n     progress.session.js was included first */\n    if (typeof progress === 'undefined') {\n        progress = {};\n    }\n    if (typeof progress.data === 'undefined') {\n        progress.data = {};\n    }\n\n    progress.data._nextid = 0;\n    progress.data._uidprefix = \"\" + ( Date.now ? Date.now() : (new Date().getTime()));\n\n    /* 15 - 9 */\n    var UID_MAX_VALUE = 999999999999999;\n\n    progress.data._getNextId = function () {\n        var uid = ++progress.data._nextid;\n        if (uid >= UID_MAX_VALUE) {\n            progress.data._nextid = uid = 1;\n            progress.data._uidprefix = \"\" + ( Date.now ? Date.now() : (new Date().getTime()));\n        }\n\n        return progress.data._uidprefix + \"-\" + uid;\n    };\n\n\n    var msg = {};\n    msg.msgs = {};\n//        msg numbers   0 -  99 are related to use of the API (methods and properties we expose to developers)\n//                    100 - 109 relate to network errors\n//                    110 - 998 are for miscellaneous errors\n                    \n    msg.msgs.jsdoMSG000 = \"JSDO, Internal Error: {1}\";\n    msg.msgs.jsdoMSG001 = \"JSDO: JSDO has multiple tables. Please use {1} at the table reference level.\";\n    msg.msgs.jsdoMSG002 = \"JSDO: Working record for '{1}' is undefined.\";\n    msg.msgs.jsdoMSG003 = \"JSDO: {1} function requires a function as a parameter.\";\n    msg.msgs.jsdoMSG004 = \"JSDO: Unable to find resource '{1}' in the catalog.\";\n    msg.msgs.jsdoMSG005 = \"JSDO: Data for table '{1}' was not specified in addRecords() call.\";\n    msg.msgs.jsdoMSG006 = \"JSDO: Data for JSDO was not specified in addRecords() call.\";\n    msg.msgs.jsdoMSG007 = \"JSDO: Test function in {1} must return a boolean.\";\n    msg.msgs.jsdoMSG008 = \"JSDO: Invalid keyFields parameter in addRecords() call.\";\n    msg.msgs.jsdoMSG009 = \"JSDO: KeyField '{1}' in addRecords() call was not found in the schema.\";\n    msg.msgs.jsdoMSG010 = \"JSDO: Field '{1}' in relationship was not found in the schema.\";\n    msg.msgs.jsdoMSG011 = \"UIHelper: JSDO has multiple tables. \" +\n        \"Please use {1} at the table reference level.\";\n    msg.msgs.jsdoMSG012 = \"UIHelper: Invalid {2} parameter in {1} call.\";\n    msg.msgs.jsdoMSG020 = \"JSDO: tableName parameter must be a string in addRecords() call.\";\n    msg.msgs.jsdoMSG021 = \"JSDO: addMode parameter must be specified in addRecords() call.\";\n    msg.msgs.jsdoMSG022 = \"JSDO: Invalid addMode specified in addRecords() call.\";\n    msg.msgs.jsdoMSG023 = \"JSDO: Duplicate found in addRecords() call using APPEND mode.\";\n    msg.msgs.jsdoMSG024 = \"{1}: Unexpected signature in call to {2} function.\";\n    msg.msgs.jsdoMSG025 = \"{1}: Invalid parameters in call to {2} function.\";\n    msg.msgs.jsdoMSG026 = \"JSDO: saveChanges requires a \" +\n        \"CREATE, UPDATE, DELETE or SUBMIT operation to be defined.\";\n    msg.msgs.jsdoMSG030 = \"JSDO: Invalid {1}, expected {2}.\";\n    msg.msgs.jsdoMSG031 = \"JSDO: Specified sort field name '{1}' was not found in the schema.\";\n    msg.msgs.jsdoMSG032 = \"JSDO: Before-image data already exists for record in addRecords() call.\";\n    msg.msgs.jsdoMSG033 = \"{1}: Invalid signature for {2}. {3}\";\n    msg.msgs.jsdoMSG034 = \"JSDO: In '{1}' function, JSON data is missing _id\";\n    msg.msgs.jsdoMSG035 = \"JSDO: In '{1}' function, before-image JSON data is missing prods:clientId\";\n    msg.msgs.jsdoMSG036 = \"JSDO: '{1}' can only be called for a dataset\";\n    msg.msgs.jsdoMSG037 = \"{1}: Event name must be provided for {2}.\";\n    msg.msgs.jsdoMSG038 = \"Too few arguments. There must be at least {1}.\";\n    msg.msgs.jsdoMSG039 = \"The name of the event is not a string.\";\n    msg.msgs.jsdoMSG040 = \"The event listener is not a function.\";\n    msg.msgs.jsdoMSG041 = \"The event listener scope is not an object.\";\n    msg.msgs.jsdoMSG042 = \"'{1}' is not a defined event for this object.\";\n    msg.msgs.jsdoMSG043 = \"{1}: A session object was requested to check the status of a Mobile \" +\n        \"Service named '{2}', but it has not loaded the definition of that service.\";\n    msg.msgs.jsdoMSG044 = \"JSDO: In '{1}' function, {2} is missing {3} property.\";\n    msg.msgs.jsdoMSG045 = \"JSDO: {1} function: {2} is missing {3} property.\";    \n    msg.msgs.jsdoMSG046 = \"JSDO: {1} operation is not defined.\";\n    msg.msgs.jsdoMSG047 = \"{1} timeout expired.\";\n    msg.msgs.jsdoMSG048 = \"{1}: {2} method has argument '{3}' that is missing property '{4}'.\";\n    msg.msgs.jsdoMSG049 = \"{1}: Unexpected error authenticating: {2}\";\n    msg.msgs.jsdoMSG050 = \"No token returned from server\";\n    msg.msgs.jsdoMSG051 = \"{1} authenticate() failed because the AuthenticationProvider is already managing a successful authentication.\";\n    msg.msgs.jsdoMSG052 = \"{1}: Login was not attempted because no credentials were supplied.\";\n    \n    //                    100 - 109 relate to network errors\n    msg.msgs.jsdoMSG100 = \"JSDO: Unexpected HTTP response. Too many records.\";\n    msg.msgs.jsdoMSG101 = \"Network error while executing HTTP request.\";\n\n    //                    110 - 499 are for miscellaneous errors\n    msg.msgs.jsdoMSG110 = \"Catalog error: idProperty not specified for resource '{1}'. \" +\n        \"idProperty is required {2}.\";\n    msg.msgs.jsdoMSG111 = \"Catalog error: Schema '{1}' was not found in catalog.\";\n    msg.msgs.jsdoMSG112 = \"Catalog error: Output parameter '{1}' was not found for operation '{2}'.\";\n    msg.msgs.jsdoMSG113 = \"Catalog error: Found xType '{1}' for output parameter '{2}' \" +\n        \"for operation '{3}' but xType DATASET, TABLE or ARRAY was expected.\";\n    msg.msgs.jsdoMSG114 = \"JSDO: idProperty '{1}' is missing from '{2}' record.\";\n    msg.msgs.jsdoMSG115 = \"JSDO: Invalid option specified in {1}() call.\";\n    msg.msgs.jsdoMSG116 = \"JSDO: {1} parameter must be a string in {2} call.\";\n    msg.msgs.jsdoMSG117 = \"JSDO: Schema from storage area '{1}' does not match JSDO schema\";\n\tmsg.msgs.jsdoMSG118 = \"JSDO: Plugin '{1}' was not found.\";\n\tmsg.msgs.jsdoMSG119 = \"JSDO: A mappingType is expected when 'capabilities' is set.\" +\n                                \" Please specify a plugin (ex: JFP).\";\n\tmsg.msgs.jsdoMSG120 = \"JSDO: Parameter '{2}' requires capability '{1}' in the catalog.\";\n    msg.msgs.jsdoMSG121 = \"{1}: Argument {2} must be of type {3} in {4} call.\";\n    msg.msgs.jsdoMSG122 = \"{1}: Incorrect number of arguments in {2} call. There should be {3}.\";\n    msg.msgs.jsdoMSG123 = \"{1}: A server response included an invalid '{2}' header.\";\n    msg.msgs.jsdoMSG124 = \"JSDO: autoApplyChanges is not supported for saveChanges(true) \" + \n                            \"with a temp-table. Use jsdo.autoApplyChanges = false.\";\n    msg.msgs.jsdoMSG125 = \"JSDOSession: The AuthenticationProvider needs to be managing a valid token.\";\n    \n    //                    500 - 998 are for generic errors\n    msg.msgs.jsdoMSG500 = \"{1}: '{2}' objects must contain a '{3}' property.\";\n    msg.msgs.jsdoMSG501 = \"{1}: '{2}' cannot be an empty string.\";\n    msg.msgs.jsdoMSG502 = \"{1}: The object '{2}' has an invalid value in the '{3}' property.\";\n    msg.msgs.jsdoMSG503 = \"{1}: '{2}' must be of type '{3}'\";\n    msg.msgs.jsdoMSG504 = \"{1}: {2} has an invalid value for the '{3}' property.\";    \n\n    msg.msgs.jsdoMSG998 = \"JSDO: JSON object in addRecords() must be DataSet or Temp-Table data.\";\n\n    msg.getMsgText = function (n, args) {\n        var text = msg.msgs[n],\n            i;\n        if (!text) {\n            throw new Error(\"Message text was not found by getMsgText()\");\n        }\n        for (i = 1; i < arguments.length; i += 1) {\n            text = text.replace(new RegExp('\\\\{' + i + '\\\\}', 'g'), arguments[i]);\n        }\n\n        return text;\n    };\n\n    progress.data._getMsgText = msg.getMsgText;\n\t\n\tprogress.data.PluginManager = {};\n\tprogress.data.PluginManager._plugins = {};\n\t\n\tprogress.data.PluginManager.addPlugin = function(name, plugin) {\n        if (progress.data.PluginManager._plugins[name] === undefined) {\n            progress.data.PluginManager._plugins[name] = plugin;\n\t\t}\n        else {\n            throw new Error(\"A plugin named '\" + name + \"' is already registered.\");\n\t\t}\n\t};\n\t\t\n    progress.data.PluginManager.getPlugin = function (name) {\n        return progress.data.PluginManager._plugins[name];\n    };\n\t\n    progress.data.JSIndexEntry = function JSIndexEntry(index) {\n        this.index = index;\n    };\n\n    progress.data.JSTableRef = function JSTableRef(jsdo, tableName) {\n        this._jsdo = jsdo;\n        this._name = tableName;\n        this._schema = null;\n        this._primaryKeys = null;\n        this._fields = null;\n        this._processed = {};\n        this._visited = false;\n\n        // record is used to represent the current record for a table reference\n        this.record = null;\n\n        // Data structure\n        this._data = [];\n        this._index = {};\n        this._hasEmptyBlocks = false;\n\n        // Arrays to keep track of changes\n        this._beforeImage = {};\n        this._added = [];\n        this._changed = {};\n        this._deleted = [];\n        this._lastErrors = [];\n        this._convertForServer;\n\n        this._createIndex = function () {\n            var i, block, id, idProperty;\n            this._index = {};\n            this._hasEmptyBlocks = false;\n            for (i = 0; i < this._data.length; i += 1) {\n                block = this._data[i];\n                if (!block) {\n                    this._hasEmptyBlocks = true;\n                    continue;\n                }\n                id = this._data[i]._id;\n                if (!id) {\n                    idProperty = this._jsdo._resource.idProperty;\n                    if (typeof(idProperty) == \"string\") {\n                        id = this._data[i][idProperty];\n                        if (!id) {\n                            throw new Error(msg.getMsgText(\"jsdoMSG114\", idProperty, this._name));\n                        }\n                        id += \"\";\n                    }\n                    else {\n                        id = progress.data._getNextId();\n                    }\n                    this._data[i]._id = id;\n                }\n                this._index[id] = new progress.data.JSIndexEntry(i);\n            }\n            this._needCompaction = false;\n        };\n\n        this._compact = function () {\n            var newDataArray = [], i, block;\n            \n            for (i = 0; i < this._data.length; i += 1) {\n                block = this._data[i];\n                if (block) {\n                    newDataArray.push(block);\n                }\n            }\n            this._data = newDataArray;\n            this._createIndex();\n        };\n\n        this._loadBeforeImageData = function (jsonObject, beforeImageJsonIndex, keyFields) {\n            var prodsBeforeData = jsonObject[this._jsdo._dataSetName][\"prods:before\"],\n                tmpIndex = {},\n                record,\n                record2,                \n                recordId,\n                key,\n                tmpKeyIndex,\n                id,\n                jsrecord,\n                tmpDataIndex,\n                tmpDeletedIndex,\n                i;\n\n                if (prodsBeforeData && prodsBeforeData[this._name]) {\n\n                if ((Object.keys(this._beforeImage).length !== 0) && keyFields && (keyFields.length !== 0)) {\n                    tmpKeyIndex = {};\n                    for (id in this._beforeImage) {\n                        jsrecord = this._findById(id, false);\n\n                        if (jsrecord) {\n                            key = this._getKey(jsrecord.data, keyFields);\n                            tmpKeyIndex[key] = jsrecord.data;\n                        }\n                    }\n                }\n\n                for (i = 0; i < prodsBeforeData[this._name].length; i++) {\n                    record = prodsBeforeData[this._name][i];\n                    tmpIndex[record[\"prods:id\"]] = record;\n\n                    if (record[\"prods:rowState\"] == \"deleted\") {\n                        key = undefined;\n\n                        if (keyFields && (keyFields.length !== 0)) {\n                            key = this._getKey(record, keyFields);\n                        }\n\n                        if (tmpKeyIndex) {\n                            if (tmpKeyIndex[key] !== undefined) {\n                                throw new Error(msg.getMsgText(\"jsdoMSG032\"));\n                            }\n                        }\n\n                        if ((tmpDataIndex === undefined) && keyFields && (keyFields.length !== 0)) {\n                            tmpDataIndex = {};\n                            tmpDeletedIndex = {};\n\n                            for (var j = 0; j < this._data.length; j++) {\n                                record2 = this._data[j];\n                                if (!record2) continue;\n\n                                var key2 = this._getKey(record2, keyFields);\n                                tmpDataIndex[key2] = record2;\n                            }\n\n                            // We also want to check if _deleted record already exists\n                            for (var j = 0; j < this._deleted.length; j++) {\n                                record2 = this._deleted[j].data;\n                                if (!record2) continue;\n\n                                var key2 = this._getKey(record2, keyFields);\n                                tmpDeletedIndex[key2] = record2;\n                            }\n                        }\n\n                        // First check to see if this deleted record is already in _deleted array\n                        if (key !== undefined) {\n                            record2 = tmpDeletedIndex[key];\n                            if (record2 !== undefined) {\n                                // If record is already in _deleted array, then nothing more to do here\n                                continue;\n                            }\n                        }\n\n                        if (key !== undefined) {\n                            record2 = tmpDataIndex[key];\n                            if (record2 !== undefined) {\n                                var jsrecord = this._findById(record2._id, false);\n                                if (jsrecord) jsrecord._remove(false);\n                                record._id = record2._id;\n                            }\n                        }\n\n                        if (record._id === undefined)\n                            record._id = progress.data._getNextId();\n                        var copy = {};\n                        this._jsdo._copyRecord(\n                            this._tableRef, record, copy);\n                        this._jsdo._deleteProdsProperties(copy);\n                        this._beforeImage[record._id] = copy;\n                        var jsrecord = new progress.data.JSRecord(this, copy);\n                        this._deleted.push(jsrecord);\n                    }\n                }\n            }\n\n            // Process data using jsonObject instead of _data\n            // First check if there is after-data for table. Can be called with just before-image data\n            var tableObject = jsonObject[this._jsdo._dataSetName][this._name];\n            if (tableObject) {\n                for (var i = 0; i < jsonObject[this._jsdo._dataSetName][this._name].length; i++) {\n                    record = jsonObject[this._jsdo._dataSetName][this._name][i];\n                    recordId = undefined;\n                    if (beforeImageJsonIndex && record[\"prods:id\"]) {\n                        recordId = beforeImageJsonIndex[record[\"prods:id\"]];\n                    }\n                    switch (record[\"prods:rowState\"]) {\n                        case \"created\":\n                            if (recordId === undefined) {\n                                recordId = record._id;\n                            }\n\n                            // If recordId and record._id are undefined, the record was not processed\n                            if (recordId !== undefined) {\n                                this._beforeImage[recordId] = null;\n                                this._added.push(recordId);\n                            }\n                            break;\n                        case \"modified\":\n                            var beforeRecord = tmpIndex[record[\"prods:id\"]];\n                            if (beforeRecord === undefined) {\n                                beforeRecord = {};\n                            }\n\n                            if (recordId === undefined) {\n                                recordId = record._id;\n                            }\n                            // If recordId and record._id are undefined, the record was not processed\n                            if (recordId !== undefined) {\n                                beforeRecord._id = record._id;\n\n                                var copy = {};\n                                this._jsdo._copyRecord(\n                                    this._tableRef, beforeRecord, copy);\n                                this._jsdo._deleteProdsProperties(copy);\n\n                                this._beforeImage[recordId] = copy;\n                                this._changed[recordId] = record;\n\n                                this._beforeImage[beforeRecord._id] = copy;\n                                this._changed[beforeRecord._id] = record;\n                            }\n                            break;\n                        case undefined:\n                            break; // rowState is only specified for records that have changed\n                        default:\n                            throw new Error(msg.getMsgText(\"jsdoMSG030\", \n                                \"rowState value in before-image data\", \"'created' or 'modified'\"));\n                    }\n                }\n            }\n\n            // Process prods:errors\n            var prodsErrors = jsonObject[this._jsdo._dataSetName][\"prods:errors\"];\n            if (prodsErrors) {\n                for (var i = 0; i < prodsErrors[this._name].length; i++) {\n                    var item = prodsErrors[this._name][i];\n                    var recordId = beforeImageJsonIndex[item[\"prods:id\"]];\n                    var jsrecord = this._findById(recordId, false);\n                    if (jsrecord) {\n                        jsrecord.data._errorString = item[\"prods:error\"];\n                    }\n                }\n            }\n\n            tmpIndex = null;\n        };\n\n        /*\n         * Clears all data (including any pending changes) in buffer\n         */\n        this._clearData = function () {\n            this._setRecord(null);\n\n            // Data structure\n            this._data = [];\n            this._index = {};\n            this._createIndex();\n\n            // Arrays to keep track of changes\n            this._beforeImage = {};\n            this._added = [];\n            this._changed = {};\n            this._deleted = [];\n        };\n\n        this.hasData = function () {\n            var data;\n\n            // Check if we should return this table with its nested child table's data as nested\n            if (this._jsdo._nestChildren) {\n                data = this._getDataWithNestedChildren(this._data);\n            }\n            else {\n                data = this._getRelatedData();\n            }\n\n            if (this._hasEmptyBlocks) {\n                for (var i = 0; i < data.length; i++) {\n                    var block = data[i];\n                    if (!block) {\n                        return true;\n                    }\n                }\n            }\n\n            return data.length !== 0;\n        };\n\n        this.getData = function (params) {\n            var i, \n                data,\n                numEmptyBlocks,\n                newDataArray,\n                block;\n                \n            if (this._needCompaction) {\n                this._compact();\n            }\n\n            if (params && params.filter) {\n                throw new Error(\"Not implemented in current version\");\n            }\n            // Check if we should return this table with its nested child table's data as nested\n            else if (this._jsdo._nestChildren) {\n                data = this._getDataWithNestedChildren(this._data);\n            }\n            else {\n                data = this._getRelatedData();\n            }\n\n            if (this._hasEmptyBlocks) {\n                numEmptyBlocks = 0;\n                newDataArray = [];   \n                for (i = 0; i < data.length; i += 1) {\n                    block = data[i];\n                    if (block) {\n                        newDataArray.push(block);\n                    }\n                    else {\n                        numEmptyBlocks++;\n                    }\n                }\n                if ((numEmptyBlocks * 100 / this._data.length) >= PROGRESS_JSDO_PCT_MAX_EMPTY_BLOCKS)\n                    this._needCompaction = true;\n\n                data = newDataArray;\n            }\n            else {\n                // Creates a copy of the data if sort and top are specified\n                // so that the sorting does not happen in the JSDO memory but \n                // in a copy of the records\n                if (params && (params.sort || params.top)) {\n                    newDataArray = [];\n                    for (i = 0; i < data.length; i += 1) {\n                        newDataArray.push(data[i]);\n                    }\n                    data = newDataArray;\n                }\n            }\n\n            if (params && (params.sort || params.top)) {\n                if (params.sort) {\n                    // Converts sort option from Kendo UI to sort option used by the JSDO\n                    sortFields = [];\n                    for (i = 0; i < params.sort.length; i += 1) {\n                        field = params.sort[i].field;\n                        if (params.sort[i].dir == \"desc\") {\n                            field += \":DESC\";\n                        }\n                        sortFields.push(field);\n                    }                                                                             \n                    \n                    // Obtain sortObject from sort options to get compare functions\n                    var sortObject = this._processSortFields(sortFields);\n                    if (sortObject.sortFields && sortObject.sortFields.length > 0) {\n                        sortObject.tableRef = this;\n                        data.sort(this._getCompareFn(sortObject));\n                    }                \n                }\n\n                if (params.top) {\n                    if (typeof(params.skip) == \"undefined\") {\n                        params.skip = 0;\n                    }\n                \n                    data = data.splice(params.skip, params.top);\n                }\n            }\n            \n            return data;\n        };\n\n        this._recToDataObject = function (record, includeChildren) {\n            var array = [record];\n            var dataObject = array;\n\n            if (typeof(includeChildren) == 'undefined') {\n                includeChildren = false;\n            }\n            if (this._jsdo._dataSetName) {\n                dataObject = {};\n                dataObject[this._jsdo._dataSetName] = {};\n                dataObject[this._jsdo._dataSetName][this._name] = array;\n                if (includeChildren && this._children.length > 0) {\n                    var jsrecord = this._findById(record._id, false);\n                    if (jsrecord) {\n                        for (var i = 0; i < this._children.length; i++) {\n                            var tableName = this._children[i];\n                            dataObject[this._jsdo._dataSetName][tableName] = \n                                this._jsdo._buffers[tableName]._getRelatedData(jsrecord);\n                        }\n                    }\n                }\n            }\n            else {\n                if (this._jsdo._dataProperty) {\n                    dataObject = {};\n                    dataObject[this._jsdo._dataProperty] = array;\n                }\n            }\n            return dataObject;\n        };\n\n        this._recFromDataObject = function (dataObject) {\n            var data = {};\n            if (dataObject) {\n                if (this._jsdo._dataSetName) {\n                    if (dataObject[this._jsdo._dataSetName])\n                        data = dataObject[this._jsdo._dataSetName][this._name];\n                }\n                else {\n                    if (this._jsdo._dataProperty) {\n                        if (dataObject[this._jsdo._dataProperty])\n                            data = dataObject[this._jsdo._dataProperty];\n                    }\n                    else if (dataObject.data) {\n                        data = dataObject.data;\n                    }\n                    else {\n                        data = dataObject;\n                    }\n                }\n            }\n\n            return data instanceof Array ? data[0] : data;\n        };\n\n        // Property: schema\n        this.getSchema = function () {\n            return this._schema;\n        };\n        this.setSchema = function (schema) {\n            this._schema = schema;\n        };\n        \n        // Private method that returns the ABL data type for the specified field\n        this._getABLType = function (fieldName) {\n            var i, schema;\n\t\t\n            schema = this.getSchema();\n\t\t\n            for (i = 0; i < schema.length; i++) {\n                if (schema[i].name == fieldName) {\n                    return  schema[i].ablType;\n                }\n            }\n\n            return undefined;\t\n        };  \n\n        // Private method that returns format property (from catalog) for the specified field\n        this._getFormat = function (fieldName) {\n            var i, schema;\n\t\t\n            schema = this.getSchema();\n\t\t\n            for (i = 0; i < schema.length; i++) {\n                if (schema[i].name == fieldName) {\n                    return  schema[i].format;\n                }\n            }\n\n            return undefined;\t\n        };  \n\n\n\n        this.add = function (values) {\n            return this._add(values, true, true);\n        };\n \n        // Alias for add() method\n        this.create = this.add;\n\n        this._add = function (values, trackChanges, setWorkingRecord) {\n            if (typeof(trackChanges) == 'undefined') {\n                trackChanges = true;\n            }\n            if (typeof(setWorkingRecord) == 'undefined') {\n                setWorkingRecord = true;\n            }\n            var record = {},\n                i,\n                j,\n                value,\n                prefixElement,\n                name;\n\n            if (typeof values === \"undefined\") {\n                values = {};\n            }\n            \n            // Assign values from the schema\n            var schema = this.getSchema();\n            for (i = 0; i < schema.length; i++) {\n                var fieldName = schema[i].name;\n                if (schema[i].type == \"array\") {\n                    record[fieldName] = [];\n                    if (schema[i].maxItems) {\n                        for (var j = 0; j < schema[i].maxItems; j++) {\n                            record[fieldName][j] = this._jsdo._getDefaultValue(schema[i]);\n                        }\n                    }\n                    \n                    // Assign array values from object parameter\n                    value = values[fieldName];\n                    if (typeof value != \"undefined\") {\n                        record[fieldName] = value;\n                        delete values[fieldName];\n                    }                    \n                    // Assign values from individual fields from flattened arrays\n                    prefixElement = this._jsdo._getArrayField(fieldName);\n                    if (!record[fieldName]) {\n                        record[fieldName] = [];\n                    }\n                    for (j = 0; j < schema[i].maxItems; j += 1) {\n                        name = prefixElement.name + (j+1);\n                        value = values[name];\n                        if (typeof value != \"undefined\") {\n                            if (!this._fields[name.toLowerCase()]) {\n                                // Skip element if a field with the same name exists                                \n                                // Remove property from object for element since it is not part of the actual schema\n                                delete values[prefixElement.name + (j+1)];                            \n                                if (typeof value == 'string' && schema[i].items.type != 'string') {\n                                    value = this._jsdo._convertType(value,\n                                                                              schema[i].items.type,\n                                                                              null);\n                                }                                \n                                record[fieldName][j] = value;                                \n                            }\n                        }\n                    }\n                }\n                else {\n                    record[fieldName] = this._jsdo._getDefaultValue(schema[i]);\n                }\n            }\n\n            // Assign values based on a relationship\n            if (this._jsdo.useRelationships && this._relationship && this._parent) {\n                if (this._jsdo._buffers[this._parent].record) {\n                    for (var j = 0; j < this._relationship.length; j++) {\n                        record[this._relationship[j].childFieldName] =\n                        this._jsdo._buffers[this._parent].record.data[this._relationship[j].parentFieldName];\n                    }\n                }\n                else\n                    throw new Error(msg.getMsgText(\"jsdoMSG002\", this._parent));\n            }\n            // Assign values from object parameter\n            for (var v in values) {\n                record[v] = values[v];\n            }\n\n            // Specify _id field - do not use schema default        \n            var id;\n            var idProperty;\n            if ((idProperty = this._jsdo._resource.idProperty) !== undefined) {\n                id = record[idProperty];\n            }\n            if (!id) {\n                id = progress.data._getNextId();\n            }\n            else {\n                id += \"\";\n            }\n            record._id = id;\n\n            if (this.autoSort\n                && this._sortRecords\n                && (this._sortFn !== undefined || this._sortObject.sortFields !== undefined)) {\n                if (this._needsAutoSorting) {\n                    this._data.push(record);\n                    this._sort();\n                }\n                else {\n                    // Find position of new record in _data and use splice\n                    for (var i = 0; i < this._data.length; i++) {\n                        if (this._data[i] === null) continue; // Skip null elements\n                        var ret = this._sortFn ?\n                            this._sortFn(record, this._data[i]) :\n                            this._compareFields(record, this._data[i]);\n                        if (ret == -1) break;\n                    }\n                    this._data.splice(i, 0, record);\n                }\n                this._createIndex();\n            }\n            else {\n                this._data.push(record);\n                this._index[record._id] = new progress.data.JSIndexEntry(this._data.length - 1);\n            }\n\n            var jsrecord = new progress.data.JSRecord(this, record);\n\n            // Set record property ignoring relationships\n            if (setWorkingRecord)\n                this._setRecord(jsrecord, true);\n\n            if (trackChanges) {\n                // Save before image\n                this._beforeImage[record._id] = null;\n                // End - Save before image\n                this._added.push(record._id);\n            }\n            return jsrecord;\n        };\n\n        /*\n         * Returns records related to the specified jsrecord.\n         * If jsrecord is not specified the parent working record is used.\n         */\n        this._getRelatedData = function (jsrecord) {\n            var data = [];\n\n            if (this._data.length === 0) return data;\n\n            if (typeof(jsrecord) == 'undefined') {\n                if (this._jsdo.useRelationships && this._relationship && this._parent) {\n                    jsrecord = this._jsdo._buffers[this._parent].record;\n                    if (!jsrecord)\n                        throw new Error(msg.getMsgText(\"jsdoMSG002\", this._parent));\n                }\n            }\n            if (jsrecord) {\n                // Filter records using relationship\n                for (var i = 0; i < this._data.length; i++) {\n                    var block = this._data[i];\n                    if (!block) continue;\n\n                    var match = false;\n                    for (var j = 0; j < this._relationship.length; j++) {\n                        match = (jsrecord.data[this._relationship[j].parentFieldName] == \n                            this._data[i][this._relationship[j].childFieldName]);\n                        if (!match) break;\n                    }\n                    if (match)\n                        data.push(this._data[i]);\n                }\n            }\n            else\n                data = this._data;\n\n            return data;\n        };\n\n\n        // This method is called on a parent table that has child tables \n        // where the relationship is specified as NESTED.\n        // It returns a json array that contains the parent rows. \n        // If a parent row is involved in nested relationship,\n        // then references to the child rows are added \n        // to the parent row in a child table array (providing the nested format)\n        // We are using the internal jsdo _data arrays,\n        // and adding a child table array to each parent row that has children.\n        // Once the caller is done with the nested data, they can call jsdo._unnestData() \n        // which removes these child table references\n        this._getDataWithNestedChildren = function (data) {\n\n            // Walk through all the rows and determine if any of its child tables\n            // should be associated (nested) with the current record\n            for (var i = 0; i < data.length; i++) {\n                var parentRecord = data[i];\n\n                // Now walk thru the parent's children to find any nested children\n                if (this._children && this._children.length > 0) {\n                    for (var j = 0; j < this._children.length; j++) {\n                        var childBuf = this._jsdo._buffers[this._children[j]];\n\n                        if (childBuf._isNested) {\n                            // If child is nested, then we should walk child records to find matches\n                            for (var k = 0; k < childBuf._data.length; k++) {\n                                var childRecord = childBuf._data[k];\n                                if (!childRecord) continue;\n\n                                var match = false;\n                                for (var m = 0; m < childBuf._relationship.length; m++) {\n                                    match = (parentRecord[childBuf._relationship[m].parentFieldName] ==\n                                    childRecord[childBuf._relationship[m].childFieldName]);\n                                    if (!match) break;\n                                }\n                                if (match) {\n                                    // Make sure that this parentRecord has an array for its child rows\n                                    if (!parentRecord[childBuf._name]) {\n                                        parentRecord[childBuf._name] = [];\n                                    }\n                                    parentRecord[childBuf._name].push(childRecord);\n                                }\n\n\n                            } // end for; finished adding all child rows for parentRecord\n\n                            // The child table may have its own nested children so call recursively\n                            // Use child row array in current parentRecord\n                            if (childBuf._hasNestedChild()) {\n                                childBuf._getDataWithNestedChildren(parentRecord[childBuf._name]);\n                            }\n\n\n                        } // end if (childBuf._isNested)\n                    }\n                }\n\n\n            }\n            return data;\n\n        };\n\n        this._findFirst = function () {\n            if (this._jsdo.useRelationships && this._relationship && this._parent) {\n                if (this._jsdo._buffers[this._parent].record) {\n                    // Filter records using relationship\n                    for (var i = 0; i < this._data.length; i++) {\n                        var block = this._data[i];\n                        if (!block) continue;\n\n                        var match = false;\n                        var parentFieldName, childFieldName;\n                        for (var j = 0; j < this._relationship.length; j++) {\n                            parentFieldName = this._relationship[j].parentFieldName;\n                            childFieldName = this._relationship[j].childFieldName;\n                            match = (this._jsdo._buffers[this._parent].record.data[parentFieldName] == \n                                this._data[i][childFieldName]);\n                            if (!match) break;\n                        }\n                        if (match) {\n                            return new progress.data.JSRecord(this, this._data[i]);\n                        }\n                    }\n                }\n            }\n            else {\n                for (var i = 0; i < this._data.length; i++) {\n                    var block = this._data[i];\n                    if (!block) continue;\n\n                    return new progress.data.JSRecord(this, this._data[i]);\n                }\n            }\n\n\n            return undefined;\n        };\n\n        this._setRecord = function (jsrecord, ignoreRelationships) {\n            if (jsrecord) {\n                this.record = jsrecord;\n            }\n            else {\n                this.record = undefined;\n            }\n\n            // Set child records only if useRelationships is true\n            if (this._jsdo.useRelationships) {\n                ignoreRelationships = ((typeof(ignoreRelationships) == 'boolean') && ignoreRelationships);\n\n                if (this._children && this._children.length > 0) {\n                    for (var i = 0; i < this._children.length; i++) {\n                        var childTable = this._jsdo._buffers[this._children[i]];\n                        if (!ignoreRelationships && this.record && childTable._relationship) {\n                            childTable._setRecord(childTable._findFirst());\n                        }\n                        else {\n                            childTable._setRecord(undefined, ignoreRelationships);\n                        }\n                    }\n                }\n            }\n\n            if (this._jsdo._defaultTableRef) {\n                this._jsdo.record = this.record;\n            }\n        };\n\n        this.assign = function (values) {\n            if (this.record) {\n                return this.record.assign(values);\n            }\n            else\n                throw new Error(msg.getMsgText(\"jsdoMSG002\", this._name));\n        };\n\n        // Alias for assign() method\n        this.update = this.assign;\n\n        this.remove = function () {\n            if (this.record) {\n                return this.record._remove(true);\n            }\n            else\n                throw new Error(msg.getMsgText(\"jsdoMSG002\", this._name));\n        };\n\n        this._remove = function (bTrackChanges) {\n            if (this.record) {\n                return this.record._remove(bTrackChanges);\n            }\n            else\n                throw new Error(msg.getMsgText(\"jsdoMSG002\", this._name));\n        };\n\n        this.getId = function () {\n            if (this.record) {\n                return this.record.data._id;\n            }\n            else\n                return 0;\n        };\n\n\t\t// getErrors() - JSTableRef\n\t\tthis.getErrors = function () {\n\t\t\treturn this._lastErrors;\n\t\t};\n\n        this.getErrorString = function () {\n            if (this.record) {\n                return this.record.data._errorString;\n            }\n            else\n                return 0;\n        };\n\n        this.findById = function (id) {\n            return this._findById(id, true);\n        };\n\n        this._findById = function (id, setWorkingRecord) {\n            if (typeof(setWorkingRecord) == 'undefined') {\n                setWorkingRecord = true;\n            }\n            if (id && this._index[id]) {\n                var record = this._data[this._index[id].index];\n                this.record = record ? (new progress.data.JSRecord(this, record)) : null;\n                if (setWorkingRecord)\n                    this._setRecord(this.record);\n                return this.record;\n            }\n\n            if (setWorkingRecord)\n                this._setRecord(null);\n            return null;\n        };\n\n        /*\n         * Finds a record in the JSDO memory using the specified function to determine the record.\n         */\n        this.find = function (fn) {\n            if (typeof(fn) != 'function') {\n                throw new Error(msg.getMsgText(\"jsdoMSG003\", \"find()\"));\n            }\n            var data = this._getRelatedData();\n\n            for (var i = 0; i < data.length; i++) {\n                var block = data[i];\n                if (!block) {\n                    continue;\n                }\n                this._setRecord(new progress.data.JSRecord(this, data[i]));\n                var result = fn(this.record);\n                if (typeof(result) != 'boolean') {\n                    throw new Error(msg.getMsgText(\"jsdoMSG007\", \"find()\"));\n                }\n                if (result) {\n                    return this.record;\n                }\n            }\n\n            this._setRecord(null);\n            return null;\n        };\n\n        /*\n         * Loops through the records  \n         */\n        this.foreach = function (fn) {\n            if (typeof(fn) != 'function') {\n                throw new Error(msg.getMsgText(\"jsdoMSG003\", \"foreach()\"));\n            }\n            var numEmptyBlocks = 0;\n            if (this._needCompaction)\n                this._compact();\n\n            var data = this._getRelatedData();\n\n            this._inforeach = true;\n            for (var i = 0; i < data.length; i++) {\n                var block = data[i];\n                if (!block) {\n                    numEmptyBlocks++;\n                    continue;\n                }\n\n                this._setRecord(new progress.data.JSRecord(this, data[i]));\n                var result = fn(this.record);\n                if ((typeof(result) != 'undefined') && !result)\n                    break;\n            }\n\n            this._inforeach = false;\n\n            if ((numEmptyBlocks * 100 / this._data.length) >= PROGRESS_JSDO_PCT_MAX_EMPTY_BLOCKS)\n                this._needCompaction = true;\n        };\n\n        this._equalRecord = function (rec1, rec2, keyFields) {\n            var field;\n            var match = true;\n            for (var i = 0; i < keyFields.length; i++) {\n                var fieldName = keyFields[i];\n                var value1 = rec1[fieldName];\n                var value2 = rec2[fieldName];\n\n                if (!jsdo[tableName].caseSensitive) {\n                    field = jsdo[tableName]._fields[fieldName.toLowerCase()];\n                    if (field && field.type == \"string\") {\n                        if (value1 !== undefined && value1 !== null)\n                            value1 = value1.toUpperCase();\n                        if (value2 !== undefined && value2 !== null)\n                            value2 = value2.toUpperCase();\n                    }\n                }\n\n                match = (value1 == value2);\n                if (!match) return false;\n            }\n            return true;\n        };\n\n        // Private method to merge changes using merge modes: APPEND, EMPTY, MERGE and REPLACE\n        this._getKey = function (record, keyFields) {\n            var keyObject = {};\n            for (var i = 0; i < keyFields.length; i++) {\n                var fieldName = keyFields[i];\n                var value = record[fieldName];\n\n                if (!jsdo[tableName].caseSensitive) {\n                    field = jsdo[tableName]._fields[fieldName.toLowerCase()];\n                    if (field && field.type == \"string\") {\n                        if (value !== undefined && value !== null)\n                            value = value.toUpperCase();\n                    }\n                }\n                keyObject[fieldName] = value;\n            }\n            return JSON.stringify(keyObject);\n        };\n\n        this._getCompareFn = function (sortObject) {\n            if (typeof sortObject == 'function') {\n                return function (rec1, rec2) {\n                    if (rec1 === null) return 1;\n                    if (rec2 === null) return -1;\n\n                    var jsrec1 = new progress.data.JSRecord(this, rec1);\n                    var jsrec2 = new progress.data.JSRecord(this, rec2);\n                    return sortObject(jsrec1, jsrec2);\n                };\n            }\n            else return function (rec1, rec2) {\n                var tableRef = sortObject.tableRef;\n                var sortFields = sortObject.sortFields;\n                if (!(sortFields instanceof Array)) return 0;\n                var sortAscending = sortObject.sortAscending;\n\n                if (rec1 === null) return 1;\n                if (rec2 === null) return -1;\n\n                var field;\n                for (var i = 0; i < sortFields.length; i++) {\n                    var fieldName = sortFields[i];\n                    var value1 = rec1[fieldName];\n                    var value2 = rec2[fieldName];\n\n                    if (!tableRef.caseSensitive) {\n                        field = tableRef._fields[fieldName.toLowerCase()];\n                        if (field && field.type == \"string\") {\n                            if (value1 !== undefined && value1 !== null)\n                                value1 = value1.toUpperCase();\n                            if (value2 !== undefined && value2 !== null)\n                                value2 = value2.toUpperCase();\n                        }\n                    }\n                    if (value1 > value2 || (value1 === undefined || value1 === null))\n                        return sortAscending[i] ? 1 : -1;\n                    else if (value1 < value2 || (value2 === undefined && value2 === null))\n                        return sortAscending[i] ? -1 : 1;\n                }\n                return 0;\n            };\n        };\n\n        this._sortObject = {};\n        this._sortObject.tableRef = this;\n        this._sortObject.sortFields = undefined;\n        this._sortObject.sortAscending = undefined;\n        this._compareFields = this._getCompareFn(this._sortObject);\n\n        // _sortRecords - Tells the table reference whether to sort on add, assign and addRecords\t\t\n        this._sortRecords = true;\n        // Tells the table reference whether an autoSort is required on an add or assign\n        this._needsAutoSorting = false;\n        this._sortFn = undefined;\n        if ((typeof Object.defineProperty) == 'function') {\n            this._autoSort = true;\n            Object.defineProperty(\n                this,\n                \"autoSort\",\n                {\n                    get: function () {\n                        return this._autoSort;\n                    },\n                    set: function (value) {\n                        if (value) {\n                            this._autoSort = true;\n                            if (this._sortFn || this._sortObject.sortFields) {\n                                this._sort();\n                                this._createIndex();\n                            }\n                        }\n                        else\n                            this._autoSort = false;\n                    },\n                    enumerable: true,\n                    writeable: true\n                });\n            this._caseSensitive = false;\n            Object.defineProperty(\n                this,\n                \"caseSensitive\",\n                {\n                    get: function () {\n                        return this._caseSensitive;\n                    },\n                    set: function (value) {\n                        if (value) {\n                            this._caseSensitive = true;\n                        }\n                        else\n                            this._caseSensitive = false;\n                        if (this.autoSort &&\n                            (this._sortObject.sortFields && !this._sortFn)) {\n                            this._sort();\n                            this._createIndex();\n                        }\n                    },\n                    enumerable: true,\n                    writeable: true\n                });\n        }\n        else {\n            this.autoSort = true;\n            this.caseSensitive = false; // caseSensitive is false by default\t\t\n        }\n\n        this._processSortFields = function (sortFields) {\n            var sortObject = {};\n            if (sortFields instanceof Array) {\n                sortObject.sortFields = sortFields;\n                sortObject.sortAscending = [];\n                sortObject.fields = {};\n                for (var i = 0; i < sortObject.sortFields.length; i++) {\n                    var idx;\n                    var fieldName;\n                    var field;\n\n                    if (typeof (sortObject.sortFields[i]) != 'string') {\n                        throw new Error(msg.getMsgText(\"jsdoMSG030\", \"sort field name\", \"string element\"));\n                    }\n                    if ((idx = sortObject.sortFields[i].indexOf(':')) != -1) {\n                        fieldName = sortObject.sortFields[i].substring(0, idx);\n                        var sortOrder = sortObject.sortFields[i].substring(idx + 1);\n                        switch (sortOrder.toUpperCase()) {\n                            case 'ASCENDING':\n                            case 'ASC':\n                                sortObject.sortAscending[i] = true;\n                                break;\n                            case 'DESCENDING':\n                            case 'DESC':\n                                sortObject.sortAscending[i] = false;\n                                break;\n                            default:\n                                throw new Error(msg.getMsgText(\"jsdoMSG030\", \n                                    \"sort order '\" + sortObject.sortFields[i].substring(idx + 1) + \"'\", \n                                    \"ASCENDING or DESCENDING\"));\n                        }\n                    }\n                    else {\n                        fieldName = sortObject.sortFields[i];\n                        sortObject.sortAscending[i] = true;\n                    }\n                    if (fieldName != \"_id\" && this._fields) {\n                        field = this._fields[fieldName.toLowerCase()];\n                        if (field) {\n                            if (field.type == \"array\")\n                                throw new Error(msg.getMsgText(\"jsdoMSG030\", \"data type found in sort\", \n                                    \"scalar field\"));\n                            fieldName = field.name;\n                        }\n                        else\n                            throw new Error(msg.getMsgText(\"jsdoMSG031\", fieldName));\n                    }\n                    sortObject.sortFields[i] = fieldName;\n                    sortObject.fields[fieldName] = fieldName;\n                }\n            }\n            else {\n                sortObject.sortFields = undefined;\n                sortObject.sortAscending = undefined;\n                sortObject.fields = undefined;\n            }\n            return sortObject;\n        };\n\n        this.setSortFields = function (sortFields) {\n            if (sortFields === undefined || sortFields === null) {\n                this._sortObject.sortFields = undefined;\n                this._sortObject.sortAscending = undefined;\n            }\n            else if (sortFields instanceof Array) {\n                var sortObject = this._processSortFields(sortFields);\n                this._sortObject.sortFields = sortObject.sortFields;\n                this._sortObject.sortAscending = sortObject.sortAscending;\n                this._sortObject.fields = sortObject.fields;\n\n                if (this.autoSort) {\n                    this._sort();\n                    this._createIndex();\n                }\n            }\n            else\n                throw new Error(msg.getMsgText(\"jsdoMSG024\", \"JSDO\", \"setSortFields()\"));\n        };\n\n        this.setSortFn = function (fn) {\n            // Check that fn parameter is a function\n            // Valid values are a function, undefined, or null\n            // Documentation mentions null as a way to clear the sort function\n            if (fn && typeof (fn) != 'function') {\n                throw new Error(msg.getMsgText(\"jsdoMSG030\", \"parameter in setSortFn()\", \n                    \"function parameter\"));\n            }\n            this._sortFn = fn ? this._getCompareFn(fn) : undefined;\n            if (this.autoSort) {\n                this._sort();\n                this._createIndex();\n            }\n        };\n\n        this.sort = function (arg1) {\n            if (arg1 === undefined || arg1 === null) {\n                throw new Error(msg.getMsgText(\"jsdoMSG025\", \"JSDO\", \"sort()\"));\n            }\n            if (arguments.length !== 1 ||\n                (!(arg1 instanceof Array) && typeof(arg1) != 'function')) {\n                throw new Error(msg.getMsgText(\"jsdoMSG024\", \"JSDO\", \"sort()\"));\n            }\n            \n            if (arg1 instanceof Array) {\n                var sortObject = this._processSortFields(arg1);\n                if (sortObject.sortFields && sortObject.sortFields.length > 0)\n                    this._sort(sortObject);\n            }\n            else {\n                this._sort(arg1);\n            }\n            this._createIndex();\n        };\n\n        this._sort = function (arg1) {\n            if (arguments.length === 0 &&\n                (!this.autoSort || (this._sortFn === undefined && this._sortObject.sortFields === undefined)))\n                return;\n\n            if (arguments.length === 0) {\n                if (this._sortFn) {\n                    // Sort using function\n                    this._data.sort(this._sortFn);\n                }\n                else {\n                    // Sort using sort fields\n                    this._data.sort(this._compareFields);\n                }\n                this._needsAutoSorting = false;\n            }\n            else {\n                if (typeof(arg1) == 'function') {\n                    // Sort using function\n                    this._data.sort(this._getCompareFn(arg1));\n                }\n                else {\n                    // Sort using sort fields\n                    arg1.tableRef = this;\n                    this._data.sort(this._getCompareFn(arg1));\n                }\n                if (this.autoSort)\n                    this._needsAutoSorting = true;\n            }\n        };\n\n        /*\n         * Reads a JSON object into the JSDO memory for the specified table reference.\n         */\n        this.addRecords = function (jsonObject, addMode, keyFields, trackChanges, isInvoke) {\n            this._jsdo._addRecords(this._name, jsonObject, addMode, keyFields, trackChanges, isInvoke);\n        };\n\n        /*\n         * Accepts changes for the specified table reference. \n         */\n        this.acceptChanges = function () {\n            var tableRef = this;\n\n            // First, let's remove any \"prods:\" properties from created and updated records.\n            // Don't have to worry about deleted records, since they're going away.\n            for (var id in tableRef._beforeImage) {\n                //  Create\n                if (tableRef._beforeImage[id] === null) {\n                    var jsrecord = tableRef._findById(id, false);\n                    if (jsrecord !== null) {\n                        tableRef._jsdo._deleteProdsProperties(jsrecord.data, true);\n                    }\n\n                }\n                // Update\n                else if (this._changed[id] !== undefined) {\n                    var jsrecord = this._findById(id, false);\n                    if (jsrecord !== null) {\n                        tableRef._jsdo._deleteProdsProperties(jsrecord.data, true);\n                    }\n                }\n            }\n\n            tableRef._processed = {};\n            tableRef._added = [];\n            tableRef._changed = {};\n            tableRef._deleted = [];\n            tableRef._beforeImage = {};\n        };\n\n        /*\n         * Rejects changes for the specified table reference.\n         */\n        this.rejectChanges = function () {\n            // Reject changes\n            for (var id in this._beforeImage) {\n                if (this._beforeImage[id] === null) {\n                    // Undo create\n                    this._jsdo._undoCreate(this, id);\n                }\n                else if (this._changed[id] !== undefined) {\n                    // Undo update\n                    this._jsdo._undoUpdate(this, id, true);\n                }\n                else {\n                    // Undo delete\n                    this._jsdo._undoDelete(this, id, true);\n                }\n            }\n\n            var tableRef = this;\n            tableRef._processed = {};\n            tableRef._added = [];\n            tableRef._changed = {};\n            tableRef._deleted = [];\n        };\n\n        this.hasChanges = function () {\n            return (Object.keys(this._beforeImage).length !== 0);\n        };\n\n        this.getChanges = function () {\n            var result = [];\n            for (var id in this._beforeImage) {\n                var item = {rowState: \"\", record: null};\n                // Create\n                if (this._beforeImage[id] === null) {\n                    item.rowState = PROGRESS_JSDO_ROW_STATE_STRING[progress.data.JSDO._OP_CREATE];\n                    item.record = this._findById(id, false);\n                }\n                // Update\n                else if (this._changed[id] !== undefined) {\n                    item.rowState = PROGRESS_JSDO_ROW_STATE_STRING[progress.data.JSDO._OP_UPDATE];\n                    item.record = this._findById(id, false);\n                }\n                // Delete\n                else {\n                    item.rowState = PROGRESS_JSDO_ROW_STATE_STRING[progress.data.JSDO._OP_DELETE];\n                    item.record = new progress.data.JSRecord(this, this._beforeImage[id]);\n                }\n                result.push(item);\n            }\n            return result;\n        };\n\n        /*\n         * Private method to apply changes for the specified table reference.\n         * If _errorString has been set for a row, row change is rejected. \n         * If it has not been set, acceptRowChanges() is called.\n         */\n        this._applyChanges = function () {\n            for (var id in this._beforeImage) {\n                //  Create\n                if (this._beforeImage[id] === null) {\n                    var jsrecord = this._findById(id, false);\n                    if (jsrecord !== null) {\n                        if (jsrecord.data._errorString !== undefined) {\n                            this._jsdo._undoCreate(this, id);\n                        }\n                        else {\n                            jsrecord.acceptRowChanges();\n                        }\n                    }\n                    else {\n                        // Record not present in JSDO memory\n                        // Delete after Create\n                        var found = false;\n                        for (var i = 0; i < this._deleted.length; i++) {\n                            found = (this._deleted[i].data._id == id);\n                            if (found) break;\n                        }\n                        if (!found) {\n                            throw new Error(msg.getMsgText(\"jsdoMSG000\", \n                                \"Created record appears to be deleted without a delete operation.\"));\n                        }\n                    }\n                }\n                // Update\n                else if (this._changed[id] !== undefined) {\n                    var jsrecord = this._findById(id, false);\n                    if (jsrecord !== null) {\n                        // Record found in JSDO memory\n                        if (jsrecord.data._errorString !== undefined) {\n                            this._jsdo._undoUpdate(this, id);\n                        }\n                        else {\n                            jsrecord.acceptRowChanges();\n                        }\n                    }\n                    else {\n                        // Record not present in JSDO memory\n                        // Delete after Update\n                        if (this._beforeImage[id]._errorString !== undefined) {\n                            this._jsdo._undoDelete(this, id);\n                        }\n                        else {\n                            var found = false;\n                            for (var i = 0; i < this._deleted.length; i++) {\n                                found = (this._deleted[i].data._id == id);\n                                if (found) break;\n                            }\n                            if (!found) {\n                                throw new Error(msg.getMsgText(\"jsdoMSG000\", \n                                    \"Updated record appears to be deleted without a delete operation.\"));\n                            }\n                        }\n                    }\n                }\n                // Delete\n                else {\n                    if (this._beforeImage[id]._errorString !== undefined) {\n                        this._jsdo._undoDelete(this, id);\n                    }\n                }\n            }\n\n            var tableRef = this;\n            tableRef._processed = {};\n            tableRef._added = [];\n            tableRef._changed = {};\n            tableRef._deleted = [];\n            tableRef._beforeImage = {};\n        };\n\n\n        /*\n         * Accepts row changes for the working record at the table reference level.\n         */\n        this.acceptRowChanges = function () {\n            if (this.record)\n                return this.record.acceptRowChanges();\n            throw new Error(msg.getMsgText(\"jsdoMSG002\", this._name));\n        };\n\n        /*\n         * Rejects row changes for the working record at the table reference level.\n         */\n        this.rejectRowChanges = function () {\n            if (this.record)\n                return this.record.rejectRowChanges();\n            throw new Error(msg.getMsgText(\"jsdoMSG002\", this._name));\n        };\n\n\n        /* This method returns true \n         * if this table has any child tables and at least one of those tables is nested.\n         * Else if returns false.\n         */\n        this._hasNestedChild = function () {\n            var hasNestedChild = false;\n            var childBufObj;\n\n            // If table has children, see if any relationship is NESTED\t\n            if (this._children.length > 0) {\n                for (var i = 0; i < this._children.length; i++) {\n                    childBufObj = this._jsdo._buffers[this._children[i]];\n\n                    if (childBufObj._isNested) {\n                        hasNestedChild = true;\n                        break;\n                    }\n                }\n            }\n\n            return hasNestedChild;\n        };\n    };\n\n    /*\n     * Returns a JSRecord for the specified JSDO.\n     * @param jsdo the JSDO\n     * @param record the values of the record\n     */\n    progress.data.JSRecord = function JSRecord(tableRef, record) {\n        this._tableRef = tableRef;\n        this.data = record;\n\n        this.getId = function () {\n            return this.data._id ? this.data._id : null;\n        };\n\n        this.getErrorString = function () {\n            return this.data._errorString;\n        };\n\n        /*\n         * Saves a copy of the current record to the before image.\n         */\n        this._saveBeforeImageUpdate = function () {\n            // Save before image \n            if (this._tableRef._beforeImage[this.data._id] === undefined) {\n                // this.data._index = index;\n                var copy = {};\n                this._tableRef._jsdo._copyRecord(\n                    this._tableRef, this.data, copy);\n                this._tableRef._beforeImage[this.data._id] = copy;\n            }\n\n            if (this._tableRef._changed[this.data._id] === undefined) {\n                this._tableRef._changed[this.data._id] = this.data;\n            }\n            // End - Save before image\t\t\t\n        };\n\n        /*\n         * \n         */\n        this._sortRecord = function (fields) {\n            var index = this._tableRef._index[this.data._id].index;\n            var record = this._tableRef._data[index];\n\n            if (this._tableRef.autoSort \n                && this._tableRef._sortRecords \n                && (this._tableRef._sortFn !== undefined \n                    || this._tableRef._sortObject.sortFields !== undefined)) {\n\n                if (this._tableRef._sortObject.fields) {\n                    if (typeof fields == 'string') {\n                        if (this._tableRef._sortObject.fields[fields] === undefined)\n                            return; // Only sort records if the the specified field is in the sort fields\n                    }\n                    else if (fields instanceof Array) {\n                        var found = false;\n                        for (var i = 0; i < fields.length; i++) {\n                            if (this._tableRef._sortObject.fields[fields[i]] !== undefined) {\n                                found = true;\n                                break;\n                            }\n                        }\n                        if (!found)\n                            return; // Only sort records if the the specified fields are in the sort fields\n                    }\n                }\n\n                if (this._tableRef._needsAutoSorting) {\n                    this._tableRef._sort();\n                    this._tableRef._createIndex();\n                }\n                else {\n                    // Find position of new record in _data and use splice\n                    for (var i = 0; i < this._tableRef._data.length; i++) {\n                        if (this._tableRef._data[i] === null) continue; // Skip null elements\n                        if (i == index) continue; // Skip changed record\n                        var ret = this._tableRef._sortFn ?\n                            this._tableRef._sortFn(record, this._tableRef._data[i]) :\n                            this._tableRef._compareFields(record, this._tableRef._data[i]);\n                        if (ret == -1) break;\n                    }\n\n                    if (i > index) {\n                        i--;\n                    }\n                    if (i != index) {\n                        this._tableRef._data.splice(index, 1);\n                        this._tableRef._data.splice(i, 0, record);\n                        this._tableRef._createIndex();\n                    }\n                }\n            }\n        };\n\n        /*\n         * Assigns the specified values.\n         * @param record parameter with the record values\n         */\n        this.assign = function (record) {\n            if (record === undefined)\n                throw new Error(msg.getMsgText(\"jsdoMSG024\", \"JSDO\", \"assign() or update()\"));\n\n            this._saveBeforeImageUpdate();\n\n            var fieldName,\n                i,\n                j,\n                value,\n                schema = this._tableRef.getSchema(),\n                prefixElement,\n                name;\n            \n            if (record) {\n                for (i = 0; i < schema.length; i += 1) {\n                    fieldName = schema[i].name;\n                    value = record[fieldName];\n                    if (typeof value != \"undefined\") {\n                        if (typeof value == 'string' && schema[i].type != 'string') {\n                            value = this._tableRef._jsdo._convertType(value,\n                                schema[i].type,\n                                schema[i].items ? schema[i].items.type : null);\n                        }\n                        this.data[fieldName] = value;\n                    }\n                    if (schema[i].type === \"array\") {\n                        // Assign values from individual fields from flattened arrays                      \n                        prefixElement = this._tableRef._jsdo._getArrayField(fieldName);\n                        if (!this.data[fieldName]) {\n                            this.data[fieldName] = [];\n                        }\n                        for (j = 0; j < schema[i].maxItems; j += 1) {\n                            name = prefixElement.name + (j+1);\n                            value = record[name];\n                            if (typeof value != \"undefined\") {\n                                // Skip element if a field with the same name exists\n                                if (!this._tableRef._fields[name.toLowerCase()]) {                                \n                                    if (typeof value == 'string' && schema[i].items.type != 'string') {\n                                        value = this._tableRef._jsdo._convertType(value,\n                                                                                  schema[i].items.type,\n                                                                                  null);\n                                    }                                \n                                    this.data[fieldName][j] = value;\n                                }\n                            }\n                        }\n                    }                    \n                }\n\n                this._sortRecord();\n            }\n            return true;\n        };\n\n        // Alias for assign() method\n        this.update = this.assign;\n\n        /*\n         * Removes the JSRecord.\n         */\n        this.remove = function () {\n            return this._remove(true);\n        };\n\n        this._remove = function (bTrackChanges) {\n            if (typeof(bTrackChanges) == 'undefined') {\n                bTrackChanges = true;\n            }\n\n            var index = this._tableRef._index[this.data._id].index;\n            var jsrecord = this._tableRef._findById(this.data._id, false);\n\n            if (bTrackChanges) {\n                // Save before image\n                var record = this._tableRef._beforeImage[this.data._id];\n                if (record === undefined) {\n                    // Record does not exist in the before image\n                    this.data._index = index;\n                    this._tableRef._beforeImage[this.data._id] = this.data;\n                }\n                else {\n                    // Record exists in the before image\n                    if (record) {\n                        // Record is not null - a null entry in the before image indicates \n                        // corresponds to an add\n                        // Save the index of the record\n                        // so that an undo would restore the record in the same position in _data\n                        record._index = index;\n                    }\n                }\n                // End - Save before image\n                this._tableRef._deleted.push(jsrecord);\n            }\n\n            // Set entry to null instead of removing entry - index requires positions to be persistent\n            this._tableRef._data[index] = null;\n            this._tableRef._hasEmptyBlocks = true;\n            delete this._tableRef._index[this.data._id];\n\n            // Set record property\n            this._tableRef._setRecord(null);\n\n            return true;\n        };\n\n        /*\n         * Accepts row changes for the specified record.\n         */\n        this.acceptRowChanges = function () {\n            var id = this.data._id;\n            if (this._tableRef._beforeImage[id] !== undefined) {\n                if (this._tableRef._beforeImage[id] === null) {\n                    // Accept create\t\t\t\t\n                    // Remove element from _added\n                    for (var i = 0; i < this._tableRef._added.length; i++) {\n                        if (this._tableRef._added[i] == id) {\n                            this._tableRef._added.splice(i, 1);\n                            break;\n                        }\n                    }\n                    this._tableRef._jsdo._deleteProdsProperties(this.data, true);\n                }\n                else if (this._tableRef._changed[id] !== undefined) {\n                    // Accept update\n                    delete this._tableRef._changed[id];\n                    this._tableRef._jsdo._deleteProdsProperties(this.data, true);\n                }\n                else {\n                    // Accept delete\n                    // Remove element from _deleted\n                    for (var i = 0; i < this._tableRef._deleted.length; i++) {\n                        if (this._tableRef._deleted[i].data._id == id) {\n                            this._tableRef._deleted.splice(i, 1);\n                            break;\n                        }\n                    }\n                }\n                delete tableRef._beforeImage[id];\n            }\n        };\n\n        /*\n         * Rejects row changes for the specified record.\n         */\n        this.rejectRowChanges = function () {\n            var id = this.data._id;\n            if (this._tableRef._beforeImage[id] !== undefined) {\n                if (this._tableRef._beforeImage[id] === null) {\n                    // Undo create\t\t\t\t\n                    this._tableRef._jsdo._undoCreate(this._tableRef, id);\n                    // Remove element from _added\n                    for (var i = 0; i < this._tableRef._added.length; i++) {\n                        if (this._tableRef._added[i] == id) {\n                            this._tableRef._added.splice(i, 1);\n                            break;\n                        }\n                    }\n                }\n                else if (this._tableRef._changed[id] !== undefined) {\n                    // Undo update\n                    this._tableRef._jsdo._undoUpdate(this._tableRef, id, true);\n                    delete this._tableRef._changed[id];\n                }\n                else {\n                    // Undo delete\n                    this._tableRef._jsdo._undoDelete(this._tableRef, id, true);\n                    // Remove element from _deleted\n                    for (var i = 0; i < this._tableRef._deleted.length; i++) {\n                        if (this._tableRef._deleted[i].data._id == id) {\n                            this._tableRef._deleted.splice(i, 1);\n                            break;\n                        }\n                    }\n                }\n                delete tableRef._beforeImage[id];\n            }\n        };\n\n    };\n\n    /*\n     * Returns a JSDO for the specified resource.\n     * @param resNameOrParmObj: the resource name or an object that contains the initial values for the JSDO\n     *                     (if this is an object, it should include the name property with the resource name\n     * @param serviceName : name of service (ignored if 1st param is an object containing the initial values)\n     */\n    progress.data.JSDO = function JSDO(resNameOrParmObj, serviceName) {\n        var _super = {};\n        \n        if (typeof progress.data.Session == 'undefined') {\n            throw new Error('ERROR: You must include progress.session.js');\n        }\n        \n        _super.subscribe = this.subscribe;\n        \n        // Override for Observable.subscribe\n        this.subscribe = function(evt) {\n            var args = Array.prototype.slice.call(arguments);\n            if (typeof evt === \"string\") {\n                // Aliases for events\n                switch(evt.toLowerCase()) {\n                case \"beforeread\":\n                    args[0] = \"beforefill\";\n                    break;\n                case \"afterread\":\n                    args[0] = \"afterfill\";                \n                    break;\n                }\n            }\n            _super.subscribe.apply(this, args);\n        };\n        \n        this._defineProperty = function (tableName, fieldName) {\n            Object.defineProperty(\n                this._buffers[tableName],\n                fieldName,\n                {\n                    get: function fnGet() {\n                        var name,\n                            index,\n                            element,\n                            fieldInfo;\n                        if (this.record) {\n                            index = fieldName.indexOf(progress.data.JSDO.ARRAY_INDEX_SEPARATOR);\n                            if (index > 0 && !this._fields[fieldName.toLowerCase()]) {\n                                // Skip element if a field with the same name exists                                \n                                // Check if field is a flattened array field by quickly checking for the separator\n                                // Extract name and index element\n                                name = fieldName.substring(0, index);\n                                element = fieldName.substring(index + progress.data.JSDO.ARRAY_INDEX_SEPARATOR.length);\n                                fieldInfo = this._fields[name.toLowerCase()];\n                                if (!isNaN(element) && fieldInfo && (fieldInfo.type === \"array\")) {\n                                    return this.record.data[name][element - 1];\n                                }\n                            }\n                            return this.record.data[fieldName];                            \n                        }\n                        else\n                            return null;\n                    },\n                    set: function (value) {\n                        var name = fieldName,\n                            index,\n                            element,\n                            fieldInfo;\n                        if (this.record) {\n                            this.record._saveBeforeImageUpdate();\n\n                            try {\n                                index = fieldName.indexOf(progress.data.JSDO.ARRAY_INDEX_SEPARATOR);\n                                if (index > 0 && !this._fields[fieldName.toLowerCase()]) {\n                                    // Skip element if a field with the same name exists                                    \n                                    name = fieldName.substring(0, index);\n                                    element = fieldName.substring(index + progress.data.JSDO.ARRAY_INDEX_SEPARATOR.length);\n                                    fieldInfo = this._fields[name.toLowerCase()];\n                                    if (!isNaN(element) && fieldInfo && (fieldInfo.type === \"array\")) {\n                                        this.record.data[name][element - 1] = value;\n                                        return;\n                                    }\n                                }                            \n                                this.record.data[fieldName] = value;\n                            }\n                            finally {\n                                this.record._sortRecord(name);\n                            }\n                        }\n                    },\n                    enumerable: true,\n                    writeable: true\n                });\n        };\n\n        // Initial values\n        this._buffers = {};         // Object of table references\n        this._numBuffers = 0;\n        this._defaultTableRef = null;\n\n        this._async = true;\n        this._dataProperty = null;\n        this._dataSetName = null;\n        this.operations = [];\n        this.useRelationships = true;\n\n        this._session = null;\n        this._needCompaction = false;\n\n        this._hasCUDOperations = false;\n        this._hasSubmitOperation = false;\n        this._useSubmit = false; // For saving saveChanges(useSubmit) param\n\n        this.autoApplyChanges = true; // default should be true to support 11.2 behavior\n        this._lastErrors = [];\n        this._localStorage = null;\n        this._convertForServer;\n        var autoFill = false;\n\n        // Initialize JSDO using init values\n        if (!arguments[0]) {\n            throw new Error(\"JSDO: Parameters are required in constructor.\");\n        }\n\n        if (typeof(arguments[0]) == \"string\") {\n            this.name = arguments[0];\n//\t\tif ( arguments[1] && (typeof(arguments[1]) ==  \"string\") )\n//\t\t\tlocalServiceName = serviceName;\n        }\n        else if (typeof(arguments[0]) == \"object\") {\n            var args = arguments[0];\n            for (var v in args) {\n                switch (v) {\n                    case 'autoFill':\n                        autoFill = args[v];\n                        break;\n                    case 'events':\n                        this._events = {};\n                        for (var eventName in args[v]) {\n                            this._events[eventName.toLowerCase()] = args[v][eventName];\n                        }\n                        break;\n                    case 'dataProperty':\n                        this._dataProperty = args[v];\n                        break;\n                    default:\n                        this[v] = args[v];\n                }\n            }\n        }\n        /* error out if caller didn't pass the resource name */\n        if ((!this.name) /*|| !(this._session)*/) {\n            // make this error message more specific?\n            throw new Error(\"JSDO: JSDO constructor is missing the value for 'name'\");\n        }\n\n        /* perform some basic validation on the event object for the proper structure if provided */\n        if (this._events) {\n            if ((typeof this._events) !== 'object') {\n                throw new Error(\"JSDO: JSDO constructor event object is not defined as an object\");\n            }\n\n            /* make sure all the event handlers are sane */\n            for (var prop in this._events) {\n                var evt = this._events[prop];\n                if (!(evt instanceof Array)) {\n                    throw new Error('JSDO: JSDO constructor event object for ' + prop + ' must be an array');\n                }\n                evt.forEach(function (el) {\n                    if ((typeof el) !== 'object') {\n                        throw new Error(\"JSDO: JSDO constuctor event object for \" + \n                            prop + \" is not defined as an object\");\n                    }\n                    /* listener must have at least fn property defined as a function */\n                    if ((typeof el.fn) !== 'function') {\n                        throw new Error(\"JSDO: JSDO event listener for \" + prop + \" is not a function.\");\n                    }\n                    /* scope is optional, but must be an object if provided */\n                    if (el.scope && (typeof el.scope) !== 'object') {\n                        throw new Error(\"JSDO: JSDO event listener scope for \" + prop + \" is not an object.\");\n                    }\n                });\n            }\n        }\n\n        if (this.name) {\n            // Read resource definition from the Catalog - save reference to JSDO\n            // Enhance this to deal with multiple services loaded and the same resource\n            // name is used by more than one service (use the local serviceName var)\n            this._resource = progress.data.ServicesManager.getResource(this.name);\n            if (this._resource) {\n                if (!this.url)\n                    this.url = this._resource.url;\n                if (!this._dataSetName && this._resource._dataSetName) {\n                    // Catalog defines a DataSet\n                    this._dataSetName = this._resource._dataSetName;\n\n                    // Define TableRef property in the JSDO\n                    if (this._resource.dataProperty) {\n                        var buffer = this[this._resource.dataProperty] \n                            = new progress.data.JSTableRef(this, this._resource.dataProperty);\n                        this._buffers[this._resource.dataProperty] = buffer;\n                    }\n                    else {\n                        for (var tableName in this._resource.fields) {\n                            var buffer = this[tableName] \n                                = new progress.data.JSTableRef(this, tableName);\n                            this._buffers[tableName] = buffer;\n                        }\n                    }\n                }\n                if (!this._dataProperty && this._resource.dataProperty)\n                    this._dataProperty = this._resource.dataProperty;\n\n                if (!this._dataSetName) {\n                    var tableName = this._dataProperty ? this._dataProperty : \"\";\n                    this._buffers[tableName] = new progress.data.JSTableRef(this, tableName);\n                    if (tableName)\n                        this[tableName] = this._buffers[tableName];\n                }\n\n                // Add functions for operations to JSDO object\n                for (var fnName in this._resource.fn) {\n                    this[fnName] = this._resource.fn[fnName][\"function\"];\n                }\n                // Check if CUD operations have been defined\n                this._hasCUDOperations =\n                    this._resource.generic[\"create\"] !== undefined\n                    || this._resource.generic[\"update\"] !== undefined\n                    || this._resource.generic[\"delete\"] !== undefined;\n                this._hasSubmitOperation = this._resource.generic[\"submit\"] !== undefined;\n\n                /* get a session object, using name of the service to look it up in the list of\n                 * sessions maintained by the ServicesManager\n                 */\n                if (!this._session) {\n                    var myservice = progress.data.ServicesManager.getService(this._resource.service.name);\n                    this._session = myservice._session;\n                    this._session._pushJSDOs(this);\n                }\n            }\n            else {\n                throw new Error(msg.getMsgText(\"jsdoMSG004\", this.name));\n            }\n        }\n        else {\n            this._buffers[\"\"] = new progress.data.JSTableRef(this, \"\");\n        }\n\n        if (!this._session) {\n            throw new Error(\"JSDO: Unable to get user session for resource '\" + this.name + \"'\");\n        }\n\n        // Calculate _numBuffers and _defaultTableRef\n        for (var buf in this._buffers) {\n            this._buffers[buf]._parent = null;\n            this._buffers[buf]._children = [];\n            // The _relationship object is only specified for the child buffer.\n            // Currently it is limited to only a single relationship. ie. It does not support the\n            // where the child buffer is involved in more than one data-relation\n            this._buffers[buf]._relationship = null;\n            this._buffers[buf]._isNested = false;\n            if (!this._defaultTableRef)\n                this._defaultTableRef = this._buffers[buf];\n            this._numBuffers++;\n        }\n        if (this._numBuffers != 1)\n            this._defaultTableRef = null;\n        else {\n            // record is used to represent the current record for a table reference\n            // data corresponds to the values (JSON object) of the data\n            this.record = null;\n        }\n\n        // Define caseSensitive property at the JSDO level\n        if ((typeof Object.defineProperty) == 'function') {\n            this._caseSensitive = false;\t// caseSensitive is false by default\n            Object.defineProperty(\n                this,\n                \"caseSensitive\",\n                {\n                    get: function () {\n                        return this._caseSensitive;\n                    },\n                    set: function (value) {\n                        this._caseSensitive = value ? true : false;\n\n                        for (var buf in this._buffers) {\n                            this._buffers[buf].caseSensitive = this._caseSensitive;\n                        }\n                    },\n                    enumerable: true,\n                    writeable: true\n                });\n            this._autoSort = true;\t// autoSort is true by default\n            Object.defineProperty(\n                this,\n                \"autoSort\",\n                {\n                    get: function () {\n                        return this._autoSort;\n                    },\n                    set: function (value) {\n                        this._autoSort = value ? true : false;\n\n                        for (var buf in this._buffers) {\n                            this._buffers[buf].autoSort = this._autoSort;\n                        }\n                    },\n                    enumerable: true,\n                    writeable: true\n                });\n        }\n        \n        // Define _properties property at the JSDO level\n        this._properties = {};\n        if ((typeof Object.defineProperty) == 'function') {\n            Object.defineProperty( this, \n                                   \"this._properties\",\n                                   {  \n                                       get: function () {\n                                            return this._properties;\n                                       },\n                                       enumerable: false\n                                   }\n                                 );\n            \n        }\n\n\n        // Set schema for TableRef\n        if (this._resource && this._resource.fields) {\n            for (var buf in this._buffers) {\n                this._buffers[buf]._schema = this._resource.fields[buf];\n                this._buffers[buf]._primaryKeys = this._resource.primaryKeys[buf];\n\n                // Create _fields object used to validate fields as case-insensitive.\n                this._buffers[buf]._fields = {};\n                var fields = this._buffers[buf]._schema;\n                for (var i = 0; i < fields.length; i++) {\n                    this._buffers[buf]._fields[fields[i].name.toLowerCase()] = fields[i]; \n                    if (typeof(fields[i].origName) !== \"undefined\") {\n                        if ((typeof(fields[i].origName) !== \"string\")\n                            || (fields[i].origName.trim() === \"\")) {\n                            throw new Error(msg.getMsgText(\"jsdoMSG504\", \n                                \"JSDO\", \"Field '\" + fields[i].name + \"' in resource '\" + this._resource.name + \"'\", \"origName\"));\n                        }\n                    }\n                }\n                \n                if (this._buffers[buf]._schema && (typeof Object.defineProperty) == 'function') {\n                    // Add fields as properties of the TableRef object\n                    for (var i = 0; i < this._buffers[buf]._schema.length; i++) {\n                        var fieldName = this._buffers[buf]._schema[i].name,\n                            fieldInfo = this._buffers[buf]._schema[i];                        \n                        if (typeof(this._buffers[buf][fieldName]) == 'undefined') {\n                            this._defineProperty(buf, fieldName);\n                        }\n\t\t\t\t\t\tif (fieldInfo.type === \"array\") {\n\t\t\t\t\t\t\tfor (var j = 0; j < fieldInfo.maxItems; j += 1) {\n                                var name = fieldName + progress.data.JSDO.ARRAY_INDEX_SEPARATOR + (j + 1);\n                                // Skip element if a field with the same name exists                                \n                                // Only create property if the name is not being used\n                                if (!this._buffers[buf]._fields[name.toLowerCase()]) {\n                                    this._defineProperty(buf, name);\n                                }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}                        \n                    }\n                }\n            }\n            // Set schema for when dataProperty is used but not specified via the catalog\n            if (this._defaultTableRef\n                && !this._defaultTableRef._schema\n                && this._resource.fields[\"\"]) {\n                this._defaultTableRef._schema = this._resource.fields[\"\"];\n            }\n        }\n        else {\n            if (this._defaultTableRef)\n                this._defaultTableRef._schema = [];\n        }\n\n        // Set isNested property\n        if (this._numBuffers > 1) {\n            for (var buf in this._buffers) {\n                var fields = [];\n                var found = false;\n                for (var i = 0; i < this._buffers[buf]._schema.length; i++) {\n                    var field = this._buffers[buf]._schema[i];\n\n                    if (field.items\n                        && field.type == \"array\" && field.items.$ref) {\n                        if (this._buffers[field.name]) {\n                            found = true;\n                            this._buffers[field.name]._isNested = true;\n                        }\n                    }\n                    else\n                        fields.push(field);\n                }\n                // Replace list of fields - removing nested datasets from schema\n                if (found)\n                    this._buffers[buf]._schema = fields;\n            }\n        }\n\n        // Process relationships\n        if (this._resource && this._resource.relations) {\n            for (var i = 0; i < this._resource.relations.length; i++) {\n                var relationship = this._resource.relations[i];\n\n                if (relationship.childName && relationship.parentName) {\n                    // Set casing of fields in relationFields to be the same as in the schema\n                    if (relationship.relationFields instanceof Array) {\n                        for (var j = 0; j < relationship.relationFields.length; j++) {\n                            var fieldName;\n                            var field;\n                            if (this._buffers[relationship.parentName]._fields) {\n                                fieldName = relationship.relationFields[j].parentFieldName;\n                                field=this._buffers[relationship.parentName]._fields[fieldName.toLowerCase()];\n                                if (field) {\n                                    relationship.relationFields[j].parentFieldName = field.name;\n                                }\n                                else\n                                    throw new Error(msg.getMsgText(\"jsdoMSG010\", fieldName));\n                            }\n                            if (this._buffers[relationship.childName]._fields) {\n                                fieldName = relationship.relationFields[j].childFieldName;\n                                field=this._buffers[relationship.childName]._fields[fieldName.toLowerCase()];\n                                if (field) {\n                                    relationship.relationFields[j].childFieldName = field.name;\n                                }\n                                else\n                                    throw new Error(msg.getMsgText(\"jsdoMSG010\", fieldName));\n                            }\n                        }\n                    }\n                    this._buffers[relationship.childName]._parent = relationship.parentName;\n                    this._buffers[relationship.childName]._relationship = relationship.relationFields;\n                    this._buffers[relationship.parentName]._children.push(relationship.childName);\n                }\n            }\n        }      \n        \n        this._getDefaultValue = function (field) {\n            var defaultValue,\n                t, m, d,\n                isDate = false;\n\n            if ((field.type === \"string\")\n                && field.format\n                && (field.format.indexOf(\"date\") !== -1)\n                && (field[\"default\"])) {\n                isDate = true;\n            } else if ((field.type === \"array\")\n                       && field.ablType\n                       && (field.ablType.indexOf(\"DATE\") != -1)\n                       && (field[\"default\"])) {\n                isDate = true;\n            } else {\n                defaultValue = field[\"default\"];\n            }\n            \n            if (isDate) {\n                switch (field[\"default\"].toUpperCase()) {\n                    case \"NOW\":\n                        defaultValue = new Date().toISOString();\n                        break;\n                    case \"TODAY\":\n                        t = new Date();\n                        m = String((t.getMonth() + 1));\n                        if (m.length === 1) {\n                            m = '0' + m;\n                        }\n                        d = String((t.getDate()));\n                        if (d.length === 1) {\n                            d = '0' + d;\n                        }\n                        defaultValue = t.getFullYear() + '-' + m + '-' + d;\n                        break;\n                    default:\n                        defaultValue = field[\"default\"];\n                }\n            }\n            \n            return defaultValue;\n        };\n        \n        // Method to calculate the element information of an array given the name, index, and value\n        // Parameters:\n        // arrayFieldName The name o the field\n        // index Optional parameter - if index is null/undefined the name of the element is the prefix\n        // value Optional parameter\n        this._getArrayField = function (arrayFieldName, index, value) {\n            var element = {};\n            // ABL arrays are 1-based\n            element.name = arrayFieldName + progress.data.JSDO.ARRAY_INDEX_SEPARATOR + ((index >= 0) ? (index + 1) : \"\");\n            element.value = value ? value[index] : undefined;\n            return element;\n        };\n\n        this.isDataSet = function () {\n            return this._dataSetName ? true : false;\n        };\n\n        /* handler for invoke operation complete */\n        this._invokeComplete = function (jsdo, success, request) {\n            // only fire on async requests\n            if (request.async && request.fnName) {\n                jsdo.trigger('afterInvoke', request.fnName, jsdo, success, request);\n            }\n            \n            if (request.deferred) {\n                if (success) {\n                    request.deferred.resolve(jsdo, success, request);\n                }\n                else {\n                    request.deferred.reject(jsdo, success, request);\n                }\n            }            \n        };\n\n        /* handler for invoke operation success */\n        this._invokeSuccess = function (/* jsdo, success, request */) {\n            // do nothing\n        };\n\n        /* handler for invoke operation error */\n        this._invokeError = function (/* jsdo, success, request */) {\n            // do nothing\n        };\n\n        /*\n         * Performs an HTTP request using the specified parameters.  This is \n         * used to perform remote calls for the JSDO for operations defined.\n         * \n         */\n        this._httpRequest = function (xhr, method, url, reqBody, request) {\n\n            // if xhr wasn't passed we'll create our own since this is an invoke operation\n            // if xhr is passed, then it is probably a CRUD operation which is setup with XHR\n            // in call to session\n            if (!xhr) {\n                xhr = new XMLHttpRequest();\n\n                // only setup the callback handlers if we're responsible for creating the \n                // xhr call which happens on invoke operations...which is the normal case\n                // the CRUD operations setup their own callbacks and they have their own\n                // event handlers so we don't use them here.\n                xhr.onCompleteFn = this._invokeComplete;\n                xhr.onSuccessFn = this._invokeSuccess;\n                xhr.onErrorFn = this._invokeError;\n                xhr.onreadystatechange = this.onReadyStateChangeGeneric;\n\n                // for invokes we always fire the invoke when doing async\n                if (request.async && request.fnName) {\n                    this.trigger('beforeInvoke', request.fnName, this, request);\n                }\n\n                // For Invoke operations, wrap reqBody in a request object\n                // This is not required for CRUD operations since the whole\n                // reqBody is mapped to the parameter\n                if (reqBody) {\n                    if (this._resource && this._resource.service) {\n                        var useRequest = this._resource.service.useRequest;\n                        if (this._resource.service.settings \n                            && this._resource.service.settings.useRequest !== undefined) {\n                            useRequest = this._resource.service.settings.useRequest;\n                        }\n                        if (useRequest) {\n                            reqBody = {request: reqBody};\n                        }\n                    }\n                }\n            }\n\n            xhr.request = request;\n            xhr.jsdo = this;\n            request.jsdo = this;\n            request.xhr = xhr;\n\n            this._session._openRequest(xhr, method, url, request.async);\n\n            var input = null;\n            if (reqBody) {\n                xhr.setRequestHeader(\"Content-Type\", \"application/json; charset=utf-8\");\n                input = JSON.stringify(reqBody);\n            }\n\n            try {\n                xhr.send(input);\n            } catch (e) {\n                request.success = false;\n                request.exception = e;\n                // let Session check for online/offline\n                xhr.jsdo._session._checkServiceResponse(xhr, request.success, request);\n            }\n\n            return request;\n        };\n\n\n        // This method currently is just used by the JSDOReadService.\n        // It returns data in its non-nested (default) format\n        this._getDataObject = function () {\n            var dataObject = {};\n            if (this._dataSetName) {\n                dataObject[this._dataSetName] = {};\n\n                var oldUseRelationships = this.useRelationships;\n                // Turn off useRelationships so that getData() returns all the records\n                try {\n                    this.useRelationships = false;\n                    for (var buf in this._buffers) {\n                        dataObject[this._dataSetName][buf] = this._buffers[buf].getData();\n                    }\n                }\n                finally {\n                    // Restore useRelationships\n                    this.useRelationships = oldUseRelationships;\n                }\n            }\n            else {\n                if (this._dataProperty) {\n                    dataObject[this._dataProperty] = this.getData();\n                }\n                else\n                    return this.getData(); // Array\n            }\n            return dataObject;\n        };\n\n\n        // This method currently is just used by the JSDOReadService.\n        // Now that the JSDO Services support nested data, we want to return data nested for those \n        // relationships that are marked nested. \n        //\n        // This method returns a data object containing the nested data.  \n        // If a parent row is involved in nested relationship, \n        // then references to its child rows are added to the parent row in a child table array \n        // (providing the nested format).\n        // We are using the internal jsdo _data arrays, \n        // and adding a child table array to each parent row that has children.\n        // Once the caller is done with the nested data, \n        // they can call jsdo._unnestData() which removes these child table references\n        // \n        this._getDataObjectAsNested = function () {\n            var dataObject = {};\n            if (this._dataSetName) {\n                dataObject[this._dataSetName] = {};\n\n                try {\n                    // First walk thru all buffers. We need to determine if any of the buffers are\n                    // involved in a nested relationship. If so, we want to return the child's \n                    // data in nested format.\n                    for (var buf in this._buffers) {\n                        var bufObj = this._buffers[buf];\n\n\n                        // If this is a child table, and its involved in a nested relationship,\n                        // then just skip.\n                        // This table's data will be nested within each parent row when we \n                        // process the parent table.\n                        if (bufObj._isNested) continue;\n\n                        this._nestChildren = false;  // default to false\n\n                        // If table has children, see if any relationship is NESTED\t\n                        if (bufObj._children.length > 0) {\n                            for (var i = 0; i < bufObj._children.length; i++) {\n                                var childBufObj = this._buffers[bufObj._children[i]];\n\n                                if (childBufObj._isNested) {\n                                    this._nestChildren = true;\n                                    break;\n                                }\n                            }\n                        }\n\n                        dataObject[this._dataSetName][buf] = this._buffers[buf].getData();\n                    }\n                }\n                catch (e) {\n                    throw new Error(msg.getMsgText(\"jsdoMSG000\", e.message));\n                }\n                finally {\n                    // Set back to default avlue\n                    this._nestChildren = false;\n                }\n            }\n            else {\n                if (this._dataProperty) {\n                    dataObject[this._dataProperty] = this.getData();\n                }\n                else\n                    return this.getData(); // Array\n            }\n            return dataObject;\n        };\n\n\n        // This method is used in conjunction with _getDataObjectAsNested() in the JSDOReadService.\n        // _getDataObjectAsNested() adds arrays of child row references to their parent rows.\n        // Once the JSDOReadService has done its data mapping, we need to remove the references since\n        // internally the JSDO stores its data in unnested format.\n        this._unnestData = function () {\n\n            if (this._dataSetName) {\n                var parentRecord;\n                var bufObj;\n                var childBufObj;\n\n                // First walk thru all buffers. We need to determine if any of the buffers are parent\n                // buffers involved in a nested relationship. If so, then we'll look for any child row arrays\n                // to delete\n                for (var buf in this._buffers) {\n                    bufObj = this._buffers[buf];\n\n                    // If we know this table has at least one nested child table, we'll walk thru\n                    // all its rows to determine if the rows have any child row arrays.\n                    // It's more efficient to just walk thru the parent row list once, so we'll\n                    // check for all child row arrays here\n\n                    if (bufObj._hasNestedChild()) {\n                        // Now must walk thru the parent rows and delete any child row arrays\n                        for (var i = 0; i < bufObj._data.length; i++) {\n                            parentRecord = bufObj._data[i];\n\n                            for (var j = 0; j < bufObj._children.length; j++) {\n                                childBufObj = this._buffers[bufObj._children[j]];\n\n                                if (parentRecord[childBufObj._name]) {\n                                    delete parentRecord[childBufObj._name];\n                                }\n                            }\n\n                        }\n                    }\n                } // end for\n            }\n        };\n\n\n        this._recToDataObject = function (record, includeChildren) {\n            if (this._defaultTableRef)\n                return this._defaultTableRef._recToDataObject(record, includeChildren);\n            throw new Error(msg.getMsgText(\"jsdoMSG001\", \"_recToDataObject()\"));\n        };\n\n        this._recFromDataObject = function (dataObject) {\n            if (this._defaultTableRef)\n                return this._defaultTableRef._recFromDataObject(dataObject);\n            throw new Error(msg.getMsgText(\"jsdoMSG001\", \"_recFromDataObject()\"));\n        };\n\n        this.add = function (obj) {\n            if (this._defaultTableRef)\n                return this._defaultTableRef.add(obj);\n            throw new Error(msg.getMsgText(\"jsdoMSG001\", \"add() or create()\"));\n        };\n        \n        // Alias for add() method\n        this.create = this.add;\n        \n        this.hasData = function () {\n            for (var buf in this._buffers) {\n                if (this._buffers[this._buffers[buf]._name].hasData())\n                    return true;\n            }\n            return false;\n        };\n\n        this.getData = function (params) {\n            if (this._defaultTableRef)\n                return this._defaultTableRef.getData(params);\n            throw new Error(msg.getMsgText(\"jsdoMSG001\", \"getData()\"));\n        };\n\n        this.getSchema = function () {\n            if (this._defaultTableRef)\n                return this._defaultTableRef.getSchema();\n            throw new Error(msg.getMsgText(\"jsdoMSG001\", \"getSchema()\"));\n        };\n\n        this.findById = function (id) {\n            if (this._defaultTableRef)\n                return this._defaultTableRef.findById(id);\n            throw new Error(msg.getMsgText(\"jsdoMSG001\", \"findById()\"));\n        };\n\n        this._convertType = function (value, type, itemType) {\n            if ((typeof value != 'string') || (type === null)) return value;\n            var result = value;\n            try {\n                if (type == 'array') {\n                    var result = [];\n                    \n                    value = value.slice(1, value.length - 1);\n                    var elements = value.split(',');\n                    var convertItem = (itemType && (itemType != 'string'));\n                    for (var i = 0; i < elements.length; i++) {\n                       result[i] = convertItem ? this._convertType(elements[i], itemType, null) : elements[i];\n                    }\n                }\n                else if (type == 'integer') {\n                    result = parseInt(value);\n                }\n                else if (type == 'number') {\n                    result = parseFloat(value);\n                }\n                else {\n                    result = value;\n                }\n            }\n            catch (e) {\n                throw new Error(msg.getMsgText(\"jsdoMSG000\", \n                    \"Error converting string to native type: \" + e.message));\n            }\n            return result;\n        };\n\n        this.assign = function (values) {\n            if (this._defaultTableRef) {\n                return this._defaultTableRef.assign(values);\n            }\n            else\n                throw new Error(msg.getMsgText(\"jsdoMSG001\", \"assign() or update()\"));\n        };\n\n        // Alias for assign() method\n        this.update = this.assign;\n\n        this.remove = function () {\n            if (this._defaultTableRef) {\n                return this._defaultTableRef.remove();\n            }\n            else\n                throw new Error(msg.getMsgText(\"jsdoMSG001\", \"remove()\"));\n        };\n\n        this.getId = function () {\n            if (this._defaultTableRef)\n                return this._defaultTableRef.getId();\n            throw new Error(msg.getMsgText(\"jsdoMSG001\", \"getId()\"));\n        };\n\n\t\t// getErrors() - JSDO\n\t\tthis.getErrors = function () {\n            if (this._defaultTableRef)\n                return this._defaultTableRef.getErrors();\n            throw new Error(msg.getMsgText(\"jsdoMSG001\", \"getErrors()\"));\n\t\t};\n\n        this.getErrorString = function () {\n            if (this._defaultTableRef)\n                return this._defaultTableRef.getErrorString();\n            throw new Error(msg.getMsgText(\"jsdoMSG001\", \"getErrorString()\"));\n        };\n\n        /*\n         * Finds a record in the JSDO memory using the specified function to determine the record.\n         */\n        this.find = function (fn) {\n            if (this._defaultTableRef)\n                return this._defaultTableRef.find(fn);\n            throw new Error(msg.getMsgText(\"jsdoMSG001\", \"find()\"));\n        };\n\n        this.foreach = function (fn) {\n            if (this._defaultTableRef)\n                return this._defaultTableRef.foreach(fn);\n            throw new Error(msg.getMsgText(\"jsdoMSG001\", \"foreach()\"));\n        };\n\n        this.setSortFields = function (sortFields) {\n            if (this._defaultTableRef)\n                return this._defaultTableRef.setSortFields(sortFields);\n            throw new Error(msg.getMsgText(\"jsdoMSG001\", \"setSortFields()\"));\n        };\n\n        this.setSortFn = function (fn) {\n            if (this._defaultTableRef)\n                return this._defaultTableRef.setSortFn(fn);\n            throw new Error(msg.getMsgText(\"jsdoMSG001\", \"setSortFn()\"));\n        };\n\n        this.sort = function (arg1) {\n            if (this._defaultTableRef)\n                return this._defaultTableRef.sort(arg1);\n            throw new Error(msg.getMsgText(\"jsdoMSG001\", \"sort()\"));\n        };\n\n\t\tthis._clearErrors = function () {\n\t\t\tthis._lastErrors = [];\n            for (var buf in this._buffers) {\n\t\t\t\tthis._buffers[buf]._lastErrors = [];\n\t\t\t}\n\t\t};\n\n        /*\n         * Loads data from the HTTP resource.\n         */\n        this.fill = function () {\n            var objParam,\n                promise,\n\t\t\t\tproperties,\n\t\t\t\tmapping;\n                \n\t\t\tthis._clearErrors();\n\n            // Process parameters\n            if (arguments.length !== 0) {\n                // Call to fill() has parameters\n                if (typeof(arguments[0]) == 'function') {\n                    throw new Error(msg.getMsgText(\"jsdoMSG024\", \"JSDO\", \"fill() or read()\"));                \n                }\n                \n                // fill( string);\n                var filter;\n                if (arguments[0] === null || arguments[0] === undefined) {\n                    filter = \"\";\n                }\n                else if (typeof(arguments[0]) == \"string\") {\n                    filter = arguments[0];\n\t\t\t\t\tobjParam = {filter: filter};     \n\t\t\t\t}\n                else if (typeof(arguments[0]) == \"object\") {\n                    // options \n                    // ablFilter, id, top, skip, sort\n\t\t\t\t\t\n\t\t\t\t\tproperties = this.getMethodProperties(\"read\");\n\t\t\t\t\t\n                    // Use plugin if mappingType is not undefined, null, or \"\"\n\t\t\t\t\tif (properties && properties.mappingType) {\n\t\t\t\t\t\tmapping = progress.data.PluginManager.getPlugin(properties.mappingType);\n\t\t\t\t\t\tif (!mapping) {\n\t\t\t\t\t\t\tthrow new Error(msg.getMsgText(\"jsdoMSG118\", properties.mappingType));\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (typeof(mapping.requestMapping) === \"function\") {\n\t\t\t\t\t\t\tobjParam = mapping.requestMapping(this, arguments[0], { operation: \"read\" });\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tobjParam = arguments[0];\n\t\t\t\t\t\t} \n\t\t\t\t\t}\n\t\t\t\t\telse {\n                        if (properties.capabilities) {\n                            throw new Error(msg.getMsgText(\"jsdoMSG119\"));\n                        }\n\t\t\t\t\t\tobjParam = arguments[0];\t\t\t\t\t\t\n\t\t\t\t\t}\n                }\n                else {\n                    throw new Error(msg.getMsgText(\"jsdoMSG025\", \"JSDO\", \"fill() or read()\"));\n                }                  \n            }\n            else {\n                // fill();\t\t\t\n                objParam = null;\n            }\n\n            var xhr = new XMLHttpRequest();\n            var request = {\n                xhr: xhr,\n                jsdo: this,\n                objParam: objParam\n            };\n\n            xhr.request = request;\n            xhr.jsdo = this;\n\n            xhr.onSuccessFn = this._fillSuccess;\n            xhr.onErrorFn = this._fillError;\n            xhr.onCompleteFn = this._fillComplete;\n            xhr.onreadystatechange = this.onReadyStateChangeGeneric;\n\n            this.trigger(\"beforeFill\", this, request);\n\n            if (this._resource) {\n                if (typeof(this._resource.generic.read) == \"function\") {\n                    xhr.objParam = objParam;\n                    this._resource.generic.read(xhr, this._async);\n                    if (xhr.request.deferred) {\n                        promise = xhr.request.deferred.promise();\n                    }\n                }\n                else {\n                    throw new Error(\"JSDO: READ operation is not defined.\");\n                }\n            }\n            else {                \n                // Old approach to call READ\n                this._session._openRequest(xhr, 'GET', this.url, this._async);\n                try {\n                    xhr.send(null);\n                }\n                catch (e) {\n                    request.exception = e;\n                    // get the Client Context ID (AppServer ID)\n                    xhr.jsdo._session._checkServiceResponse(xhr, request.success, request);\n                }\n            }\n\n            return promise;\n        };\n\n        // Alias for fill() method\n        this.read = this.fill;\n\n        /*\n         * Clears all data (including any pending changes) for each buffer in JSDO\n         */\n        this._clearData = function () {\n            for (var buf in this._buffers) {\n                this._buffers[buf]._clearData();\n            }\n        };\n\n        /*\n         * Executes a CRUD operation using the built-in API.\n         */\n        this._execGenericOperation = function (operation, objParam, request, \n                                               onCompleteFn, onSuccessFn, onErrorFn) {\n\n            var xhr = new XMLHttpRequest();\n            request.xhr = xhr;\n            request.jsdo = this;\n            request.objParam = objParam;\n            request.operation = operation;\n            xhr.jsdo = this;\n            xhr.onCompleteFn = onCompleteFn;\n            xhr.onSuccessFn = onSuccessFn;\n            xhr.onErrorFn = onErrorFn;\n            xhr.onreadystatechange = this.onReadyStateChangeGeneric;\n            xhr.request = request;\n            \n            this._convertRequestData(objParam);\n\n            var operationStr;\n            switch (operation) {\n                case progress.data.JSDO._OP_READ:\n                case progress.data.JSDO._OP_CREATE:\n                case progress.data.JSDO._OP_UPDATE:\n                case progress.data.JSDO._OP_DELETE:\n                case progress.data.JSDO._OP_SUBMIT:\n                    operationStr = PROGRESS_JSDO_OP_STRING[operation];\n                    break;\n                default:\n                    throw new Error(\"JSDO: Unexpected operation \" + operation + \" in HTTP request.\");\n            }\n\n            if (this._resource) {\n                if (typeof(this._resource.generic[operationStr]) == \"function\") {\n                    xhr.objParam = objParam;\n                    this._resource.generic[operationStr](xhr, this._async);\n                }\n                else {\n                    // \"JSDO: {1} operation is not defined.\"\n                    throw new Error(msg.getMsgText(\"jsdoMSG046\", operationStr.toUpperCase() ));\n                }\n            }\n        };\n        \n        // Determines if any fields need a conversion when data sent to backend\n        this._initConvertForServer = function () {\n            var i, buf, schema;\n            \n            // If set, we're good. Field lists for conversion have already been created\n            if (this._convertForServer !== undefined) {\n                return;\n            }\n            \n            this._convertForServer = false;      \n            for (buf in this._buffers) {    \n                schema = this._buffers[buf].getSchema();\n                this._buffers[buf]._convertFieldsForServer = [];\n                this._buffers[buf]._convertForServer = false;\n                \n                // Check if any fields need conversion\n                for (i = 0; i < schema.length; i++) {\n                    if (schema[i].ablType && this._ablTypeNeedsConversion(schema[i].ablType)) {\n                        this._buffers[buf]._convertFieldsForServer.push({name: schema[i].name, \n                                                                         ablType: schema[i].ablType});\n                    }\n                }\n                if (this._buffers[buf]._convertFieldsForServer.length > 0) {\n                    this._convertForServer = true;\n                    this._buffers[buf]._convertForServer = true;\n                }\n            } \n        };\n        \n        this._convertRequestData = function (objParam) {\n            var buf,\n                beforeData; \n                \n            if (this._convertForServer === false) {\n                return;\n            }\n            \n            // We know at least one table has a field to convert \n            for (buf in this._buffers) { \n                if (this._buffers[buf]._convertForServer) {\n                    if (objParam[this._dataSetName]) {\n                        // First convert after-table\n                        if (objParam[this._dataSetName][buf]) {\n                            this._convertTableData(this._buffers[buf], objParam[this._dataSetName][buf]);\n                        }\n                        \n                        // Now let's convert before-image data \n                        beforeData = objParam[this._dataSetName][\"prods:before\"];\n                        if (beforeData && beforeData[buf]) {\n                            this._convertTableData(this._buffers[buf], beforeData[buf]); \n                        }   \n                    }\n                    // This is for case where saveChanges(false) is called with no before-image data\n                    else if (objParam[buf]) { \n                        this._convertTableData(this._buffers[buf], objParam[buf]);\n                    }\n                }\n            }                                                                        \n        };\n        \n        this._convertTableData = function (tableRef, tableData) {\n            var i;\n            \n            for (i = 0; i < tableData.length; i++) {\n                this._convertRowData(tableRef, tableData[i]);\n            }\n        };\n         \n        this._convertRowData = function (tableRef, record) {    \n            var i,\n                field;\n            \n            for (i = 0; i < tableRef._convertFieldsForServer.length; i += 1) {\n                field = tableRef._convertFieldsForServer[i];\n                record[field.name] = this._convertField(record[field.name], field.ablType);\n            }\n        };\n        \n        this._convertField = function (value, ablType) {\n            var result;\n            \n            if (value === undefined || value === null) {\n                return value;\n            }\n            \n            if (value instanceof Array) {\n                var resultArray = [];\n                for (var i = 0; i < value.length; i++) {\n                    resultArray[i] = this._convertField(value[i], ablType);     \n                }\n                return resultArray;\n            }\n            \n            try {\n                switch (ablType.toUpperCase()) {\n                    case \"DATE\":\n                    case \"DATETIME\":\n                        if (typeof value === 'string') {\n                            result = value;\n                        }\n                        else if (value instanceof Date) {\n                            result = this._convertDate(value, ablType.toUpperCase());\n                        }\n                        else {\n                            throw new Error(\"Unexpected value for  \" + ablType.toUpperCase() + \".\");\n                        }\n                        break;\n                    default:\n                        result = value;\n                        break;\n                }\n            }\n            catch (e) {\n                throw new Error(msg.getMsgText(\"jsdoMSG000\", \n                    \"Error in _convertField for value: \" + value + \". \" + e.message));\n            }\n            \n            return result;\n        };\n        \n        // Convert Date object to string for DATE and DATETIME ablTypes\n        // Not necessary to do for DATETIME-TZ since JSON.stringify() will do correct conversion \n        this._convertDate = function (value, ablType) {\n            var result = value;\n            \n            // DATE format should be in ISO 8601 format yyyy-mm-dd\n            // DATETIME format should be in ISO 8601 format yyyy-mm-ddThh:mm:ss.sss\n            if (ablType === \"DATE\" || ablType === \"DATETIME\") { \n                result =  progress.util._pad(value.getFullYear(), 4) + '-' + \n                          progress.util._pad(value.getMonth() + 1) + '-' + \n                          progress.util._pad(value.getDate());\n                    \n                if (ablType === \"DATETIME\") {\n                    result =  result + \"T\" + \n                         progress.util._pad(value.getHours()) + \":\" + \n                         progress.util._pad(value.getMinutes()) + \":\" + \n                         progress.util._pad(value.getSeconds()) + \".\" + \n                         progress.util._pad(value.getMilliseconds(), 3);\n                }              \n            }\n            \n             return result;\n        };\n        \n        \n        this._ablTypeNeedsConversion = function (ablType) {\n            \n            var needsConversion = false;\n            \n            switch (ablType.toUpperCase()) {\n                case \"DATE\":\n                case \"DATETIME\":\n                    needsConversion =  true;\n                    break;\n            }\n            \n            return needsConversion;     \n        };\n\n           \n\n        this._undefWorkingRecord = function () {\n            // Set record property\n            for (var buf in this._buffers) {\n                this._buffers[buf]._setRecord(null);\n            }\n        };\n\n        /*\n         * Saves changes in the JSDO. Save any outstanding changes for CREATES, UPDATE, and DELETEs\n         */\n        this.saveChanges = function (useSubmit) {\n            var promise,\n                request;\n\n            if (useSubmit === undefined) {\n                useSubmit = false;\n            }\n            else if (typeof(useSubmit) != 'boolean') {\n                throw new Error(msg.getMsgText(\"jsdoMSG025\", \"JSDO\", \"saveChanges()\"));\n            }\n            \n            // _fireCUDTriggersForSubmit() needs to know how saveChanges() was called\n            this._useSubmit = useSubmit; \n\n            // confirm the availability of the operations required for executing this saveChanges call\n            // (_checkThatJSDOHasRequiredOperations() throws an error if there's a missing operation,\n            // which this method deliberately allows to bubble up to the caller)\n            this._checkThatJSDOHasRequiredOperations(); \n            \n            // Don't allow Submit with just a temp-table if autoApplyChanges is true\n            if ( !this._dataSetName && this._useSubmit && this.autoApplyChanges) {\n                  /* error message: \"autoApplyChanges is not supported for submit with a temp-table */\n                  /* Use jsdo.autoApplyChanges = false.\" */\n                  throw new Error(msg.getMsgText(\"jsdoMSG124\")); \n            }\n            \n            // Check if any data being sent to server needs to first be converted\n            this._initConvertForServer();\n            \n            // Clear errors before sending request\n\t\t\tthis._clearErrors();\n\n            request = {\n                jsdo: this\n            };\n\n            this.trigger(\"beforeSaveChanges\", this, request);\n\n            if (useSubmit) {\n                /* Pass in request object. \n                 * Need to use same request object so before and after saveChanges events \n                 * are in sync in JSDO Submit Service. */\n                promise = this._syncDataSetForSubmit(request);\n            }\n            else if (this._dataSetName) {\n                promise = this._syncDataSetForCUD();\n            }\n            else {\n                promise = this._syncSingleTable();\n            }\n            \n            return promise;\n        };\n\n        /* \n         * _checkThatJSDOHasRequiredOperations\n            \n           This method is intended to be used by the saveChanges() method to determine whether \n           the JSDO's resource definition includes the operations necessary for executing the\n           types of changes that are pending in the JSDO. It checks for Submit if saveChanges\n           was called with useSubmit set to true, otherwise it checks whatever CUD operations are\n           pending. \n           The JSDO's internal _useSubmit property must be set correctly before this method \n           is called\n         */\n        this._checkThatJSDOHasRequiredOperations = function( ) {\n            var checkedDelete = false,\n                checkedCreate = false,\n                checkedUpdate = false,\n                buf,\n                tableRef;\n\n            if (!this._hasCUDOperations && !this._hasSubmitOperation) {\n                throw new Error(msg.getMsgText(\"jsdoMSG026\"));\n            }\n\n            // Validate the use of Submit\n            if (this._useSubmit) {\n                if (!this._hasSubmitOperation) {\n                    // \"JSDO: {1} operation is not defined.\";  \n                    throw new Error(msg.getMsgText(\"jsdoMSG046\", \"SUBMIT\"));\n                }\n                else {\n                    return;\n                }\n            }\n            \n            if (!this._resource) {\n                // Need the _resource property to do the validation. If not present, just return \n                // and let execution run as normal (presumably there will be an error)\n                return;\n            }\n           \n            // Find the pending operations and make sure they are defined\n            for (buf in this._buffers) {\n\n                tableRef = this._buffers[buf];\n\n                if (!checkedDelete && tableRef._deleted.length > 0) {\n                    this._confirmOperationExists( progress.data.JSDO._OP_DELETE );\n                    checkedDelete = true;\n                }\n                \n                if (!checkedCreate && tableRef._added.length > 0) {\n                    this._confirmOperationExists( progress.data.JSDO._OP_CREATE );\n                    checkedCreate = true;\n                }\n\n                if (!checkedUpdate && Object.keys(tableRef._changed).length > 0) {\n                    this._confirmOperationExists( progress.data.JSDO._OP_UPDATE );  \n                    checkedUpdate = true;\n                }\n                \n                if ( checkedDelete && checkedCreate && checkedUpdate ) {\n                    break;\n                }\n            }\n            \n        };\n\n        // Determines whether a given operation is defined by the JSDO's resource\n        // throws an error if it's not defined\n        this._confirmOperationExists = function(operation) {\n            var operationStr = PROGRESS_JSDO_OP_STRING[operation];\n            if (typeof(this._resource.generic[operationStr]) !== \"function\") {\n                // \"JSDO: {1} operation is not defined.\"\n                throw new Error(msg.getMsgText(\"jsdoMSG046\", operationStr.toUpperCase() ));\n            }\n        };\n        \n        this.invoke = function (name, object) {\n            var request = this[name](object);\n            if (request.deferred) {\n                return request.deferred.promise();\n            }\n            \n            return undefined;\n        };\n\n        /*\n         * Synchronizes changes for a TableRef\n         *\n         * @param operation\t\tHTTP operation to be performed\n         * @param tableRef\t\tHandle to the TableRef\n         * @param batch         Optional. batch information associated with the sync operation. \n         *                      If not specified a new one will be created.  Used for saving datasets.\n         */\n        this._syncTableRef = function (operation, tableRef, batch) {\n            var rowData,\n                requestData,\n                jsonObject;\n            \n            if (tableRef._visited) return;\n            tableRef._visited = true;\n\n            //ensure batch object is sane \n            if (!batch) {\n                batch = {\n                    operations: []\n                };\n            } else if (!batch.operations) {\n                batch.operations = [];\n            }\n\n            // Before children\n            // Create parent records before children\n            switch (operation) {\n                case progress.data.JSDO._OP_CREATE:\n                    for (var i = 0; i < tableRef._added.length; i++) {\n                        var id = tableRef._added[i];\n                        var jsrecord = tableRef._findById(id, false);\n\n                        if (!jsrecord) continue;\n                        if (tableRef._processed[id]) continue;\n                        tableRef._processed[id] = jsrecord.data;\n                        \n                        rowData = {};\n                        jsonObject = {};\n                        \n                        // Make copy of row data, in case we need to convert data for backend..\n                        tableRef._jsdo._copyRecord(tableRef, jsrecord.data, rowData);\n\n                        if (this.isDataSet()) {\n                            if (this._useBeforeImage(\"create\")) {\n                                jsonObject[this._dataSetName] = {};\n                                var dataSetObject = jsonObject[this._dataSetName];\n                                dataSetObject[\"prods:hasChanges\"] = true;\n\n                                dataSetObject[tableRef._name] = [];\n                                \n                                // Dont need to send prods:id for create, \n                                // no before table or error table to match\n                                // Dont need to send prods:clientId - since only sending one record\n                                rowData[\"prods:rowState\"] = \"created\";\n                                rowData[\"prods:clientId\"] = jsrecord.data._id;\n\n                                delete rowData[\"_id\"];\n\n                                dataSetObject[tableRef._name].push(rowData);\n                            }\n                            else {\n                                jsonObject[tableRef._name] = [];\n                                jsonObject[tableRef._name].push(rowData);\n                            }\n                        }\n                        else {\n                            jsonObject = rowData;\n                        }\n                            \n\n                        var request = {\n                            operation: operation,\n                            batch: batch,\n                            jsrecord: jsrecord,\n                            jsdo: this\n                        };\n                        batch.operations.push(request);\n\n                        jsrecord._tableRef.trigger(\"beforeCreate\", this, jsrecord, request);\n                        this.trigger(\"beforeCreate\", this, jsrecord, request);\n\n                        this._execGenericOperation(\n                            progress.data.JSDO._OP_CREATE, jsonObject, request, this._createComplete, \n                                this._createSuccess, this._createError);\n                    }\n                    break;\n                case progress.data.JSDO._OP_UPDATE:\n                    for (var id in tableRef._changed) {\n                        var jsrecord = tableRef._findById(id, false);\n\n                        if (!jsrecord) continue;\n                        if (tableRef._processed[id]) continue;\n                        tableRef._processed[id] = jsrecord.data;\n                        \n                        rowData = {};\n                        jsonObject = {};\n                        requestData = {};\n                        \n                        // Make copy of row data, in case we need to convert data for backend..\n                        tableRef._jsdo._copyRecord(tableRef, jsrecord.data, rowData);\n                        \n                        var useBeforeImageFormat = false;\n                        if (this.isDataSet()) {\n                            if (this._useBeforeImage(\"update\")) {\n                                useBeforeImageFormat = true;\n                                jsonObject[this._dataSetName] = {};\n                                var dataSetObject = jsonObject[this._dataSetName];\n                                dataSetObject[\"prods:hasChanges\"] = true;\n                                dataSetObject[tableRef._name] = [];\n\n                                // Dont need to send prods:clientId - since only sending one record\n                                rowData[\"prods:id\"] = jsrecord.data._id;\n                                rowData[\"prods:rowState\"] = \"modified\";\n                                rowData[\"prods:clientId\"] = jsrecord.data._id;\n                                delete rowData[\"_id\"];\n\n                                dataSetObject[tableRef._name].push(rowData);\n\n                                // Now create before-table data\n                                dataSetObject[\"prods:before\"] = {};\n                                var beforeObject = dataSetObject[\"prods:before\"];\n                                beforeObject[tableRef._name] = [];\n\n                                var beforeRowData = {};\n                                // Dont need to send prods:clientId - since only sending one record\n                                beforeRowData[\"prods:id\"] = jsrecord.data._id;\n\n                                tableRef._jsdo._copyRecord(tableRef, \n                                    tableRef._beforeImage[jsrecord.data._id], beforeRowData);\n                                delete beforeRowData[\"_id\"];\n\n                                beforeObject[tableRef._name].push(beforeRowData);\n                            }\n                        }\n\n                        if (!useBeforeImageFormat) {\n                            if (this._resource.service\n                                && this._resource.service.settings\n                                && this._resource.service.settings.sendOnlyChanges) {\n                                tableRef._jsdo._copyRecord(tableRef, jsrecord.data, requestData, \n                                    tableRef._beforeImage[jsrecord.data._id]);\n\n                                if (this._resource.idProperty) {\n                                    requestData[this._resource.idProperty] = \n                                        jsrecord.data[this._resource.idProperty];\n                                }\n                                else {\n                                    throw new Error(msg.getMsgText(\"jsdoMSG110\", this._resource.name, \n                                        \" for sendOnlyChanges property\"));\n                                }\n                            }\n                            else\n                                requestData = rowData;\n\n                            if (this.isDataSet()) {\n                                jsonObject[tableRef._name] = [];\n                                jsonObject[tableRef._name].push(requestData);\n                            }\n                            else {\n                                jsonObject = rowData;\n                            }\n                        }\n\n                        var request = {\n                            jsrecord: jsrecord,\n                            operation: operation,\n                            batch: batch,\n                            jsdo: this\n                        };\n                        batch.operations.push(request);\n\n                        jsrecord._tableRef.trigger(\"beforeUpdate\", this, jsrecord, request);\n                        this.trigger(\"beforeUpdate\", this, jsrecord, request);\n\n                        this._execGenericOperation(\n                            progress.data.JSDO._OP_UPDATE, jsonObject, request, this._updateComplete,\n                            this._updateSuccess, this._updateError);\n                    }\n                    break;\n            }\n\n            // Call _syncTableRef on child tables\n            for (var i = 0; i < tableRef._children.length; i++) {\n                var childTableName = tableRef._children[i];\n                this._syncTableRef(\n                    operation, this._buffers[childTableName], batch);\n            }\n\n            // After children\n            // Delete parent records after children\n\n            if (operation == progress.data.JSDO._OP_DELETE) {\n                for (var i = 0; i < tableRef._deleted.length; i++) {\n                    var id = tableRef._deleted[i]._id;\n                    var jsrecord = tableRef._deleted[i];\n\n                    if (!jsrecord) continue;\n                    tableRef._processed[id] = jsrecord.data;\n                    \n                    rowData = {};\n                    jsonObject = {};\n                    requestData = {};\n                        \n                    // Make copy of row data, in case we need to convert data for backend..\n                    tableRef._jsdo._copyRecord(tableRef, jsrecord.data, rowData);\n                        \n                    var useBeforeImageFormat = false;\n                    if (this.isDataSet()) {\n                        if (this._useBeforeImage(\"delete\")) {\n                            useBeforeImageFormat = true;\n                            jsonObject[this._dataSetName] = {};\n                            var dataSetObject = jsonObject[this._dataSetName];\n                            dataSetObject[\"prods:hasChanges\"] = true;\n\n                            // There is no after tables for deletes, so just create before-table data\n                            dataSetObject[\"prods:before\"] = {};\n                            var beforeObject = dataSetObject[\"prods:before\"];\n                            beforeObject[tableRef._name] = [];\n                            \n                            var beforeRowData = {};\n\n                            // Dont need to send prods:id for delete, no after table or error table to match\n                            // Dont need to send prods:clientId - since only sending one record\n                            beforeRowData[\"prods:rowState\"] = \"deleted\";\n                            beforeRowData[\"prods:clientId\"] = jsrecord.data._id;\n\n                            tableRef._jsdo._copyRecord(tableRef, \n                                tableRef._beforeImage[rowData._id], beforeRowData);\n                            beforeObject[tableRef._name].push(beforeRowData);\n                        }\n                    }\n\n                    if (!useBeforeImageFormat) {\n                        if (this._resource.service\n                            && this._resource.service.settings\n                            && this._resource.service.settings.sendOnlyChanges) {\n                            if (this._resource.idProperty) {\n                                requestData[this._resource.idProperty] = \n                                    jsrecord.data[this._resource.idProperty];\n                            }\n                            else {\n                                throw new Error(msg.getMsgText(\"jsdoMSG110\", this._resource.name, \n                                    \" for sendOnlyChanges property\"));\n                            }\n                        }\n                        else {\n                            requestData = rowData;\n                        }\n\n                        if (this.isDataSet()) {\n                            jsonObject[tableRef._name] = [];\n                            jsonObject[tableRef._name].push(requestData);\n                        }\n                        else {\n                            jsonObject = rowData;\n                        }\n                    }\n\n                    var request = {\n                        batch: batch,\n                        jsrecord: jsrecord,\n                        operation: operation,\n                        jsdo: this\n                    };\n\n                    batch.operations.push(request);\n\n                    jsrecord._tableRef.trigger(\"beforeDelete\", this, jsrecord, request);\n                    this.trigger(\"beforeDelete\", this, jsrecord, request);\n\n                    this._execGenericOperation(\n                        progress.data.JSDO._OP_DELETE, jsonObject, request, this._deleteComplete, \n                        this._deleteSuccess, this._deleteError);\n                }\n            }\n        };\n\n        /*\n         * Returns true if the specified operation type was specified in the catalog as useBeforeImage,\n         * else it returns false.\n         */\n        this._useBeforeImage = function (opType) {\n\n            for (var idx = 0; idx < this._resource.operations.length; idx++) {\n                if (this._resource.operations[idx].type == opType) {\n                    return this._resource.operations[idx].useBeforeImage;\n                }\n            }\n\n            return false;\n        };\n\n\n        /*\n         * Synchronizes changes for a DataSet. This is called when we send over one row at at time\n         * to Create, Update and Delete methods.\n         * It handles row with or without before-image data.\n         */\n        this._syncDataSetForCUD = function () {\n            var batch = {\n                    operations: []\n                },\n                deferred,\n                promise;\n            \n            if (typeof($) == 'function' && typeof($.Deferred) == 'function') {\n                deferred = $.Deferred();\n                promise = deferred.promise();\n                batch.deferred = deferred;\n            }            \n            \n            // Process buffers\n            // Synchronize deletes\n            for (var buf in this._buffers) {\n                this._buffers[buf]._visited = false;\n            }\n            for (var buf in this._buffers) {\n                var tableRef = this._buffers[buf];\n                this._syncTableRef(\n                    progress.data.JSDO._OP_DELETE, tableRef, batch);\n            }\n\n            // Synchronize adds\n            for (var buf in this._buffers) {\n                this._buffers[buf]._visited = false;\n            }\n            for (var buf in this._buffers) {\n                var tableRef = this._buffers[buf];\n                this._syncTableRef(\n                    progress.data.JSDO._OP_CREATE, tableRef, batch);\n            }\n\n            // Synchronize updates\n            for (var buf in this._buffers) {\n                this._buffers[buf]._visited = false;\n            }\n            for (var buf in this._buffers) {\n                var tableRef = this._buffers[buf];\n                this._syncTableRef(\n                    progress.data.JSDO._OP_UPDATE, tableRef, batch);\n            }\n\n            if (this.autoApplyChanges) {\n                for (var buf in this._buffers) {\n                    var tableRef = this._buffers[buf];\n                    tableRef._processed = {};\n                    tableRef._added = [];\n                    tableRef._changed = {};\n                    tableRef._deleted = [];\n                }\n            }\n\n            // OE00229270 If _async is false, this ensures that afterSaveChanges() is called just once \n            // We now do this after all operations have been processed\n            if (!this._async) {\n                if (this._isBatchComplete(batch)) {\n                    var success = this._isBatchSuccess(batch);\n                    var request = {\n                        batch: batch,\n                        success: success\n                    };\n                    this._undefWorkingRecord();\n                    \n                    // Save error messages\n                    this._lastErrors = [];\n                    if (!success && batch.operations) {\n                        this._updateLastErrors(this, batch, null);\n                    }\n                        \n                    this._fireAfterSaveChanges(success, request);\n                }\n            }\n            // end OE00229270\n\n            return promise;\n        };\n\n\n        /*\n         * Synchronizes changes for a single table\n         */\n        this._syncSingleTable = function () {\n            var deferred, promise;\n            if (!this._defaultTableRef) return;\n            var tableRef = this._defaultTableRef;\n\n            var batch = {\n                operations: []\n            };\n            \n            if (typeof($) == 'function' && typeof($.Deferred) == 'function') {\n                deferred = $.Deferred();\n                promise = deferred.promise();\n                batch.deferred = deferred;\n            }                \n\n            var fireAfterSaveChanges = false;\n\n            // Skip delete for records that were added\n            // mark them as processed\n            var addedRecords = {};\n            for (var i = 0; i < tableRef._added.length; i++) {\n                var id = tableRef._added[i];\n                addedRecords[id] = id;\n            }\n            for (var i = 0; i < tableRef._deleted.length; i++) {\n                var jsrecord = tableRef._deleted[i];\n                if (!jsrecord) continue;\n\n                var id = jsrecord.data._id;\n                if (addedRecords[id]) {\n                    // Set request object\n                    // Properties async, fnName, objParam, and response \n                    // are not set when the HTTP request is suppressed \n                    var request = {\n                        success: true,\n                        xhr: undefined,\n                        operation: progress.data.JSDO._OP_DELETE,\n                        batch: batch,\n                        jsrecord: jsrecord,\n                        jsdo: this\n                    };\n                    batch.operations.push(request);\n                    tableRef._processed[id] = jsrecord.data;\n\n                    var jsdo = request.jsdo;\n                    try {\n                        request.jsrecord._tableRef.trigger(\"afterDelete\", jsdo, request.jsrecord, \n                            request.success, request);\n                        jsdo.trigger(\"afterDelete\", jsdo, request.jsrecord, request.success, request);\n                    } finally {\n                        request.complete = true;\n                    }\n\n                    fireAfterSaveChanges = true;\n                }\n            }\n            addedRecords = null;\n\n            // Synchronize deletes\n            for (var i = 0; i < tableRef._deleted.length; i++) {\n                var jsrecord = tableRef._deleted[i];\n                if (!jsrecord) continue;\n\n                var id = jsrecord.data._id;\n                if (tableRef._processed[id]) continue;\n\n                tableRef._processed[id] = jsrecord.data;\n                fireAfterSaveChanges = false;\n\n                var xhr = new XMLHttpRequest();\n                xhr.jsdo = this;\n\n                var request = {\n                    xhr: xhr,\n                    operation: progress.data.JSDO._OP_DELETE,\n                    batch: batch,\n                    jsrecord: jsrecord,\n                    jsdo: this\n                };\n                batch.operations.push(request);\n                xhr.onCompleteFn = this._deleteComplete;\n                xhr.onSuccessFn = this._deleteSuccess;\n                xhr.onErrorFn = this._deleteError;\n                xhr.onreadystatechange = this.onReadyStateChangeGeneric;\n                xhr.request = request;\n\n                jsrecord._tableRef.trigger(\"beforeDelete\", this, jsrecord, request);\n                this.trigger(\"beforeDelete\", this, jsrecord, request);\n\n                var requestData = {};\n                if (this._resource.service\n                    && this._resource.service.settings\n                    && this._resource.service.settings.sendOnlyChanges) {\n                    if (this._resource.idProperty) {\n                        requestData[this._resource.idProperty] = jsrecord.data[this._resource.idProperty];\n                    }\n                    else {\n                        throw new Error(msg.getMsgText(\"jsdoMSG110\", this._resource.name, \n                            \" for sendOnlyChanges property\"));\n                    }\n                }\n                else {\n                    // We must copy record in case _convertRowData() needs to make conversion\n                    tableRef._jsdo._copyRecord(tableRef, jsrecord.data, requestData);\n                }\n                \n                if (tableRef._convertForServer) {\n                    this._convertRowData(tableRef, requestData);\n                } \n\n                if (this._resource) {\n                    if (typeof(this._resource.generic[\"delete\"]) == \"function\") {\n                        xhr.objParam = requestData;\n                        this._resource.generic[\"delete\"](xhr, this._async);\n                    }\n                    else {\n                        throw new Error(\"JSDO: DELETE operation is not defined.\");\n                    }\n                }\n                else {\n                    this._session._openRequest(xhr, 'DELETE', this.url + '/' + id, true);\n                    try {\n                        xhr.send(null);\n                    } catch (e) {\n                        request.success = false;\n                        request.exception = e;\n                        // let Session check for online/offline\n                        xhr.jsdo._session._checkServiceResponse(xhr, request.success, request);\n                    }\n\n                }\n            }\n\n            // Synchronize adds\n            for (var i = 0; i < tableRef._added.length; i++) {\n                var id = tableRef._added[i];\n                var jsrecord = tableRef._findById(id, false);\n                var requestData = {};\n\n                if (!jsrecord) continue;\n                if (tableRef._processed[id]) continue;\n                tableRef._processed[id] = jsrecord.data;\n                fireAfterSaveChanges = false;\n\n                var xhr = new XMLHttpRequest();\n                xhr.jsdo = this;\n                var request = {\n                    xhr: xhr,\n                    jsrecord: jsrecord,\n                    batch: batch,\n                    operation: progress.data.JSDO._OP_CREATE,\n                    jsdo: this\n                };\n                batch.operations.push(request);\n                xhr.onCompleteFn = this._createComplete;\n                xhr.onSuccessFn = this._createSuccess;\n                xhr.onErrorFn = this._createError;\n                xhr.onreadystatechange = this.onReadyStateChangeGeneric;\n                xhr.request = request;\n\n                jsrecord._tableRef.trigger(\"beforeCreate\", this, jsrecord, request);\n                this.trigger(\"beforeCreate\", this, jsrecord, request);\n\n                if (this._resource) {\n                    if (typeof(this._resource.generic.create) == \"function\") {\n                        this._copyRecord(tableRef, jsrecord.data, requestData);\n                        if (this._resource.idProperty !== undefined && jsrecord.data._id !== undefined) {\n                            // Remove _id when idProperty is set\n                            delete requestData._id;\n                        }\n                        \n                        if (tableRef._convertForServer) {\n                            this._convertRowData(tableRef, requestData);\n                        }  \n                        \n                        xhr.objParam = requestData;\n                        \n                        this._resource.generic.create(xhr, this._async);\n                    }\n                    else {\n                        throw new Error(\"JSDO: CREATE operation is not defined.\");\n                    }\n                    \n                }\n                else {\n                    this._session._openRequest(xhr, 'POST', this.url, true);\n                    xhr.setRequestHeader(\"Content-Type\", \"application/json; charset=utf-8\");\n                    this._copyRecord(tableRef, jsrecord.data, requestData);\n                    \n                    if (tableRef._convertForServer) {\n                        this._convertRowData(tableRef, requestData);\n                    } \n                    var input = JSON.stringify(requestData);\n                    \n                    try {\n                        xhr.send(input);\n                    } catch (e) {\n                        request.success = false;\n                        request.exception = e;\n                        // let Session check for online/offline\n                        xhr.jsdo._session._checkServiceResponse(xhr, request.success, request);\n                    }\n\n                }\n            }\n\n            // Synchronize updates\n            for (var id in tableRef._changed) {\n                var jsrecord = tableRef._findById(id, false);\n\n                if (!jsrecord) continue;\n                if (tableRef._processed[id]) continue;\n                tableRef._processed[id] = jsrecord.data;\n                fireAfterSaveChanges = false;\n\n                var xhr = new XMLHttpRequest();\n                var request = {\n                    xhr: xhr,\n                    jsrecord: jsrecord,\n                    operation: progress.data.JSDO._OP_UPDATE,\n                    batch: batch,\n                    jsdo: this\n                };\n                xhr.request = request;\n                xhr.jsdo = this;\n                batch.operations.push(request);\n                xhr.onCompleteFn = this._updateComplete;\n                xhr.onSuccessFn = this._updateSuccess;\n                xhr.onErrorFn = this._updateError;\n                xhr.onreadystatechange = this.onReadyStateChangeGeneric;\n\n                jsrecord._tableRef.trigger(\"beforeUpdate\", this, jsrecord, request);\n                this.trigger(\"beforeUpdate\", this, jsrecord, request);\n\n                var requestData = {};\n                if (this._resource.service\n                    && this._resource.service.settings\n                    && this._resource.service.settings.sendOnlyChanges) {\n                        \n                    tableRef._jsdo._copyRecord(tableRef, jsrecord.data, requestData, \n                        tableRef._beforeImage[jsrecord.data._id]);\n\n                    if (this._resource.idProperty) {\n                        requestData[this._resource.idProperty] = jsrecord.data[this._resource.idProperty];\n                    }\n                    else {\n                        throw new Error(msg.getMsgText(\"jsdoMSG110\", this._resource.name, \n                            \" for sendOnlyChanges property\"));\n                    }\n                }\n                else {\n                    // We must copy record in case _convertRowData() needs to make conversion\n                    tableRef._jsdo._copyRecord(tableRef, jsrecord.data, requestData);\n                }\n                \n                if (tableRef._convertForServer) {\n                    this._convertRowData(tableRef, requestData);\n                }\n\n                if (this._resource) {\n                    if (typeof(this._resource.generic.update) == \"function\") {\n                        xhr.objParam = requestData;\n                        this._resource.generic.update(xhr, this._async);\n                    }\n                    else {\n                        throw new Error(\"JSDO: UPDATE operation is not defined.\");\n                    }\n                }\n                else {\n                    this._session._openRequest(xhr, 'PUT', this.url + '/' + id, this._async);\n                    xhr.setRequestHeader(\"Content-Type\", \"application/json; charset=utf-8\");\n                    \n                    var input = JSON.stringify(requestData);\n                    \n                    try {\n                        xhr.send(input);\n                    } catch (e) {\n                        request.success = false;\n                        request.exception = e;\n                        // let Session check for online/offline\n                        xhr.jsdo._session._checkServiceResponse(xhr, request.success, request);\n                    }\n                }\n            }\n\n            if (this.autoApplyChanges) {\n                // Arrays to keep track of changes\n                tableRef._added = [];\n                tableRef._changed = {};\n                tableRef._deleted = [];\n                tableRef._processed = {};\n            }\n\n            // OE00229270 If _async is false, fire afterSaveChanges() after all operations are processed \n            if (!this._async)\n                fireAfterSaveChanges = true;\n\n            if (fireAfterSaveChanges) {\n                var jsdo = this;\n                var request = {\n                    batch: batch,\n                    success: true\n                };\n                \n                // Save error messages\n                jsdo._lastErrors = [];\n                if (batch.operations) {\n                    jsdo._updateLastErrors(jsdo, batch, null);\n                }\n                    \n                jsdo._undefWorkingRecord();\n                jsdo._fireAfterSaveChanges(request.success, request);\n            }\n\n            return promise;\n        };\n\n        /************************************************************************\n         *\n         * Synchronizes changes for a DataSet or a temp-table, sending over the entire change-set\n         * to saveChanges() on server\n         * If sync'ing a DataSet, sends over before-image and after-image data.\n         */\n        this._syncDataSetForSubmit = function (request) {\n            var deferred,\n                promise,\n                jsonObject,\n                completeFn = this._saveChangesComplete,\n                successFn = this._saveChangesSuccess,\n                errorFn =  this._saveChangesError;                \n            \n            if (typeof($) == 'function' && typeof($.Deferred) == 'function') {\n                deferred = $.Deferred();\n                promise = deferred.promise();\n                request.deferred = deferred;\n            }                        \n            \n            request.jsrecords = [];            \n\n            // First thing to do is to create jsonObject with before and after image data for all \n            // records in change-set (creates, updates and deletes)\n            if ( this._dataSetName ) {\n                jsonObject = this._createChangeSet(this._dataSetName, false, request);\n            }\n            else {\n                // just a temp-table. Need to create it somewhat differently from DS \n                // (no before and after image data)\n                jsonObject = this._createTTChangeSet(this._defaultTableRef, request);                \n                successFn = this._saveChangesSuccessTT;  // will process success response differently from DS\n            }\n            \n            this._execGenericOperation(progress.data.JSDO._OP_SUBMIT, jsonObject, request, \n                completeFn, successFn, errorFn);\n                \n            return promise;\n        };\n\n        /************************************************************************\n         *\n         * Private method that creates a jsonObject with before and after image data for all\n         * records in change-set (creates, updates and deletes)\n         *\n         * Params: dataSetName is required.\n         *         alwaysCreateTable is required. If true, always create table array (even if no data/changes)\n         *         request is optional\n         */\n        this._createChangeSet = function (dataSetName, alwaysCreateTable, request) {\n            var changeSetJsonObject = {};\n\n            changeSetJsonObject[dataSetName] = {};\n            var dataSetJsonObject = changeSetJsonObject[dataSetName];\n\n            var hasChanges = dataSetJsonObject[\"prods:hasChanges\"] = this._hasChanges();\n            if (hasChanges) {\n                if ((alwaysCreateTable === true)) {\n                    for (var buf in this._buffers) {\n                        dataSetJsonObject[this._buffers[buf]._name] = [];\n                    }\n                }\n\n                // First do deletes\n                //for (var buf in this._buffers) { this._buffers[buf]._visited = false; }\n                for (var buf in this._buffers) {\n                    var tableRef = this._buffers[buf];\n                    this._addDeletesToChangeSet(tableRef, dataSetJsonObject, request);\n                }\n\n                //  Adds\n                //for (var buf in this._buffers) { this._buffers[buf]._visited = false; }\n                for (var buf in this._buffers) {\n                    var tableRef = this._buffers[buf];\n                    this._addCreatesToChangeSet(tableRef, dataSetJsonObject, request);\n                }\n\n                // Updates\n                //for (var buf in this._buffers) { this._buffers[buf]._visited = false; }\n                for (var buf in this._buffers) {\n                    var tableRef = this._buffers[buf];\n                    this._addChangesToChangeSet(tableRef, dataSetJsonObject, request);\n                }\n\n                // Clear _processed map\n                for (var buf in this._buffers) {\n                    this._buffers[buf]._processed = {};\n                }\n            }\n\n            // Check if change set is empty\n            // A saveChanges() with a delete of new record would result in an empty change set        \n            // An empty DataSet is sent to the server to ensure that AfterSaveChanges fires\n            var keys = Object.keys(changeSetJsonObject[dataSetName]);\n            if (keys.length == 1 && keys[0] == \"prods:hasChanges\") {\n                for (var buf in this._buffers) {\n                    dataSetJsonObject[this._buffers[buf]._name] = [];\n                }\n                dataSetJsonObject[\"prods:hasChanges\"] = false;\n            }\n\n            return changeSetJsonObject;\n        };\n\n        /************************************************************************\n         *\n         * Private method that creates a jsonObject for the created and changed records\n         * in a temp-table. There is no before-image information. This is used in the\n         * case of a Submit operation when the JSDO is just for a temp-table \n         *\n         * Params: dataSetName is required.\n         *         alwaysCreateTable is required. If true, always create table array (even if no data/changes)\n         *         request is optional\n         */\n        this._createTTChangeSet = function (tableRef, request) {\n            var changeSetJsonObject = {},\n                hasChanges,\n                tempTableJsonObject,\n                i,\n                id,\n                jsrecord;\n\n            changeSetJsonObject[tableRef._name] = [];\n            tempTableJsonObject = changeSetJsonObject[tableRef._name];\n\n            hasChanges = this._hasChanges();\n            if (hasChanges) {\n                \n                // (note that we do not send deleted rows on submit for a temp-table)\n                \n                //  Adds\n                for (i = 0; i < tableRef._added.length; i++) {\n                    id = tableRef._added[i];\n                    jsrecord = tableRef._findById(id, false);\n                    if (jsrecord) {\n                        if ( !tableRef._processed[jsrecord.data._id] ) {\n                            this._addRowToTTChangeSet(tableRef, jsrecord, tempTableJsonObject,\n                                                       request, \"beforeCreate\");\n                        }\n                    }\n                }              \n\n                // changed rows\n                for (id in tableRef._changed) {\n                    if (tableRef._changed.hasOwnProperty(id)) {\n                        jsrecord = tableRef._findById(id, false);\n                        if (jsrecord) {\n                            if ( !tableRef._processed[jsrecord.data._id] ) {\n                                this._addRowToTTChangeSet(tableRef, jsrecord, tempTableJsonObject, \n                                                          request, \"beforeUpdate\");\n                            }\n                        }\n                    }\n                }              \n                \n                // Clear _processed map\n                tableRef._processed = {};\n            }\n\n            return changeSetJsonObject;\n        };\n\n        this._addRowToTTChangeSet = function (tableRef, jsrecord, tempTableJsonObject, request, event) {\n            var rowData = {};\n            \n            tableRef._processed[jsrecord.data._id] = jsrecord.data;\n            \n            // Store jsrecord in request object so we can access it when saveChanges completes, \n            // in order to run afterCreate events\n            if (typeof(request) != 'undefined') {\n                request.jsrecords.push(jsrecord);\n\n                // Need to call beforeCreate trigger when saveChanges(true) is called\n                jsrecord._tableRef.trigger(event, this, jsrecord, request);\n                this.trigger(event, this, jsrecord, request);\n            }\n            \n            tableRef._jsdo._copyRecord(tableRef, jsrecord.data, rowData);\n            delete rowData[\"_id\"];\n\n            tempTableJsonObject.push(rowData);\n        };\n\n        /************************************************************************\n         *\n         * Private method that creates a jsonObject with data and also before image data\n         *  for all records in change-set (creates, updates and deletes)\n         *\n         * Params: dataSetName is required.\n         * It returns jsonObject that can be used as input to addRecords()\n         */\n        this._createDataAndChangeSet = function (dataSetName) {\n            var jsonObject = {};\n\n            jsonObject[dataSetName] = {};\n            var dataSetJsonObject = jsonObject[dataSetName];\n\n            /* We always want to create tables (even if there's no data) so we can compare schemas\n             * of data in local storage to JSDO's schema */\n            for (var buf in this._buffers)\n                dataSetJsonObject[this._buffers[buf]._name] = [];\n\n            if (this._hasChanges()) {\n                dataSetJsonObject[\"prods:hasChanges\"] = true;\n            }\n\n            // Add data from each table. This will also add bi data for any created or updated rows\n            for (var buf in this._buffers) {\n                var tableRef = this._buffers[buf];\n                this._addRecordsToObject(tableRef, dataSetJsonObject);\n            }\n\n            // Now do deletes\n            for (var buf in this._buffers) {\n                var tableRef = this._buffers[buf];\n                this._addDeletesToChangeSet(tableRef, dataSetJsonObject);\n            }\n\n            // Clear _processed map\n            for (var buf in this._buffers) {\n                this._buffers[buf]._processed = {};\n            }\n            return jsonObject;\n        };\n\n        // This method adds all record for specified table into dataSetJsonObject.\n        // If record has bi data, it adds that as well\n        this._addRecordsToObject = function (tableRef, dataSetJsonObject) {\n\n            if (tableRef._data.length > 0 && !dataSetJsonObject[tableRef._name])\n                dataSetJsonObject[tableRef._name] = [];\n\n            for (var i = 0; i < tableRef._data.length; i++) {\n                var record = tableRef._data[i];\n                if (!record) continue;\n\n                // Check if record has bi data, can only determine if it's created or changed since\n                // deleted rows are not in after data\n                if (this._doesRecordHaveCreateBIData(tableRef, record._id) === true) {\n                    var jsrecord = tableRef._findById(record._id, false);\n                    if (!jsrecord) continue;\n                    if (tableRef._processed[jsrecord.data._id]) continue;\n                    this._addCreatedRowToChangeSet(tableRef, jsrecord, dataSetJsonObject);\n                }\n                if (this._doesRecordHaveUpdateBIData(tableRef, record._id) === true) {\n                    var jsrecord = tableRef._findById(record._id, false);\n                    if (!jsrecord) continue;\n                    if (tableRef._processed[jsrecord.data._id]) continue;\n                    this._addChangedRowToChangeSet(tableRef, jsrecord, dataSetJsonObject);\n                }\n                else {\n                    if (tableRef._processed[record._id]) continue;\n                    tableRef._processed[record._id] = record;\n\n                    var rowData = {};\n\n                    tableRef._jsdo._copyRecord(tableRef, record, rowData);\n                    delete rowData[\"_id\"];\n\n                    dataSetJsonObject[tableRef._name].push(rowData);\n                }\n            }\n        };\n\n\n        // Check if specified after record has bi data for newly created record.\n        // Returns True if after record has corresponding bi data, else false\n        this._doesRecordHaveCreateBIData = function (tableRef, id) {\n            for (var i = 0; i < tableRef._added.length; i++) {\n                if (tableRef._added[i] === id)\n                    return true;\n            }\n\n            return false;\n        };\n\n        // Check if specified after record has bi data for updated record.\n        // Returns True if after record has corresponding bi data, else false\n        this._doesRecordHaveUpdateBIData = function (tableRef, id) {\n            for (var changedId in tableRef._changed) {\n                if (changedId === id)\n                    return true;\n            }\n\n            return false;\n        };\n\n\n        // If a create, remove or update exists, method returns true, else returns false\n        this._hasChanges = function () {\n            var hasChanges = false;\n\n            for (var buf in this._buffers) {\n                var tableRef = this._buffers[buf];\n\n                var hasUpdates = false;\n                for (var id in tableRef._changed) {\n                    hasUpdates = true;\n                    break;\n                }\n\n                if (tableRef._deleted.length > 0 || tableRef._added.length > 0 || hasUpdates) {\n                    hasChanges = true;\n                    break;\n                }\n            }\n            \n            return hasChanges;\n        };\n\n        // This method is used when saveChanges() is called, and also when storing data to local storage.\n        // The request param should be defined for saveChanges(),\n        // but not needed when storing data to local storage\n        this._addDeletesToChangeSet = function (tableRef, dataSetJsonObject, request) {\n            // There is no after table for deletes, so just create before-table data\n            for (var i = 0; i < tableRef._deleted.length; i++) {\n                var jsrecord = tableRef._deleted[i];\n\n                if (!jsrecord) continue;\n\n                if (jsrecord.data\n                    && jsrecord.data._id !== undefined\n                    && tableRef._beforeImage[jsrecord.data._id] === null) {\n                    // Deleted record is for a new record - do not send deleted record to server\n                    continue;\n                }\n\n                this._addDeletedRowToChangeSet(tableRef, jsrecord, dataSetJsonObject, request);\n            }\n        };\n\n        this._addDeletedRowToChangeSet = function (tableRef, jsrecord, dataSetJsonObject, request) {\n            tableRef._processed[jsrecord.data._id] = jsrecord.data;\n\n            // Store jsrecord in request object so we can access it when saveChanges completes, \n            // in order to run afterDelete events\n            jsrecord.data[\"prods:rowState\"] = \"deleted\";\n\n            if (typeof(request) != 'undefined') {\n                request.jsrecords.push(jsrecord);\n\n                // Need to call beforeDelete trigger if saveChanges(true) is called\n                jsrecord._tableRef.trigger(\"beforeDelete\", this, jsrecord, request);\n                this.trigger(\"beforeDelete\", this, jsrecord, request);\n            }\n\n            var beforeRowData = {};\n            // AppServer will roundtrip this back to jsdo client\n            beforeRowData[\"prods:clientId\"] = jsrecord.data._id;\n            beforeRowData[\"prods:rowState\"] = \"deleted\";\n\n            var beforeTableJsonObject = this._getTableInBeforeJsonObject(dataSetJsonObject, tableRef._name);\n            tableRef._jsdo._copyRecord(tableRef, tableRef._beforeImage[jsrecord.data._id], beforeRowData);\n            delete beforeRowData[\"_id\"];\n\n            beforeTableJsonObject.push(beforeRowData);\n        };\n\n        // This method is used when saveChanges() is called, and also when storing data to local storage.\n        // The request param should be defined for saveChanges(), \n        // but not needed when storing data to local storage\n        this._addCreatesToChangeSet = function (tableRef, dataSetJsonObject, request) {\n            // There is no before table for creates, so just create after-table data\n            for (var i = 0; i < tableRef._added.length; i++) {\n                var id = tableRef._added[i];\n                var jsrecord = tableRef._findById(id, false);\n                if (!jsrecord) continue;\n                if (tableRef._processed[jsrecord.data._id]) continue;\n\n                this._addCreatedRowToChangeSet(tableRef, jsrecord, dataSetJsonObject, request);\n            }\n        };\n\n        this._addCreatedRowToChangeSet = function (tableRef, jsrecord, dataSetJsonObject, request) {\n            tableRef._processed[jsrecord.data._id] = jsrecord.data;\n\n            if (!dataSetJsonObject[tableRef._name]) {\n                dataSetJsonObject[tableRef._name] = [];\n            }\n\n            // Store jsrecord in request object so we can access it when saveChanges completes, \n            // in order to run afterCreate events\n            jsrecord.data[\"prods:rowState\"] = \"created\";\n\n            if (typeof(request) != 'undefined') {\n                request.jsrecords.push(jsrecord);\n\n                // Need to call beforeCreate trigger when saveChanges(true) is called\n                jsrecord._tableRef.trigger(\"beforeCreate\", this, jsrecord, request);\n                this.trigger(\"beforeCreate\", this, jsrecord, request);\n            }\n\n            var rowData = {};\n            // AppServer will roundtrip this back to jsdo client\n            rowData[\"prods:clientId\"] = jsrecord.data._id;\n            rowData[\"prods:rowState\"] = \"created\";\n\n            tableRef._jsdo._copyRecord(tableRef, jsrecord.data, rowData);\n            delete rowData[\"_id\"];\n\n            dataSetJsonObject[tableRef._name].push(rowData);\n        };\n\n        // This method is used when saveChanges() is called, and also when storing data to local storage.\n        // The request param should be defined for saveChanges(),\n        // but not needed when storing data to local storage\n        this._addChangesToChangeSet = function (tableRef, dataSetJsonObject, request) {\n            // For Changes, there is both before and after table data\n            for (var id in tableRef._changed) {\n                var jsrecord = tableRef._findById(id, false);\n                if (!jsrecord) continue;\n                if (tableRef._processed[jsrecord.data._id]) continue;\n\n                this._addChangedRowToChangeSet(tableRef, jsrecord, dataSetJsonObject, request);\n            }\n        };\n\n        this._addChangedRowToChangeSet = function (tableRef, jsrecord, dataSetJsonObject, request) {\n            tableRef._processed[jsrecord.data._id] = jsrecord.data;\n\n            if (!dataSetJsonObject[tableRef._name]) {\n                dataSetJsonObject[tableRef._name] = [];\n            }\n\n            // Store jsrecord in request object so we can access it when saveChanges completes, in order\n            // to run afterUpdate events\n            jsrecord.data[\"prods:rowState\"] = \"modified\";\n\n            if (typeof(request) != 'undefined') {\n                request.jsrecords.push(jsrecord);\n\n                // Need to call beforeUpdate trigger when saveChanges(true) is called\n                jsrecord._tableRef.trigger(\"beforeUpdate\", this, jsrecord, request);\n                this.trigger(\"beforeUpdate\", this, jsrecord, request);\n            }\n\n            var rowData = {};\n            // Required by AppServer in before-image data. Matches before row\n            rowData[\"prods:id\"] = jsrecord.data._id;\n            // AppServer will roundtrip this back to jsdo client\n            rowData[\"prods:clientId\"] = jsrecord.data._id;\n            rowData[\"prods:rowState\"] = \"modified\";\n\n            tableRef._jsdo._copyRecord(tableRef, jsrecord.data, rowData);\n            delete rowData[\"_id\"];\n\n            dataSetJsonObject[tableRef._name].push(rowData);\n\n            // Now add before-image data\n            var beforeTableJsonObject = this._getTableInBeforeJsonObject(dataSetJsonObject, tableRef._name);\n            var beforeRowData = {};\n            // Required by AppServer in before-image data. Matches after row\n            beforeRowData[\"prods:id\"] = jsrecord.data._id;\n\n            tableRef._jsdo._copyRecord(tableRef, tableRef._beforeImage[jsrecord.data._id], beforeRowData);\n            //delete beforeRowData[\"_id\"]; \n\n            beforeTableJsonObject.push(beforeRowData);\n        };\n\n\n        // Private method to get table's json object from the specified dataset json object.\n        // If it hasn't been created yet, this method creates it.\n        this._getTableInBeforeJsonObject = function (dataSetJsonObject, tableName) {\n            if (!dataSetJsonObject[\"prods:before\"]) {\n                dataSetJsonObject[\"prods:before\"] = {};\n            }\n            var beforeObject = dataSetJsonObject[\"prods:before\"];\n\n            if (!beforeObject[tableName]) {\n                beforeObject[tableName] = [];\n            }\n\n            return beforeObject[tableName];\n        };\n        \n\n        /*********************************************************************\n         *\n         * Reads a JSON object into the JSDO memory.\n         */\n        this.addRecords = function (jsonObject, addMode, keyFields, trackChanges, isInvoke) {\n            if (this.isDataSet()) {\n                if (jsonObject instanceof Array) {\n                    if (!this._defaultTableRef) {\n                        throw new Error(msg.getMsgText(\"jsdoMSG998\"));\n                    }\n                }\n                else {\n                    if (jsonObject === undefined || jsonObject === null) {\n                        jsonObject = {};\n                    }\n\n                    if (jsonObject[this._dataSetName]) {\n                        jsonObject = jsonObject[this._dataSetName];\n                    }\n                }\n\n                // Allow empty object in addRecords with MODE_EMPTY\n                if (addMode != progress.data.JSDO.MODE_EMPTY) {\n                    if (Object.keys(jsonObject).length === 0)\n                        throw new Error(msg.getMsgText(\"jsdoMSG006\"));\n                }\n\n                var oldUseRelationships = this.useRelationships;\n                // Turn off useRelationships since addRecords() does not use the working record\t\t\t\n                this.useRelationships = false;\n                try {\n                    for (var buf in this._buffers) {\n                        // Read data for tables in JSON object\n                        if (jsonObject[this._buffers[buf]._name])\n                            this._addRecords(this._buffers[buf]._name, jsonObject, addMode, \n                                keyFields, trackChanges, isInvoke);\n                        else if (addMode == progress.data.JSDO.MODE_EMPTY) {\n                            this._buffers[this._buffers[buf]._name]._clearData();\n                        }\n                    }\n                } finally {\n                    // Restore useRelationships\n                    this.useRelationships = oldUseRelationships;\n                }\n            }\n            else if (this._defaultTableRef) {\n                this._addRecords(this._defaultTableRef._name, jsonObject, addMode, keyFields, \n                    trackChanges, isInvoke);\n            }\n        };\n\n        /*\n         * Copies the fields of the source record to the target record.\n         * Preserves the _id of the target record.\n         */\n        this._copyRecord = function (tableRef, source, target, onlyChangesRecord) {\n            for (var field in source) {\n\n                if (onlyChangesRecord !== undefined) {\n                    if (source[field] == onlyChangesRecord[field])\n                        continue;\n                }\n\n                // Fix for PSC00277769\n                if (source[field] === undefined || source[field] === null) {\n                    target[field] = source[field];\n                }\n                else if (source[field] instanceof Date) {\n                    target[field] = source[field];\n                }                    \n                else if (typeof source[field] === 'object') {\n                    var newObject = source[field] instanceof Array ? [] : {};\n                    this._copyRecord(tableRef, source[field], newObject);\n                    target[field] = newObject;\n                }\n                else\n                    target[field] = source[field];\n            }\n        };\n\n        /*\n         * Deletes the \"prods:\" properties when no longer needed, \n         * typically when doing acceptChanges, rejectChanges, or _applyChanges.\n         * These properties are used to transfer before-image info between client JSDO and AppServer.\n         *\n         * Also, it optionally clears out the errorString field depending upon value of clearErrorString. \n         * To be consistent with the handling of \n         * the ABL's Buffer ERROR-STRING attribute, \n         * the errorString field should be cleared out when doing acceptChanges() or rejectChanges().\n         */\n        this._deleteProdsProperties = function (record, clearErrorString, deleteRowState) {\n\n            /* Default to false */\n            if (typeof(clearErrorString) == 'undefined') {\n                clearErrorString = false;\n            }\n\n            /* Default to true */\n            if (typeof(deleteRowState) == 'undefined') {\n                deleteRowState = true;\n            }\n\n            if (record) {\n                delete record[\"prods:id\"];\n                delete record[\"prods:hasErrors\"];\n                delete record[\"prods:clientId\"];\n\n                if (deleteRowState) {\n                    delete record[\"prods:rowState\"];\n                }\n\n                if (clearErrorString) {\n                    delete record._errorString;\n                }\n            }\n        };\n\n        this._addRecords = function (tableName, jsonObject, addMode, keyFields, trackChanges, isInvoke) {\n            var beforeImageJsonObject = null;\n            var beforeImageJsonIndex = null;\n\n            if (jsonObject && (this._dataSetName !== undefined)) {\n                if (jsonObject[this._dataSetName] &&\n                    jsonObject[this._dataSetName][\"prods:hasChanges\"]) {\n                    beforeImageJsonObject = jsonObject;\n                    beforeImageJsonIndex = {};\n                }\n                else if (jsonObject[\"prods:hasChanges\"]) {\n                    beforeImageJsonObject = {};\n                    beforeImageJsonObject[this._dataSetName] = jsonObject;\n                    beforeImageJsonIndex = {};\n                }\n            }\n\n            if (typeof(tableName) != 'string')\n                throw new Error(msg.getMsgText(\"jsdoMSG020\"));\n            if (!addMode)\n                throw new Error(msg.getMsgText(\"jsdoMSG021\"));\n\n            switch (addMode) {\n                case progress.data.JSDO.MODE_APPEND:\n                case progress.data.JSDO.MODE_EMPTY:\n                case progress.data.JSDO.MODE_MERGE:\n                case progress.data.JSDO.MODE_REPLACE:\n                    break;\n                default:\n                    throw new Error(msg.getMsgText(\"jsdoMSG022\"));\n            }\n\n            if (!keyFields)\n                keyFields = [];\n            else {\n                if (!(keyFields instanceof Array) && (typeof(keyFields) == 'object')) {\n                    if (keyFields[tableName]) {\n                        keyFields = keyFields[tableName];\n                    }\n                    else {\n                        keyFields = [];\n                    }\n                }\n            }\n\n            if (!(keyFields instanceof Array)) {\n                throw new Error(msg.getMsgText(\"jsdoMSG008\"));\n            }\n\n            // Check that the specified field names are in the schema\n            if (this._buffers[tableName]._fields) {\n                for (var i = 0; i < keyFields.length; i++) {\n                    var field = this._buffers[tableName]._fields[keyFields[i].toLowerCase()];\n                    if (field === undefined) {\n                        throw new Error(msg.getMsgText(\"jsdoMSG009\", keyFields[i]));\n                    }\n                    else {\n                        keyFields[i] = field.name;\n                    }\n                }\n            }\n\n            trackChanges = trackChanges ? true : false;\n\n            if (tableName) {\n                if (!(jsonObject instanceof Array)) {\n                    var data = null;\n\n                    if (jsonObject === undefined || jsonObject === null) {\n                        jsonObject = {};\n                    }\n\n                    if (this.isDataSet()) {\n                        if (jsonObject[this._dataSetName])\n                            data = jsonObject[this._dataSetName][tableName];\n                        else if (jsonObject[tableName])\n                            data = jsonObject[tableName];\n                    } else {\n                        if (this._dataProperty)\n                            data = jsonObject[this._dataProperty];\n                        else if (jsonObject.data)\n                            data = jsonObject.data;\n                    }\n\n\n                    if (data instanceof Array) {\n                        saveJsonObject = jsonObject;\n                        jsonObject = data;\n                    }\n                    else if ((addMode == progress.data.JSDO.MODE_EMPTY)\n                        && (typeof  (jsonObject) == 'object')\n                        && (Object.keys(jsonObject).length === 0)) {\n                        jsonObject = []; // Allow empty object in addRecords with\n                        // MODE_EMPTY\n                    }\n                    // Allow empty object when called by restoreChangesOnlyForTable()\n                    // where there are only deletes - in bi data\n                    else if ((addMode == progress.data.JSDO.MODE_REPLACE)\n                        && (typeof  (jsonObject) == 'object')\n                        && (beforeImageJsonObject)) {\n                        jsonObject = [];\n                    }\n                }\n\n                if (!(jsonObject instanceof Array)) {\n                    throw new Error(msg.getMsgText(\"jsdoMSG005\", tableName));\n                }\n\n                var dataHasBeenProcessed = false;\n                try {\n                    this._buffers[tableName]._sortRecords = false;\n                    if (keyFields.length === 0 || addMode == progress.data.JSDO.MODE_EMPTY) {\n                        // Quick merge\n                        if (addMode == progress.data.JSDO.MODE_EMPTY) {\n                            this._buffers[tableName]._clearData();\n                        }\n                        // APPEND, MERGE, REPLACE\n                        for (var i = 0; i < jsonObject.length; i++) {\n                            var jsrecord = this._buffers[tableName]._add(jsonObject[i], trackChanges, false);\n                            jsonObject[i]._id = jsrecord.data._id;\n                            if (beforeImageJsonIndex && jsonObject[i][\"prods:id\"]) {\n                                beforeImageJsonIndex[jsonObject[i][\"prods:id\"]] = jsrecord.data._id;\n                            }\n                            if (beforeImageJsonObject) {\n                                this._deleteProdsProperties(jsrecord.data);\n                            }\n                        }\n                    }\n                    else {\n                        // Build temporary index\n                        var tmpIndex;\n\n                        if (this._buffers[tableName]._data.length * jsonObject.length >= 10) {\n                            tmpIndex = {};\n\n                            for (var i = 0; i < this._buffers[tableName]._data.length; i++) {\n                                var record = this._buffers[tableName]._data[i];\n                                if (!record) continue;\n\n                                var key = this._buffers[tableName]._getKey(record, keyFields);\n                                tmpIndex[key] = record;\n                            }\n\n                        }\n                        else\n                            tmpIndex = null; // Do not use an index\n                        var checkBeforeImage = \n                            (Object.keys(this._buffers[tableName]._beforeImage).length !== 0);\n                        for (var i = 0; i < jsonObject.length; i++) {\n                            var match = false;\n                            var record = null;\n\n                            // Check for duplicates\n                            if (tmpIndex) {\n                                var key = this._buffers[tableName]._getKey(jsonObject[i], keyFields);\n                                record = tmpIndex[key];\n                                match = (record !== undefined);\n                            }\n                            else {\n                                for (var j = 0; j < this._buffers[tableName]._data.length; j++) {\n                                    record = this._buffers[tableName]._data[j];\n                                    if (!record) continue;\n                                    match = \n                                    (this._buffers[tableName]._equalRecord(jsonObject[i], record, keyFields));\n                                    if (match) {\n                                        // Duplicate found\n                                        break;\n                                    }\n                                }\n                            }\n\n                            if (match) {\n                                if (isInvoke \n                                    && (this._resource.idProperty !== undefined) \n                                    && (jsonObject[i]._id === undefined)) {\n                                    // Add _id to jsonObject\n                                    jsonObject[i]._id = record._id;\n                                }\n\n                                // If beforeRecord is null, there is entry in _beforeImage for a create.\n                                // If beforeRecord is undefined, there is no entry\n                                var beforeRecord = this._buffers[tableName]._beforeImage[record._id];\n                                if (checkBeforeImage \n                                    && (jsonObject[i][\"prods:id\"] !== undefined) \n                                    && (typeof beforeRecord !== 'undefined')) {\n                                    // Only throw exception if the existing bi data \n                                    // is not the same as the new bi data\n                                    var isAfterSame = this._sameData(jsonObject[i], record);\n                                    var isBeforeSame = true;\n\n                                    // For creates, beforeRecord will be null\n                                    if (beforeRecord) {\n                                        var beforeObject = this._getBeforeRecordFromObject(jsonObject[i], \n                                            beforeImageJsonObject, tableName);\n                                        if (beforeObject)\n                                            isBeforeSame = this._sameData(beforeObject, beforeRecord);\n                                    }\n\n                                    if (!isAfterSame || !isBeforeSame)\n                                        throw new Error(msg.getMsgText(\"jsdoMSG032\"));\n                                }\n\n                                switch (addMode) {\n                                    case progress.data.JSDO.MODE_APPEND:\n                                        throw new Error(msg.getMsgText(\"jsdoMSG023\"));\n                                    case progress.data.JSDO.MODE_MERGE:\n                                        /* Ignore duplicate */\n                                        if (beforeImageJsonIndex && jsonObject[i][\"prods:id\"]) {\n                                            beforeImageJsonIndex[jsonObject[i][\"prods:id\"]] = record._id;\n                                        }\n                                        break;\n                                    case progress.data.JSDO.MODE_REPLACE:\n                                        if (beforeImageJsonIndex && jsonObject[i][\"prods:id\"]) {\n                                            beforeImageJsonIndex[jsonObject[i][\"prods:id\"]] = record._id;\n                                        }\n\n                                        if (jsonObject[i]._id === undefined)\n                                            jsonObject[i]._id = record._id;\n                                        this._copyRecord(\n                                            this._buffers[tableName],\n                                            jsonObject[i], record);\n                                        this._deleteProdsProperties(record);\n                                        break;\n                                    default:\n                                        break;\n                                }\n                            }\n                            else {\n                                // Add record\n                                var jsrecord = \n                                    this._buffers[tableName]._add(jsonObject[i], trackChanges, false);\n                                jsonObject[i]._id = jsrecord.data._id;\n                                if (beforeImageJsonIndex && jsonObject[i][\"prods:id\"]) {\n                                    beforeImageJsonIndex[jsonObject[i][\"prods:id\"]] = jsrecord.data._id;\n                                }\n                                if (beforeImageJsonObject) {\n                                    this._deleteProdsProperties(jsrecord.data);\n                                }\n                                if (tmpIndex) {\n                                    var key = this._buffers[tableName]._getKey(jsrecord.data, keyFields);\n                                    tmpIndex[key] = jsrecord.data;\n                                }\n                            }\n\n                        }\n                        tmpIndex = null;\n                    }\n                    dataHasBeenProcessed = true;\n                }\n                finally {\n                    this._buffers[tableName]._sortRecords = true;\n                    this._buffers[tableName]._sort();\n                    this._buffers[tableName]._createIndex();\n\n                    if (dataHasBeenProcessed && beforeImageJsonObject) {\n                        this._buffers[tableName]._loadBeforeImageData(beforeImageJsonObject, \n                            beforeImageJsonIndex, keyFields);\n                    }\n                }\n            }\n        };\n\n        // This method returns corresponding bi record of the afterRecord from specified jsonObject\n        this._getBeforeRecordFromObject = function (afterRecord, jsonObject, tablename) {\n            var beforeData = jsonObject[this._dataSetName][\"prods:before\"];\n            var id = afterRecord[\"prods:id\"];\n            var beforeRecord;\n\n            if (!beforeData) return beforeRecord;\n\n            // First check to see if the before data is the same\n            for (var i = 0; i < beforeData[tablename].length; i++) {\n                var record = beforeData[tablename][i];\n                if (record[\"prods:id\"] && id == record[\"prods:id\"]) {\n                    beforeRecord = record;\n                    break;\n                }\n            }\n\n            return beforeRecord;\n        };\n\n        this._sameData = function (record1, record2) {\n            var value1, value2;\n            for (var fieldName in record1) {\n                if (fieldName.substring(0, 5) != \"prods\" && fieldName != \"_id\") {\n                    value1 = record1[fieldName];\n                    value2 = record2[fieldName];\n\n                    if (value1 > value2 || value1 === null)\n                        return false;\n                    else if (value1 < value2 || value2 === null)\n                        return false;\n                }\n            }\n\n            return true;\n        };\n\n\n        // private method to merge changes after a read operation    \n        this._mergeRead = function (jsonObject, xhr) {\n            if (this.isDataSet()) {\n                if (this._dataProperty) {\n                    var datasetBuffer = this._buffers[this._dataProperty];\n                    datasetBuffer._data = jsonObject[this._dataSetName][this._dataProperty];\n                    if (datasetBuffer.autoSort) {\n                        datasetBuffer._sort();\n                    }\n                    datasetBuffer._createIndex();\n                }\n                else {\n                    // Load data from JSON object into _data\n                    for (var buf in this._buffers) {\n                        var data;\n                        if (jsonObject[this._dataSetName])\n                            data = jsonObject[this._dataSetName][buf];\n                        else\n                            data = null;\n                        data = data ? data : [];\n                        this._buffers[buf]._data = data;\n                        if (this._buffers[buf].autoSort) {\n                            this._buffers[buf]._sort();\n                        }\n                        this._buffers[buf]._createIndex();\n                        if (jsonObject[this._dataSetName] \n                            && jsonObject[this._dataSetName][\"prods:hasChanges\"]) {\n                            this._buffers[buf]._loadBeforeImageData(jsonObject);\n                        }\n                    }\n                    // Load nested data into _data\n                    if (this._numBuffers > 1) {\n                        for (var buf in this._buffers) {\n                            if (this._buffers[buf]._isNested\n                                && this._buffers[buf]._parent\n                                && this._buffers[this._buffers[buf]._parent]) {\n                                var srcData = this._buffers[this._buffers[buf]._parent]._data;\n                                var data = [];\n                                for (var i = 0; i < srcData.length; i++) {\n                                    if (srcData[i][buf] !== undefined) {\n                                        for (var j = 0; j < srcData[i][buf].length; j++) {\n                                            data.push(srcData[i][buf][j]);\n                                        }\n                                        delete srcData[i][buf];\n                                    }\n                                }\n                                this._buffers[buf]._data = data;\n                                if (this._buffers[buf].autoSort) {\n                                    this._buffers[buf]._sort();\n                                }\n                                this._buffers[buf]._createIndex();\n                            }\n                        }\n                    }\n                }\n            }\n            else {\n                if (jsonObject instanceof Array) {\n                    this._defaultTableRef._data = jsonObject;\n                }\n                else {\n                    if (this._dataProperty)\n                        this._defaultTableRef._data = jsonObject[this._dataProperty];\n                    else if (jsonObject.data)\n                        this._defaultTableRef._data = jsonObject.data;\n                    else {\n                        this._defaultTableRef._data = [];\n                        this._defaultTableRef._data[0] = jsonObject;\n                    }\n                }\n            }\n\n            for (var buf in this._buffers) {\n                if (this._buffers[buf].autoSort) {\n                    this._buffers[buf]._sort();\n                }\n                this._buffers[buf]._createIndex();\n            }\n        };\n\n        /**\n         * Replace existing record data and index entry with new record data.\n         */\n        this._mergeUpdateRecord = function (tableRef, recordId, record) {\n            var index = tableRef._index[recordId].index;\n            record._id = recordId;\n            \n            if (!tableRef._data[index]) {\n                tableRef._data[index] = {};\n            }\n            this._copyRecord(this._tableRef, record, tableRef._data[index]);\n            record = tableRef._data[index];\n\n            if (tableRef._jsdo._resource.idProperty !== undefined) {\n                var id = tableRef._data[index][tableRef._jsdo._resource.idProperty];\n                if (id !== undefined) {\n                    delete tableRef._index[recordId];\n                    id += \"\";\n                    tableRef._index[id] = new progress.data.JSIndexEntry(index);\n                    record._id = id;\n                }\n            }\n\n            return record;\n        };\n\n\n        /**\n         *update existing record data with specified error string\n         */\n        this._setErrorString = function (tableRef, recordId, errorString, setInBeforeTable) {\n\n            if (setInBeforeTable) {\n                // Ensure that object exists, it's null for deleted rows\n                if (tableRef._beforeImage[recordId]) {\n                    tableRef._beforeImage[recordId]._errorString = errorString;\n                }\n            }\n            else {\n                var index = tableRef._index[recordId].index;\n                tableRef._data[index]._errorString = errorString;\n            }\n        };\n\n        /*\n         * Returns the array with the data from the specified dataObject. \n         */\n        this._arrayFromDataObject = function (dataObject, tableRef) {\n            var data;\n\n            if (dataObject === undefined) return undefined;\n            if (this._dataSetName) {\n                if (dataObject[this._dataSetName])\n                    data = dataObject[this._dataSetName][tableRef._name];\n            }\n            else {\n                // check if data returned as array\n                if (dataObject instanceof Array) {\n                    data = dataObject;\n                } else {\n                    // or if data property is set\n                    if (this._dataProperty) {\n                        data = dataObject[this._dataProperty];\n                    } else if (dataObject.data) {\n                        // or just try with 'data' as the data property name\n                        data = dataObject.data;\n                    }\n                }\n            }\n\n            return data;\n        };\n\n        /////////////////////////////////////////////////////////////////////////////////////////////\n        //\n        // Private method to merge changes after a create or update operation.\n        // This method is called to merge changes when server's Create or Update methods were called. \n        //\n        // It returns true if it found error for row in before-image data (prods:hasErrors = true)\n        // It returns false if there is no before-image data or prods:hasErrors property is absent\n        this._mergeUpdateForCUD = function (jsonObject, xhr) {\n            var hasError = false,\n                errorString;\n\n            // Update dataset with changes from server\n            if (this._dataSetName) {\n                var dataSetJsonObject = jsonObject[this._dataSetName];\n\n                // only updates the specified record\n                var tableRef = xhr.request.jsrecord._tableRef;\n                var tableJsonObject = this._arrayFromDataObject(jsonObject, tableRef);\n\n                if (tableJsonObject instanceof Array) {\n                    if (tableJsonObject.length > 1) {\n                        xhr.request.success = false;\n                        throw new Error(msg.getMsgText(\"jsdoMSG100\"));\n                    }\n\n                    for (var i = 0; i < tableJsonObject.length; i++) {\n                        var recordId = xhr.request.jsrecord.getId();\n\n                        if (!recordId) {\n                            throw new Error(msg.getMsgText(\"jsdoMSG034\", \"_mergeUpdateForCUD()\"));\n                        }\n\n                        // Determine if error string (get prods_id before _mergeUpdateRecord() is called, \n                        // since it removes all prods properties)\n                        errorString = undefined;\n\n                        if (tableJsonObject[i][\"prods:hasErrors\"]) {\n                            var prods_id = tableJsonObject[i][\"prods:id\"];\n                            errorString = \n                                this._getErrorStringFromJsonObject(dataSetJsonObject, tableRef, prods_id);\n                            hasError = true;\n                        }\n\n                        var record = this._mergeUpdateRecord(tableRef, recordId, tableJsonObject[i]);\n                        if (errorString)\n                            this._setErrorString(tableRef, recordId, errorString, false);\n\n                        xhr.request.jsrecord = new progress.data.JSRecord(tableRef, record);\n                    }\n                }\n            } else {\n                // update single record with changes from server\n                var tableRef = this._defaultTableRef;\n                var data = this._arrayFromDataObject(jsonObject);\n\n                if (data instanceof Array) {\n                    if (data.length > 1) {\n                        xhr.request.success = false;\n                        throw new Error(msg.getMsgText(\"jsdoMSG100\"));\n                    }\n\n                    for (var i = 0; i < data.length; i++) {\n                        var recordId = xhr.request.jsrecord.getId();\n\n                        if (!recordId) {\n                            throw new Error(msg.getMsgText(\"jsdoMSG034\", \"_mergeUpdateForCUD()\"));\n                        }\n\n                        var record = this._mergeUpdateRecord(tableRef, recordId, data[i]);\n                        xhr.request.jsrecord = new progress.data.JSRecord(tableRef, record);\n                    }\n                }\n            }\n\n            return hasError;\n        };\n\n\n        /////////////////////////////////////////////////////////////////////////////////////////////\n        //\n        // Private method to determine if deleted row (from delete operation) returned from AppServer \n        // was returned with an error in the before-image data.\n        //\n        // It returns true if it found an error for row in before-image data (prods:hasErrors = true)\n        // It returns false if there is no before-image data or prods:hasErrors property is absent\n\n        this._checkForDeleteError = function (dataSetJsonObject, xhr) {\n            var hasError = false;\n            var tableRef = xhr.request.jsrecord._tableRef;\n\n            beforeJsonObject = dataSetJsonObject[\"prods:before\"];\n\n            // No merge is necessary for deletes, but we need to see \n            // if there are any errors on deletes records.\n            // delete records are not in after table, only in before table\n            if (beforeJsonObject) {\n                var beforeTableJsonObject = beforeJsonObject[tableRef._name];\n\n                if (beforeTableJsonObject.length > 1) {\n                    xhr.request.success = false;\n                    throw new Error(msg.getMsgText(\"jsdoMSG100\"));\n                }\n                // clientId is same as _id\n                var recordId = beforeTableJsonObject[0][\"prods:clientId\"];\n                if (!recordId) {\n                    throw new Error(msg.getMsgText(\"jsdoMSG035\", \"_checkForDeleteError()\"));\n                }\n\n                // Determine if row was returned with error string\n                if (beforeTableJsonObject[0][\"prods:hasErrors\"]) {\n                    var prods_id = beforeTableJsonObject[0][\"prods:id\"];\n                    var errorString = \n                        this._getErrorStringFromJsonObject(dataSetJsonObject, tableRef, prods_id);\n                    this._setErrorString(tableRef, recordId, errorString, true);\n                    hasError = true;\n                }\n            }\n\n            return hasError;\n        };\n\n        /////////////////////////////////////////////////////////////////////////////////////////////\n        //\n        // Private method to merge changes after a call to saveChanges.\n        // This method is called when saveChanges(useSubmit) was called with useSubmit=true.\n        // This can process/merge one or more created, deleted or updated records.\n        // In order for a jsonObject to have before-image data, it must be associated with a dataset.\n        //\n        // It only merges changes in the after table. But we need to look at before-image table to see \n        // if there were any errors passed back for the deletes \n        // \n        this._mergeUpdateForSubmit = function (jsonObject, xhr) {\n            var errorString;\n            \n            //if (!this._dataSetName || !jsonObject[this._dataSetName][\"prods:hasChanges\"])\n            if (!this._dataSetName) {\n                // \"_mergeUpdateForSubmit() can only be called for a dataset\"\n                throw new Error(msg.getMsgText(\"jsdoMSG036\", \"_mergeUpdateForSubmit()\"));\n            }\n\n            // response is sent back with extra dataset object wrapper\n            var dataSetJsonObject = jsonObject[this._dataSetName];\n            if (dataSetJsonObject[this._dataSetName])\n                dataSetJsonObject = dataSetJsonObject[this._dataSetName];\n\n            var beforeJsonObject = dataSetJsonObject[\"prods:before\"];\n\n            for (var buf in this._buffers) {\n                var tableRef = this._buffers[buf];\n\n                var tableJsonObject = dataSetJsonObject[tableRef._name];\n                if (tableJsonObject instanceof Array) {\n                    for (var i = 0; i < tableJsonObject.length; i++) {\n\n                        var recordId = tableJsonObject[i][\"prods:clientId\"];\n                        if (!recordId) {\n                            throw new Error(msg.getMsgText(\"jsdoMSG035\", \"_mergeUpdateForSubmit()\"));\n                        }\n\n                        // Determine if error string (get prods_id before _mergeUpdateRecord() is called, \n                        // since it removes all prods properties)\n                        errorString = undefined;\n\n                        if (tableJsonObject[i][\"prods:hasErrors\"]) {\n                            var prods_id = tableJsonObject[i][\"prods:id\"];\n                            errorString = \n                                this._getErrorStringFromJsonObject(dataSetJsonObject, tableRef, prods_id);\n                        }\n                        var record = this._mergeUpdateRecord(tableRef, recordId, tableJsonObject[i]);\n                        if (errorString)\n                            this._setErrorString(tableRef, recordId, errorString, false);\n\n                        // Now need to update jsrecords. \n                        // We use this data when we fire create, update and delete events.\n                        // Updating so that it contains latest data (data sent back from server) \n                        var jsrecords = xhr.request.jsrecords;\n                        for (var idx = 0; idx < jsrecords.length; idx++) {\n                            if (jsrecords[idx].data[\"_id\"] == recordId) {\n                                jsrecords[idx].data = record;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n\n            // No merge is necessary for deletes, \n            // but we need to see if there are any errors on deletes records.\n            // delete records are not in after table, only in before table\n            if (beforeJsonObject) {\n                for (var buf in this._buffers) {\n                    var tableRef = this._buffers[buf];\n                    var beforeTableJsonObject = beforeJsonObject[tableRef._name];\n\n                    if (beforeTableJsonObject instanceof Array) {\n                        for (var i = 0; i < beforeTableJsonObject.length; i++) {\n\n                            if (beforeTableJsonObject[i][\"prods:rowState\"] == \"deleted\") {\n                                var recordId = beforeTableJsonObject[i][\"prods:clientId\"];\n                                if (!recordId) {\n                                    throw new Error(msg.getMsgText(\"jsdoMSG035\", \"_mergeUpdateForSubmit()\"));\n                                }\n\n                                // If row was returned with error string, just copy that over to jsdo record\n                                if (beforeTableJsonObject[i][\"prods:hasErrors\"]) {\n                                    var prods_id = beforeTableJsonObject[i][\"prods:id\"];\n                                    var errorString = this._getErrorStringFromJsonObject(dataSetJsonObject, \n                                        tableRef, prods_id);\n                                    this._setErrorString(tableRef, recordId, errorString, true);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        };\n\n        /////////////////////////////////////////////////////////////////////////////////////////////\n        //\n        // Private method that fires afterCreate, afterUpdate and afterDelete (CUD) triggers after\n        // saveChanges(true) is called. We must fire create, update and delete triggers \n        // for each record that was sent to backend submit operation \n        this._fireCUDTriggersForSubmit = function (request) {\n            // Before firing triggers, delete prods properties (except rowState) so they don't appear in data\n            for (var idx = 0; idx < request.jsrecords.length; idx++) {\n                this._deleteProdsProperties(request.jsrecords[idx].data, false, false);\n            }\n\n            for (var idx = 0; idx < request.jsrecords.length; idx++) {\n                var jsrecord = request.jsrecords[idx];\n                switch (jsrecord.data[\"prods:rowState\"]) {\n                    case \"created\":\n                        jsrecord._tableRef.trigger(\"afterCreate\", this, jsrecord, request.success, request);\n                        this.trigger(\"afterCreate\", this, jsrecord, request.success, request);\n                        break;\n                    case \"modified\":\n                        jsrecord._tableRef.trigger(\"afterUpdate\", this, jsrecord, request.success, request);\n                        this.trigger(\"afterUpdate\", this, jsrecord, request.success, request);\n                        break;\n                    case \"deleted\":\n                        jsrecord._tableRef.trigger(\"afterDelete\", this, jsrecord, request.success, request);\n                        this.trigger(\"afterDelete\", this, jsrecord, request.success, request);\n                        break;\n                }\n            }\n        };\n\n        //////////////////////////////////////////////////////////////////////////////////////////////\n        //\n        // Private method to return error for specified row \n        // from jsonObject's prods:errors object (before-data) sent over from AppServer\n        //\n        this._getErrorStringFromJsonObject = function (dataSetJsonObject, tableRef, prods_id) {\n            var tableJsonObject;\n            var errorsJsonObject = dataSetJsonObject[\"prods:errors\"];\n\n            if (errorsJsonObject) {\n                tableJsonObject = errorsJsonObject[tableRef._name];\n            }\n\n            if (tableJsonObject instanceof Array) {\n                for (var i = 0; i < tableJsonObject.length; i++) {\n\n                    var id = tableJsonObject[i][\"prods:id\"];\n                    if (id === prods_id) {\n                        var errorString = tableJsonObject[i][\"prods:error\"];\n                        return errorString === null ? \n                            \"Server returned unspecified error. Please check log files.\" : errorString;\n                    }\n                }\n            }\n\n            return undefined;\n        };\n\n        this._fillSuccess = function (jsdo, success, request) {\n            var xhr = request.xhr,\n                properties;     \n            \n            // Need to check if responseMapping was specified; developer can specify\n            // plug-in to manipulate response \n            properties = jsdo.getMethodProperties(\"read\");\n            \n            if (properties && properties.mappingType) {\n                mapping = progress.data.PluginManager.getPlugin(properties.mappingType);\n                if (!mapping) {\n                    throw new Error(progress.data._getMsgText(\"jsdoMSG118\", properties.mappingType));\n                }\n                                \n                if (typeof (mapping.responseMapping) === \"function\") {\n                    request.response = mapping.responseMapping(jsdo, request.response, { operation: \"read\" });\n                }                \n            } \n\n            jsdo._clearData();\n            jsdo._mergeRead(request.response, xhr);   \n\n            // Set working record\n            for (var buf in jsdo._buffers) {\n                if (!jsdo._buffers[buf]._parent || !jsdo.useRelationships) {\n                    jsdo._buffers[buf]._setRecord(jsdo._buffers[buf]._findFirst());\n                }\n            }\n        };\n\n        this._fillComplete = function (jsdo, success, request) {\n            jsdo.trigger(\"afterFill\", jsdo, request.success, request);\n            if (request.deferred) {\n                if (success) {\n                    request.deferred.resolve(jsdo, success, request);\n                }\n                else {\n                    request.deferred.reject(jsdo, success, request);              \n                }\n            }\n        };\n\n        this._fillError = function (jsdo, success, request) {\n            jsdo._clearData();            \n            jsdo._updateLastErrors(jsdo, null, null, request);\n        };\n\n        this._undoCreate = function (tableRef, id) {\n            // Undo operation \n            // Remove record from JSDO memory\n            var entry = tableRef._index[id];\n            if (entry !== undefined) {\n                var index = entry.index;\n                tableRef._data[index] = null;\n            }\n            tableRef._hasEmptyBlocks = true;\n            delete tableRef._index[id];\n            delete tableRef._beforeImage[id];\n            // End - Undo operation\t\t\n        };\n\n        this._undoUpdate = function (tableRef, id, deleteProdsProps) {\n            /* Default to false */\n            if (typeof(deleteProdsProps) == 'undefined') {\n                deleteProdsProps = false;\n            }\n\n            // Undo operation\n            // Restore from before image\n            var record = tableRef._beforeImage[id];\n\n            // Before image points to an existing record\n            if (record) {\n                var index = tableRef._index[id].index;\n                tableRef._jsdo._copyRecord(tableRef, record, tableRef._data[index]);\n                if (deleteProdsProps)\n                    tableRef._jsdo._deleteProdsProperties(tableRef._data[index], true);\n            }\n            delete tableRef._beforeImage[id];\n            // End - Restore before image\t\t\n        };\n\n        this._undoDelete = function (tableRef, id, deleteProdsProps) {\n            /* Default to false */\n            if (typeof(deleteProdsProps) == 'undefined') {\n                deleteProdsProps = false;\n            }\n\n            // Restore from before image\n            var record = tableRef._beforeImage[id];\n\n            // Before image points to an existing record\n            if (record) {\n                var index = record._index;\n                delete record._index;\n                if (deleteProdsProps)\n                    tableRef._jsdo._deleteProdsProperties(record, true);\n\n                if ((index !== undefined) && (tableRef._data[index] === null)) {\n                    tableRef._data[index] = record;\n                }\n                else {\n                    tableRef._data.push(record);\n                    index = tableRef._data.length - 1;\n                }\n                tableRef._index[id] = new progress.data.JSIndexEntry(index);\n            }\n            delete tableRef._beforeImage[id];\n            // End - Restore before image\t\t\n        };\n\n        this._deleteComplete = function (jsdo, success, request) {\n            var xhr = request.xhr;\n            var jsrecord = request.jsrecord;\n\n            try {\n                // Before firing trigger, delete prods properties so they don't appear in data\n                jsdo._deleteProdsProperties(jsrecord.data, false);\n\n                jsrecord._tableRef.trigger(\"afterDelete\", jsdo, jsrecord, request.success, request);\n                jsdo.trigger(\"afterDelete\", jsdo, jsrecord, request.success, request);\n\n            } finally {\n                request.complete = true;\n                jsdo._checkSaveComplete(xhr);\n            }\n        };\n\n        this._deleteSuccess = function (jsdo, success, request) {\n            var xhr = request.xhr;\n            var jsonObject = request.response;\n            var beforeJsonObject = null;\n            var dataSetJsonObject = null;\n            var data;\n\n            //Even though this is _deleteSuccess, if before-image data is returned, the call of \n            // delete operation could return a success, but we have to check if error was returned \n            // in before-image data \n            var hasError = false;\n            if (jsdo._useBeforeImage(\"delete\")) {\n                dataSetJsonObject = jsonObject[jsdo._dataSetName];\n                beforeJsonObject = dataSetJsonObject[\"prods:before\"];\n\n                if (beforeJsonObject) {\n                    data = beforeJsonObject[request.jsrecord._tableRef._name];\n                }\n            }\n            else {\n                data = jsdo._arrayFromDataObject(jsonObject, request.jsrecord._tableRef);\n            }\n\n            if (data instanceof Array) {\n                if (data.length > 1) {\n                    request.success = false;\n                    throw new Error(msg.getMsgText(\"jsdoMSG100\"));\n                }\n            }\n\n            if (beforeJsonObject) {\n                hasError = jsdo._checkForDeleteError(dataSetJsonObject, xhr);\n            }\n\n            if (hasError)\n                request.success = false;\n\n            if (jsdo.autoApplyChanges) {\n                if (!hasError) {\n                    // Clear before image\n                    delete request.jsrecord._tableRef._beforeImage[request.jsrecord.data._id];\n                    // End - Clear before image\n                }\n                else {\n                    jsdo._deleteError(jsdo, success, request);\n                }\n            }\n        };\n\n        this._deleteError = function (jsdo, success, request) {\n            if (jsdo.autoApplyChanges) {\n                jsdo._undoDelete(request.jsrecord._tableRef, request.jsrecord.data._id);\n            }\n        };\n\n        this._createComplete = function (jsdo, success, request) {\n            var xhr = request.xhr;\n            var jsrecord = request.jsrecord;\n\n            try {\n                // Before firing trigger, delete prods properties so they don't appear in data\n                jsdo._deleteProdsProperties(jsrecord.data, false);\n\n                jsrecord._tableRef.trigger(\"afterCreate\", jsdo, jsrecord, request.success, request);\n                jsdo.trigger(\"afterCreate\", jsdo, jsrecord, request.success, request);\n            } finally {\n                request.complete = true;\n                jsdo._checkSaveComplete(xhr);\n            }\n        };\n\n        this._createSuccess = function (jsdo, success, request) {\n            var xhr = request.xhr;\n            var record = request.response;\n            var hasError = jsdo._mergeUpdateForCUD(record, xhr);\n\n            if (hasError)\n                request.success = false;\n\n            if (jsdo.autoApplyChanges) {\n                if (!hasError) {\n                    // Clear before image\n                    delete request.jsrecord._tableRef._beforeImage[request.jsrecord.data._id];\n                    // End - Clear before image\n                }\n                else {\n                    jsdo._createError(jsdo, success, request);\n                }\n            }\n        };\n\n        this._createError = function (jsdo, success, request) {\n            if (jsdo.autoApplyChanges) {\n                jsdo._undoCreate(request.jsrecord._tableRef, request.jsrecord.data._id);\n            }\n        };\n\n\n        this._updateComplete = function (jsdo, success, request) {\n            var xhr = request.xhr;\n            var jsrecord = request.jsrecord;\n            try {\n                // Before firing trigger, delete prods properties so they don't appear in data\n                jsdo._deleteProdsProperties(jsrecord.data, false);\n\n                jsrecord._tableRef.trigger(\"afterUpdate\", jsdo, jsrecord, request.success, request);\n                jsdo.trigger(\"afterUpdate\", jsdo, jsrecord, request.success, request);\n            } finally {\n                request.complete = true;\n                jsdo._checkSaveComplete(xhr);\n            }\n        };\n\n        this._updateSuccess = function (jsdo, success, request) {\n            var xhr = request.xhr;\n            var hasError = jsdo._mergeUpdateForCUD(request.response, xhr);\n\n            if (hasError)\n                request.success = false;\n\n            if (jsdo.autoApplyChanges) {\n                if (!hasError) {\n                    request.success = true;\n                    // Clear before image\n                    delete request.jsrecord._tableRef._beforeImage[request.jsrecord.data._id];\n                    // End - Clear before image\t\t\n                }\n                else {\n                    jsdo._updateError(jsdo, success, request);\n                }\n            }\n        };\n\n        this._updateError = function (jsdo, success, request) {\n\n            if (jsdo.autoApplyChanges) {\n                request.success = false;\n                jsdo._undoUpdate(request.jsrecord._tableRef, request.jsrecord.data._id);\n            }\n        };\n\n\n        this._saveChangesSuccess = function (jsdo, success, request) {\n            var records = request.response;\n            jsdo._mergeUpdateForSubmit(records, request.xhr);\n\n            // Ensure that that the _lastErrors variable has been cleared \n\t\t\tjsdo._clearErrors();\n            var changes = jsdo.getChanges();\n            jsdo._updateLastErrors(jsdo, null, changes);\n\n            if (jsdo.autoApplyChanges) {\n                jsdo._applyChanges();\n            }\n        };\n\n\n        this._saveChangesError = function (jsdo, success, request) {\n            if (jsdo.autoApplyChanges) {\n                jsdo.rejectChanges();\n            }\n            jsdo._updateLastErrors(jsdo, null, null, request);\n        };\n\n        /*  _saveChangesSuccessTT\n            internal function called after a Submit of a temp-table (not DataSet) returns success\n            This method does not attempt to do any merging of records into the JSDO memory. The\n            absence of _id for the records means that the only way we could possibly do a \"merge\"\n            would be to delete the changed rceords in the JSDO memory and then add the records\n            that were returned form the data service, but that would invalidate the _id's that\n            the Kendo datasource depends on. The application programmmer must do the merging in\n            the afterSaveChanges handler\n         */         \n        this._saveChangesSuccessTT = function (jsdo, success, request) {\n            var changes;\n\n            // Ensure that that the _lastErrors variable has been cleared \n            jsdo._clearErrors();\n            changes = jsdo.getChanges();\n            jsdo._updateLastErrors(jsdo, null, changes);\n        };\n\n        this._saveChangesComplete = function (jsdo, success, request) {\n            // Success with errors\n            if ((request.xhr.status >= 200 && request.xhr.status < 300) && jsdo._lastErrors.length > 0) {\n                request.success = false;\n            }\n\n            // If saveChanges(true) was called, then we must fire create, update and delete triggers \n            // for each record that was sent to submit operation\n            if (jsdo._useSubmit === true) {\n                jsdo._fireCUDTriggersForSubmit(request);\n            }\n\n            jsdo._undefWorkingRecord();\n            jsdo._fireAfterSaveChanges(request.success, request);\n\n        };\n\n        this._fireAfterSaveChanges = function (success, request) {\n            this.trigger(\"afterSaveChanges\", this, success, request);\n            \n            if (request.jsrecords) {\n                if (request.deferred) {\n                    if (success) {\n                        request.deferred.resolve(this, success, request);\n                    }\n                    else {\n                        request.deferred.reject(this, success, request);                    \n                    }             \n                }\n            }\n            else if (request.batch && request.batch.deferred) {\n                if (success) {\n                    request.batch.deferred.resolve(this, success, request);\n                }\n                else {\n                    request.batch.deferred.reject(this, success, request);                    \n                }\n            }\n\n            // Clear error string when autoApplyChanges is true\n            var clearErrorString = this.autoApplyChanges;\n\n            // This will be set if submit operation was performed\n            if (request.jsrecords) {\n                for (var idx = 0; idx < request.jsrecords.length; idx++) {\n                    var jsrecord = request.jsrecords[idx];\n                    if (clearErrorString) {\n                        delete jsrecord.data._errorString;\n                    }\n                    delete jsrecord.data[\"prods:rowState\"];\n                }\n            }\n            else if (request.batch && request.batch.operations) {\n                for (var idx = 0; idx < request.batch.operations.length; idx++) {\n                    var jsrecord = request.batch.operations[idx].jsrecord;\n                    if (clearErrorString) {\n                        delete jsrecord.data._errorString;\n                    }\n                }\n            }\n        };\n\n        /*\n         * Returns errors in response associated with the HTTP request.records related to the specified jsrecord.\n         */        \n        this._getErrorsFromRequest = function(request) {\n            var errors = [], // Array of objects with properties: type, id, error, errorNum, responseText\n                errorArray = [],\n                errorObject,\n                retValString,\n                j,\n                i;\n\n            if (request && !request.success) {\n               if (request.xhr.status >= 400 && request.xhr.status < 600) {\n                    try {\n                        responseObject = JSON.parse(request.xhr.responseText);\n                        \n                        // responseText could be an array, an object or just text.\n                        // If it is an array, each object would have properties _errors and optional _retVal.\n                        // If it is not an array, the object would have properties _errors and optional _retVal.\n                        // If it is text, the content could also be an HTML page, this error is handle using \"HTTP Status\".\n                        if (responseObject instanceof Array) {\n                            errorArray = responseObject;\n                        } else if (responseObject instanceof Object) {\n                            errorArray.push(responseObject);\n                        }\n                        for (i = 0; i < errorArray.length; i += 1) {\n                            errorObject = errorArray[i];\n                            if (errorObject._retVal) {\n                                errors.push({\n                                    type: progress.data.JSDO.RETVAL,\n                                    error: errorObject._retVal\n                                });\n                                retValString =  errorObject._retVal;\n                            } else {\n                                retValString = null;\n                            }\n                            if (errorObject._errors instanceof Array) {\n                                for (j = 0; j < errorObject._errors.length; j += 1) {                                    \n                                    if ((errorObject._errors[j]._errorNum === 0) \n                                        && (errorObject._errors[j]._errorMsg === retValString)) {\n                                        // Suppress additional error msg if it is same as return value\n                                        continue;\n                                    }\n                                    errors.push({\n                                        type: progress.data.JSDO.APP_ERROR,\n                                        error: errorObject._errors[j]._errorMsg,\n                                        errorNum: errorObject._errors[j]._errorNum\n                                    });\n                                }\n                            }\n                        }\n                    }\n                    catch (e) {\n                        // Ignore exceptions\n                    }\n                }\n                if (request.exception) {\n                    errors.push({\n                        type: progress.data.JSDO.ERROR,\n                        error: request.exception\n                    });\n                }\n                if (errors.length === 0 \n                    && request.xhr \n                    && (request.xhr.status >= 400 && request.xhr.status < 600)) {\n                    errors.push({\n                        type: progress.data.JSDO.ERROR,\n                        error: \"Error: HTTP Status \" + request.xhr.status + \" \" + request.xhr.statusText,\n                        responseText: request.xhr.responseText\n                    });\n                }                \n            }\n            return errors;\n        };\n        \n        this._updateLastErrors = function (jsdo, batch, changes, request) {\n            var errors,\n                errorText,\n                responseObject,\n                i,\n                j,\n                buf;\n            \n            if (batch) {\n                if (batch.operations === undefined) return;\n                for (i = 0; i < batch.operations.length; i++) {\n                    request = batch.operations[i];\n                    if (!request.success && request.xhr) {\n                        if (request.xhr.status  >= 200 && request.xhr.status < 300) {\n                            // Add error string to jsdo._lastErrors\n                            jsdo._lastErrors.push({errorString: request.jsrecord.data._errorString});\n                            // Add error object to jsdo.<table-ref>._lastErrors\n                            jsdo._buffers[request.jsrecord._tableRef._name]._lastErrors.push({\n                                    type: progress.data.JSDO.DATA_ERROR,\n                                    id: request.jsrecord.data._id,\n                                    error: request.jsrecord.data._errorString});\n                        }                        \n                        else {\n                            errors = this._getErrorsFromRequest(request);\n                            errorText = \"\";\n                            for (j = 0; j < errors.length; j += 1) {\n                                if (errors.length > 1 && errors[j].error.indexOf(\"(7243)\") != -1) {\n                                    // If there are more error messages\n                                    //      supress error \"The Server application has returned an error. (7243)\"\n                                    continue;\n                                }\n                                // Add error to table reference\n                                if (request.jsrecord \n                                    && (errors[j].type === progress.data.JSDO.APP_ERROR\n                                       || errors[j].type === progress.data.JSDO.RETVAL)) {\n                                    errors[j].id = request.jsrecord.data._id;\n                                    request.jsrecord._tableRef._lastErrors.push(errors[j]);\n                                }\n                                if (errorText.length === 0) {\n                                    errorText = errors[j].error;\n                                }\n                                else {\n                                    errorText += \"\\n\" + errors[j].error;\n                                }\n                            }\n                            // Add error string to jsdo._lastErrors                            \n                            jsdo._lastErrors.push({errorString: errorText});                            \n                        }\n                    }\n                }\n            }\n            else if (changes instanceof Array) {\n                for (i = 0; i < changes.length; i++) {\n                    if (changes[i].record && changes[i].record.data._errorString !== undefined) {\n                        jsdo._lastErrors.push({errorString: changes[i].record.data._errorString});\n                        jsdo._buffers[changes[i].record._tableRef._name]._lastErrors.push({\n                                type: progress.data.JSDO.DATA_ERROR,                            \n                                id: changes[i].record.data._id,\n                                error: changes[i].record.data._errorString});\n                    }\n                }\n            }\n            else if (request \n                     && !request.success \n                     && request.xhr \n                     && (request.xhr.status >= 400 && request.xhr.status < 600)) {\n                errors = this._getErrorsFromRequest(request);\n                errorText = \"\";\n                for (j = 0; j < errors.length; j += 1) {\n                    if (errors.length > 1 && errors[j].error.indexOf(\"(7243)\") != -1) {\n                        // If there are more error messages\n                        //      supress error \"The Server application has returned an error. (7243)\"     \n                        continue;\n                    }\n                    // Add error to all table references\n                    for (buf in this._buffers) {\n                        this._buffers[buf]._lastErrors.push(errors[j]);\n                    }\n                    if (errorText.length === 0) {\n                        errorText = errors[j].error;\n                    }\n                    else {\n                        errorText += \"\\n\" + errors[j].error;\n                    }\n                }\n                jsdo._lastErrors.push({errorString: errorText});\n            }\n        };\n\n        // Check if all the xhr operations associated with the batch for which\n        // this xhr object is related have completed (not necessarily to success).\n        // If all XHR operations have completed this fires 'afterSaveChanges' event\n        this._checkSaveComplete = function (xhr) {\n            if (xhr.request) {\n                var jsdo = xhr.request.jsdo;\n                var batch = xhr.request.batch;\n                // OE00229270 Should only do afterSaveChanges if _async\n                if (jsdo && batch && jsdo._async) {\n                    if (jsdo._isBatchComplete(batch)) {\n                        var success = jsdo._isBatchSuccess(batch);\n                        var request = {\n                            batch: batch,\n                            success: success\n                        };\n                        jsdo._undefWorkingRecord();\n\n                        // Save error messages\n                        jsdo._lastErrors = [];\n                        if (!success && batch.operations) {\n                            jsdo._updateLastErrors(jsdo, batch, null);\n                        }\n                        jsdo._fireAfterSaveChanges(success, request);\n                    }\n                }\n            }\n        };\n\n\n        /*\n         * determine if a batch of XHR requests has completed in which all requests are successful\n         */\n        this._isBatchSuccess = function (batch) {\n            if (batch.operations) {\n                for (var i = 0; i < batch.operations.length; i++) {\n                    if (!batch.operations[i].success) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        };\n\n        /*\n         * determine if all XHR requests from the batch of saves have completed (not necessarily to success) \n         */\n        this._isBatchComplete = function (batch) {\n            if (batch.operations) {\n                for (var i = 0; i < batch.operations.length; i++) {\n                    var request = batch.operations[i];\n                    // we have to check against the 'complete' flag because xhr.readyState \n                    // might be set async by the browser\n                    // while we're still in the middle of processing some other requests's response\n                    if (!request.complete) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        };\n\n        this._mergeInvoke = function (jsonObject, xhr) {\n            var operation;\n            if (xhr.request.fnName !== undefined\n                && xhr.jsdo._resource.fn[xhr.request.fnName] !== undefined) {\n                operation = xhr.jsdo._resource.fn[xhr.request.fnName].operation;\n            }\n            else\n                operation = null;\n            if (operation === undefined) {\n                // Operation data is only required for invoke operations with mergeMode: true\n                operation = null;\n                for (var i = 0; i < xhr.jsdo._resource.operations.length; i++) {\n                    if (xhr.jsdo._resource.operations[i].name == xhr.request.fnName) {\n                        operation = xhr.jsdo._resource.operations[i];\n                        break;\n                    }\n                }\n                xhr.jsdo._resource.fn[xhr.request.fnName].operation = operation;\n            }\n            if (operation !== null && operation.mergeMode) {\n                try {\n                    var mergeMode = progress.data.JSDO[\"MODE_\" + operation.mergeMode.toUpperCase()];\n                    if (mergeMode === null) {\n                        throw new Error(msg.getMsgText(\"jsdoMSG030\", \"mergeMode property\", \n                            \"EMPTY, APPEND, MERGE or REPLACE\"));\n                    }\n                    if (xhr.jsdo._resource.idProperty === undefined) {\n                        throw new Error(msg.getMsgText(\"jsdoMSG110\", this._resource.name, \n                            \" by mergeMode property in invoke operation\"));\n                    }\n                    var dataParameterName;\n                    if (xhr.jsdo.isDataSet()) {\n                        dataParameterName = xhr.jsdo._resource._dataSetName;\n                    }\n                    else if (xhr.jsdo._resource.dataProperty !== undefined) {\n                        dataParameterName = xhr.jsdo._resource.dataProperty;\n                    }\n                    else if (xhr.jsdo._resource._tempTableName !== undefined) {\n                        dataParameterName = xhr.jsdo._resource._tempTableName;\n                    }\n                    else {\n                        throw new Error(msg.getMsgText(\"jsdoMSG111\", \"\"));\n                    }\n\n                    var found = false;\n                    for (var i = 0; i < operation.params.length; i++) {\n                        if (operation.params[i].name == dataParameterName) {\n                            if (operation.params[i].type.indexOf('RESPONSE_BODY') != -1) {\n                                if ((operation.params[i].xType !== undefined)\n                                    && (operation.params[i].xType != 'DATASET')\n                                    && (operation.params[i].xType != 'TABLE')\n                                    && (operation.params[i].xType != 'ARRAY')) {\n                                    throw new Error(msg.getMsgText(\"jsdoMSG113\", operation.params[i].xType, \n                                        dataParameterName, xhr.request.fnName));\n                                }\n                                found = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    if (!found) {\n                        throw new Error(msg.getMsgText(\"jsdoMSG112\", dataParameterName, xhr.request.fnName));\n                    }\n                    xhr.jsdo.addRecords(xhr.request.response[dataParameterName], \n                        mergeMode, [xhr.jsdo._resource.idProperty], false, true);\n                }\n                catch (e) {\n                    xhr.request.success = false;\n                    xhr.request.exception = e;\n                }\n            }\n        };\n\n        this.onReadyStateChangeGeneric = function () {\n            var xhr = this;\n            if (xhr.readyState == 4) {\n                var request = xhr.request;\n\n                /* try to parse response even if request is considered \"failed\" due to http status */\n                try {\n                    request.response = JSON.parse(xhr.responseText);\n                    // in some cases the object back from appserver has a \"response\" property which represents\n                    // the real content of the JSON...happens when multiple output parameters are returned.\n                    // this of course assumes no one names their root object \"response\".\n                    if (request.response && request.response.response) {\n                        request.response = request.response.response;\n                    }\n                } catch (e) {\n                    request.response = undefined;\n                }\n\n                try {\n                    if ((xhr.status >= 200 && xhr.status < 300) \n                        || (xhr.status === 0 && xhr.responseText !== \"\")) {\n                            \n                        request.success = true;\n                        // get the Client Context ID (AppServer ID)\n                        xhr.jsdo._session._saveClientContextId(xhr); \n                        if ((typeof xhr.onSuccessFn) == 'function') {\n                            var operation;\n                            if (xhr.request.fnName !== undefined\n                                && xhr.jsdo._resource.fn[xhr.request.fnName] !== undefined) {\n                                operation = xhr.jsdo._resource.fn[xhr.request.fnName].operation;\n                            }\n                            else\n                                operation = null;\n                            if ((operation === undefined) || (operation !== null && operation.mergeMode))\n                                xhr.jsdo._mergeInvoke(request.response, xhr);\n                            if (request.success)\n                                xhr.onSuccessFn(xhr.jsdo, request.success, request);\n                            else if ((typeof xhr.onErrorFn) == 'function')\n                                xhr.onErrorFn(xhr.jsdo, request.success, request);\n                        }\n\n                    } else {\n                        request.success = false;\n                        if (xhr.status === 0) {\n                            request.exception = new Error(msg.getMsgText(\"jsdoMSG101\"));\n                        }\n                        if ((typeof xhr.onErrorFn) == 'function') {\n                            xhr.onErrorFn(xhr.jsdo, request.success, request);\n                        }\n                    }\n                } catch (e) {\n                    request.exception = e;\n                    if ((typeof xhr.onErrorFn) == 'function') {\n                        xhr.onErrorFn(xhr.jsdo, request.success, request);\n                    }\n                }\n                // get the Client Context ID (AppServer ID)\n                xhr.jsdo._session._checkServiceResponse(xhr, request.success, request);\n\n                if ((typeof xhr.onCompleteFn) == 'function') {\n                    xhr.onCompleteFn(xhr.jsdo, request.success, request);\n                }\n\n            }\n        };\n\n        /*\n         * Accepts changes for all table references in the JSDO.\n         */\n        this.acceptChanges = function () {\n            for (var buf in this._buffers) {\n                this._buffers[this._buffers[buf]._name].acceptChanges();\n            }\n        };\n\n        /*\n         * Rejects changes for the table references in the JSDO.\n         */\n        this.rejectChanges = function () {\n            for (var buf in this._buffers) {\n                this._buffers[this._buffers[buf]._name].rejectChanges();\n            }\n        };\n\n        /*\n         * Returns an array with changes for all table references in the JSDO.\n         */\n        this.getChanges = function () {\n            var result = [];\n            for (var buf in this._buffers) {\n                var changes = this._buffers[this._buffers[buf]._name].getChanges();\n                result = result.concat(changes);\n            }\n            return result;\n        };\n\n        this.hasChanges = function () {\n            for (var buf in this._buffers) {\n                if (this._buffers[this._buffers[buf]._name].hasChanges())\n                    return true;\n            }\n            return false;\n        };\n\n        /*\n         * Private method to apply changes for all table references in the JSDO.\n         * If _errorString has been set for a row, rejectRowChanges() is called. \n         * If it has not been set, acceptRowChanges() is called.\n         */\n        this._applyChanges = function () {\n            for (var buf in this._buffers) {\n                this._buffers[this._buffers[buf]._name]._applyChanges();\n            }\n        };\n\n        /*\n         * Accepts row changes for the working record using the JSDO reference.\n         */\n        this.acceptRowChanges = function () {\n            if (this._defaultTableRef)\n                return this._defaultTableRef.acceptRowChanges();\n            throw new Error(msg.getMsgText(\"jsdoMSG001\", \"acceptRowChanges()\"));\n        };\n\n        /*\n         * Reject row changes for the working record using the JSDO reference.\n         */\n        this.rejectRowChanges = function () {\n            if (this._defaultTableRef)\n                return this._defaultTableRef.rejectRowChanges();\n            throw new Error(msg.getMsgText(\"jsdoMSG001\", \"rejectRowChanges()\"));\n        };\n        \n        /*\n         * Sets complete set of properties for the jsdo. All existing properties are replaced with new set\n         */\n        this.setProperties = function( propertiesObject ) {\n           var prop;\n\n            if (arguments.length < 1) {\n                // {1}: Incorrect number of arguments in {2} call. There should be {3}.\n                throw new Error(progress.data._getMsgText(\"jsdoMSG122\", 'JSDO', 'setProperties', 1)); \n            }\n            if (arguments.length > 1) {\n                // {1}: Incorrect number of arguments in {2} call. There should be only {3}.\";\n                throw new Error(progress.data._getMsgText(\"jsdoMSG122\", 'JSDO', 'setProperties', 1)); \n            }\n            if ( typeof propertiesObject == \"object\" ) {\n                /* Copy properties of the propertiesObject argument into _properties.\n                 * Note that if object passed in has a prototype, this code copies them too)\n                 */\n                this._properties = {};\n                \n                for (prop in propertiesObject) {\n                    if( propertiesObject.hasOwnProperty(prop) )  {\n                        if (typeof propertiesObject[prop] !== \"function\" ) {\n                            this._properties[prop] = propertiesObject[prop];\n                        }\n                    }\n                }\n            }\n            else if ( (propertiesObject === undefined) || (propertiesObject === null) ) {\n                this._properties = {};\n            }\n            else {\n                // {1}: Parameter {1} must be of type {3} in {4} call.\n                throw new Error(progress.data._getMsgText(\"jsdoMSG121\", 'JSDO', 1, 'Object',\n                                                          'setProperties')); \n            }\n        };\n\n        /* \n         *  Set or remove an individual property in the property set maintained by the jsdo. \n         *  This operates only on the property identified by propertyName; \n         *  all other existing properties remain as they are.\n         *  If the propertyName is not part of the context, this call adds it.\n         *  If it exists, it is updated, unless -\n         *  If propertyValue is undefined, this call removes the property\n         */\n        this.setProperty = function( propertyName, propertyValue) {\n            if (arguments.length < 2) {\n                // {1}: Incorrect number of arguments in {2} call. There should be {3}.\n                throw new Error(progress.data._getMsgText(\"jsdoMSG122\", 'JSDO', \n                                                           'setProperty', 2)); \n            }\n            if (arguments.length !== 2) {\n                // {1}: Incorrect number of arguments in {2} call. There should be only {3}.\";\n                throw new Error(progress.data._getMsgText(\"jsdoMSG122\", \"JSDO\",\n                                                          \"setProperty\", 2)); \n            }\n            if (typeof propertyName !== \"string\") {\n                // {1}: Parameter {1} must be of type {3} in {4} call.\n                throw new Error(progress.data._getMsgText(\"jsdoMSG121\", 'JSDO', 1, 'string',\n                                                          'setProperty')); \n            }\n\n            if ( propertyValue === undefined ) {\n                delete this._properties[propertyName]; // OK if it doesn't exist -- no error\n            }\n            else {\n                this._properties[propertyName] = propertyValue;\n            }\n        };\n         \n        /* \n         * Gets the set of jsdo properties. Returns an object containing all the properties\n         */\n        this.getProperties = function( ) {\n            if (arguments.length > 0) {\n                // {1}: Incorrect number of arguments in {2} call. There should be {3}.\";\n                throw new Error(progress.data._getMsgText(\"jsdoMSG122\", 'JSDO', 'getProperties', 0)); \n            }\n            return this._properties;\n        };\n        \n        /*  Gets the value of an individual property in the jsdo property set\n         */\n        this.getProperty = function( propertyName) {\n            if (arguments.length < 1) {\n                // {1}: Incorrect number of arguments in {2} call. There should be {3}.\n                throw new Error(progress.data._getMsgText(\"jsdoMSG122\", 'JSDO', 'getProperty', 1)); \n            }\n            if (arguments.length > 1) {\n                // {1}: Incorrect number of arguments in {2} call. There should be only {3}.\";\n                throw new Error(progress.data._getMsgText(\"jsdoMSG122\", 'JSDO', 'getProperty', 1)); \n            }\n            return this._properties[propertyName];\n            \n        };\n\n        ///////////////////////////////////////////////////////////////////////////\n        //\n        //  The following methods provide support for Object Pesistence\n\n        /*\n         * Saves JSDO memory (and optionally pending changes) to local storage.\n         *\n         * saveLocal()\n         * saveLocal(name)\n         * saveLocal(dataMode)\n         * saveLocal(name, dataMode)\n         *\n         */\n        this.saveLocal = function saveLocal(arg1, arg2) {\n            var name;\n            var dataMode;\n\n            if (arguments.length > 2) {\n                throw new Error(msg.getMsgText(\"jsdoMSG024\", \"JSDO\", arguments.callee.name + \"()\"));\n            }\n\n            if (typeof(arg1) == 'string' || arg1 === null || arg1 === undefined) {\n                name = arg1;\n                dataMode = arg2;\n            }\n            else {\n                name = null;\n                dataMode = arg1;\n            }\n\n            if (name === undefined || name === null || name === \"\") {\n                name = \"jsdo_\" + this._resource.service.name + \"_\" + this._resource.name;\n            }\n            if (typeof(dataMode) == 'undefined') {\n                dataMode = progress.data.JSDO.ALL_DATA;\n            }\n            else {\n                switch (dataMode) {\n                    case progress.data.JSDO.ALL_DATA:\n                    case progress.data.JSDO.CHANGES_ONLY:\n                        break;\n                    default:\n                        throw new Error(msg.getMsgText(\"jsdoMSG115\", arguments.callee.name));\n                }\n            }\n\n            if (this._localStorage === null) {\n                // Must first instantiate _localStorage object\n                this._localStorage = new progress.data.LocalStorage();\n            }\n\n            var dataObj = this._prepareDataObjectForLocalStorage(dataMode);\n            this._localStorage.saveToLocalStorage(name, dataObj);\n        };\n\n        /*\n         * Reads localStorage (based upon name) into JSDO memory \n         * (localStorage may or may not have pending changes).\n         * readLocal()\n         * readLocal(name)\n         *\n         */\n        this.readLocal = function readLocal(name) {\n            if (arguments.length > 1) {\n                throw new Error(msg.getMsgText(\"jsdoMSG024\", \"JSDO\", arguments.callee.name + \"()\"));\n            }\n            if (name === undefined || name === null || name === \"\") {\n                name = \"jsdo_\" + this._resource.service.name + \"_\" + this._resource.name;\n            }\n            else if (typeof(name) != 'string') {\n                throw new Error(msg.getMsgText(\"jsdoMSG116\", \"name\", arguments.callee.name + \"()\"));\n            }\n\n            if (this._localStorage === null) {\n                this._localStorage = new progress.data.LocalStorage();\n            }\n\n            var object = this._localStorage.readFromLocalStorage(name);\n\n            // If storage area does not exist (i.e. object = null) then don't update JSDO local memory\n            if (object) {\n                if (this._hasMatchingSchema(object) === false)\n                    throw new Error(msg.getMsgText(\"jsdoMSG117\", name));\n\n                // For readLocal(), JSDO should first be emptied of data, so using MODE_EMPTY\n                this._restoreFromLocalStorage(object, progress.data.JSDO.MODE_EMPTY);\n            }\n\n            return object !== null;\n        };\n\n        /*\n         * Reads localStorage (based upon name) into JSDO memory \n         * (localStorage may or may not have pending changes).\n         * addLocalRecords(addMode)\n         * addLocalRecords(addMode, keyFields)\n         * addLocalRecords(name, addMode)\n         * addLocalRecords(name, addMode, keyFields)\t\n         */\n        this.addLocalRecords = function addLocalRecords(arg1, arg2, arg3) {\n            var name;\n            var addMode;\n            var keyFields;\n\n            if (arguments.length < 1) {\n                throw new Error(msg.getMsgText(\"jsdoMSG024\", \"JSDO\", arguments.callee.name + \"()\"));\n            }\n\n            if (typeof(arg1) == 'string') {\n                name = arg1;\n                addMode = arg2;\n                keyFields = arg3;\n            }\n            else {\n                name = \"jsdo_\" + this._resource.service.name + \"_\" + this._resource.name;\n                addMode = arg1;\n                keyFields = arg2;\n            }\n\n            if (typeof(name) == 'undefined' || name === null || name === \"\") {\n                name = \"jsdo_\" + this._resource.service.name + \"_\" + this._resource.name;\n            }\n            else if (typeof(name) != 'string') {\n                throw new Error(msg.getMsgText(\"jsdoMSG116\", \"name\", arguments.callee.name + \"()\"));\n            }\n\n            if (addMode != progress.data.JSDO.MODE_REPLACE) {\n                throw new Error(msg.getMsgText(\"jsdoMSG115\", arguments.callee.name));\n            }\n\n            if (this._localStorage === null) {\n                this._localStorage = new progress.data.LocalStorage();\n            }\n\n            var object = this._localStorage.readFromLocalStorage(name);\n\n            // If storage area does not exist (i.e. object = null) then don't update JSDO local memory\n            if (object) {\n                if (this._hasMatchingSchema(object) === false)\n                    throw new Error(msg.getMsgText(\"jsdoMSG117\", name));\n\n                try {\n                    this._restoreFromLocalStorage(object, addMode, keyFields);\n                }\n                catch (e) {\n                    var text = e.message;\n                    throw new Error(text.replace(new RegExp('addRecords', 'g'), 'addLocalRecords'));\n                }\n            }\n\n            return object !== null;\n        };\n\n\n        /*\n         * This method returns True if each buffer in the jsdo contains a primary key.\n         */\n        this._containsPrimaryKeys = function _containsPrimaryKeys() {\n\n            for (var buf in this._buffers) {\n                if (this._buffers[buf]._primaryKeys === null)\n                    return false;\n            }\n\n            return true;\n        };\n\n        /*\n         * Compares JSDO's dataset/table names with those in specified storage object.\n         * Returns true if they match (or if storageObject is null or empty), else false.\n         */\n        this._hasMatchingSchema = function _hasMatchingSchema(storageObject) {\n            var isValid = true;\n\n            if (storageObject === null || (Object.keys(storageObject).length === 0))\n                return true;\n\n\n            if (this._dataSetName) {\n                if (storageObject[this._dataSetName]) {\n                    for (var buf in this._buffers)\n                        if (storageObject[this._dataSetName][buf] === undefined) {\n                            isValid = false;\n                            break;\n                        }\n                }\n                else\n                    isValid = false; // dataset should be in storage area\n            }\n            else if (this._dataProperty) {\n                // If array, we had to wrap in \"fake\" dataset, so unwrap it\n                storageObject = storageObject[\"_localStorage\"];\n                if (storageObject === undefined || storageObject[this._dataProperty] === undefined)\n                    isValid = false;\n            }\n            else {\n                // If temp-table, we had to wrap in \"fake\" dataset, so unwrap it\n                storageObject = storageObject[\"_localStorage\"];\n                if (storageObject === undefined || storageObject[this._defaultTableRef._name] === undefined)\n                    isValid = false;\n            }\n\n            return isValid;\n        };\n\n\n        /*\n         * Clears the data saved to local storage.\n         *\n         * deleteLocal()\n         * deleteLocal(name)\n         */\n        this.deleteLocal = function deleteLocal(name) {\n            if (arguments.length > 1) {\n                throw new Error(msg.getMsgText(\"jsdoMSG024\", \"JSDO\", arguments.callee.name + \"()\"));\n            }\n            if (name === undefined || name === null || name === \"\") {\n                name = \"jsdo_\" + this._resource.service.name + \"_\" + this._resource.name;\n            }\n            else if (typeof(name) != 'string') {\n                throw new Error(msg.getMsgText(\"jsdoMSG116\", \"name\", arguments.callee.name + \"()\"));\n            }\n\n            if (this._localStorage === null) {\n                this._localStorage = new progress.data.LocalStorage();\n            }\n            this._localStorage.clearLocalStorage(name);\n        };\n\n\n        // This method is used by saveLocal() to return a jsonObject with current JSDO data based upon option.\n        //\n        // In order to take advantage of existing code (createChangeSet() and addRecords()) and particularly\n        // to use the processing of before-data in addRecords(), for tables and arrays, we create a dummy\n        // dataset name: _localStorage.\n        this._prepareDataObjectForLocalStorage = function (option) {\n\n            var storageObject = {};\n\n            // DataSets\n            if (this._dataSetName) {\n                switch (option) {\n                    case progress.data.JSDO.ALL_DATA:\n                        storageObject = this._createDataAndChangeSet(this._dataSetName);\n                        break;\n\n                    case progress.data.JSDO.CHANGES_ONLY:\n                        storageObject = this._createChangeSet(this._dataSetName, true);\n                        break;\n                }\n            }\n            // Arrays\n            else if (this._dataProperty) {\n                switch (option) {\n                    case progress.data.JSDO.ALL_DATA:\n                        storageObject = this._createDataAndChangeSet(\"_localStorage\");\n                        break;\n\n                    case progress.data.JSDO.CHANGES_ONLY:\n                        storageObject = this._createChangeSet(\"_localStorage\", true);\n                        break;\n                }\n            }\n            // Temp Tables\n            else {\n                switch (option) {\n                    case progress.data.JSDO.ALL_DATA:\n                        storageObject = this._createDataAndChangeSet(\"_localStorage\");\n                        break;\n\n                    case progress.data.JSDO.CHANGES_ONLY:\n                        storageObject = this._createChangeSet(\"_localStorage\", true);\n                        break;\n                }\n            }\n\n            return storageObject;\n        };\n\n\n        // Restore the data retrieved from local storage to the JSDO based upon the specified addMode\n        this._restoreFromLocalStorage = function (storageObject, addMode, keyFields) {\n\n            if (storageObject && (Object.keys(storageObject).length > 0)) {\n                if (this._dataSetName) {\n                    // Walk thru all tables to retrieve data\n                    for (var buf in this._buffers)\n                        this._restoreDataForTable(this._buffers[buf], storageObject, addMode, keyFields);\n                }\n                // Either temp-table or array\n                else\n                    this._restoreDataForTable(this._defaultTableRef, storageObject, addMode, keyFields);\n            }\n            else if (addMode === progress.data.JSDO.MODE_EMPTY)\n                this._clearData();\n        };\n\n\n        this._restoreDataForTable = function (tableRef, jsonObject, addMode, keyFields) {\n\n            // If primaryKeys not found, check if the idProperty is there\n            keyFields = keyFields !== undefined ? keyFields : tableRef._primaryKeys;\n            if (keyFields === undefined && this._resource.idProperty) {\n                keyFields = [];\n                keyFields[0] = this._resource.idProperty;\n            }\n\n            if (this._dataSetName) {\n                var oldUseRelationships = this.useRelationships;\n                // Turn off useRelationships since addRecords() does not use the working record\t\t\t\n                this.useRelationships = false;\n\n                try {\n                    tableRef.addRecords(jsonObject, addMode, keyFields);\n                } finally {\n                    // Restore useRelationships\n                    this.useRelationships = oldUseRelationships;\n                }\n            }\n            // else it's either an array (this._dataProperty) or a temp-table\n            else {\n                // Creating  dummy dataset name: \"_localStorage\" for tables and arrays\n                this._dataSetName = \"_localStorage\";\n                tableRef.addRecords(jsonObject, addMode, keyFields);\n                this._dataSetName = null;\n            }\n        };\n\n\t\tthis.getMethodProperties = function(operation, name) {\n\t\t\tvar idx;\n\t\t\t\n            if (this._resource._operations) {\n                if (this._resource._operations[operation]) {\n                    return this._resource._operations[operation];\n                }\n            }\t\n            else {\n                this._resource._operations = {};\n            }\n            for (var idx = 0; idx < this._resource.operations.length; idx++) {\n                if (this._resource.operations[idx].type == operation) {\n                    return (this._resource._operations[operation] = this._resource.operations[idx]);\n                }\n            }\n\t\t};\n\t\t\n        ///////////////////////////////////////////////////////////////////////////\n\n        // Load data\n        if (autoFill)\n            this.fill();\n\n    }; // End of JSDO\n\n    // Constants for progress.data.JSDO\n    if ((typeof Object.defineProperty) == 'function') {\n        Object.defineProperty(progress.data.JSDO, 'MODE_APPEND', {\n            value: 1,\n            enumerable: true\n        });\n        Object.defineProperty(progress.data.JSDO, 'MODE_EMPTY', {\n            value: 2,\n            enumerable: true\n        });\n        Object.defineProperty(progress.data.JSDO, 'MODE_MERGE', {\n            value: 3,\n            enumerable: true\n        });\n        Object.defineProperty(progress.data.JSDO, 'MODE_REPLACE', {\n            value: 4,\n            enumerable: true\n        });\n        Object.defineProperty(progress.data.JSDO, 'ERROR', {\n            value: -1,\n            enumerable: true\n        });\n        Object.defineProperty(progress.data.JSDO, 'APP_ERROR', {\n            value: -2,\n            enumerable: true\n        });\n        Object.defineProperty(progress.data.JSDO, 'RETVAL', {\n            value: -3,\n            enumerable: true\n        });\n        Object.defineProperty(progress.data.JSDO, 'DATA_ERROR', {\n            value: -4,\n            enumerable: true\n        });        \n    } else {\n        progress.data.JSDO.MODE_APPEND = 1;\n        progress.data.JSDO.MODE_EMPTY = 2;\n        progress.data.JSDO.MODE_MERGE = 3;\n        progress.data.JSDO.MODE_REPLACE = 4;\n    }\n\n    /* CRUD */\n    progress.data.JSDO._OP_CREATE = 1;\n    progress.data.JSDO._OP_READ = 2;\n    progress.data.JSDO._OP_UPDATE = 3;\n    progress.data.JSDO._OP_DELETE = 4;\n    progress.data.JSDO._OP_SUBMIT = 5;\n\n    /* Offline support: saving data to local storage  */\n    progress.data.JSDO.ALL_DATA = 1;\n    progress.data.JSDO.CHANGES_ONLY = 2;\n    \n    // Arrays elements as individual fields \n    // Separator must have at least one characters\n    progress.data.JSDO.ARRAY_INDEX_SEPARATOR = \"_\";\n\n// setup inheritance for JSDO\n    progress.data.JSDO.prototype = new progress.util.Observable();\n    progress.data.JSDO.prototype.constructor = progress.data.JSDO;\n    progress.data.JSDO.prototype.toString = function (radix) {\n        return \"JSDO\";\n    };\n\n// setup inheritance for table reference\n    progress.data.JSTableRef.prototype = new progress.util.Observable();\n    progress.data.JSTableRef.prototype.constructor = progress.data.JSTableRef;\n    progress.data.JSTableRef.prototype.toString = function (radix) {\n        return \"JSTableRef\";\n    };\n\n\t// Built-in Plugins\n\tprogress.data.PluginManager.addPlugin(\"JFP\", {\n\t\trequestMapping: function(jsdo, params, info) {\n\t\t\tvar sortFields,\n\t\t\tfield,\n            fieldName,            \n            fieldInfo,\n            tableName,\n            filter,\n            sortDir,\n\t\t\tablFilter,\n            sqlQuery,\n            methodProperties,\n            capabilities,\n            index,\n            position,\n            option,\n            capabilitiesObject,\n            reqCapabilities = {\n                filter: { options: [ \"ablFilter\", \"sqlQuery\" ], mapping: undefined },\n                top:    { options: [ \"top\" ], mapping: undefined },\n                skip:   { options: [ \"skip\" ], mapping: undefined },\n                id:     { options: [ \"id\" ], mapping: undefined },\n                sort:   { options: [ \"orderBy\" ], mapping: undefined }\n            },\n            doConversion = true,\n            param;\n\t\t\t\n\t\t\tif (info.operation === \"read\") {\n                capabilitiesObject = {};\n                methodProperties = jsdo.getMethodProperties(info.operation);\n                capabilities = methodProperties.capabilities;\n                \n                if (capabilities) {\n                    capabilities = capabilities.replace(/\\s/g, \"\").split(\",\");\n                    for (index = 0; index < capabilities.length; index += 1) {\n                        capabilitiesObject[capabilities[index]] = true;\n                    }\n                }\n                for (param in params) {\n                    if (param && (params[param] !== undefined) && reqCapabilities[param]) {\n                        for (index = 0; index < reqCapabilities[param].options.length; index += 1) {\n                            option = reqCapabilities[param].options[index];\n                            if (capabilitiesObject[option]) {\n                                reqCapabilities[param].mapping = option;\n                                break;\n                            }\n                        }\n                        if (!reqCapabilities[param].mapping) {\n                            throw new Error(msg.getMsgText(\"jsdoMSG120\", \n                                reqCapabilities[param].options.join(\"' or '\"), param));\n                        }\n                    }\n                }\n                \n                if (jsdo._defaultTableRef && params.tableRef === undefined) {\n                    tableName = jsdo._defaultTableRef._name;\n                }\n                else {\n                    tableName = params.tableRef;\n                }\n\n\t\t\t\tif (params.sort) {\n                    // Convert sort expression to JFP format\t\t\t\t\n\t\t\t\t\t\n                    if (typeof(params.sort) === \"object\" && !(params.sort instanceof Array)) {\n                        // Kendo UI sort format - object\n                        // Make params.sort an array\n                        params.sort = [params.sort];\n                    }\n\t\t\t\t\tsortFields = \"\";\n\t\t\t\t\tfor (index = 0; index < params.sort.length; index += 1) {\n                        field = params.sort[index];\n                        sortDir = \"\";\n\t\t\t\t\t\t\n                        if (typeof(field) === \"string\") {\n                            // setSortFields format\n                            // Extract fieldName and sortDir from string\n                            fieldName = field;\n                            position = field.indexOf(\":\");\n                            if (position !== -1) {\n                                sortDir = fieldName.substring(position + 1);\n                                fieldName = fieldName.substring(0, position);\n                                switch(sortDir.toLowerCase()) {\n                                case \"desc\":\n                                case \"descending\":                                \n                                    sortDir = \"desc\";\n                                    break;\n                                }\n                            }\n                        } else {\n                            // Kendo UI sort format - array\n                            // Extract fieldName and sortDir from object\n                            fieldName = field.field;\n                            if (params.sort[index].dir === \"desc\") {\n                                sortDir = params.sort[index].dir;                                \n                            }\n                        }\n                        if (tableName) {\n                            // Use original fieldName instead of serialized name\n                            fieldInfo = jsdo[tableName]._fields[fieldName.toLowerCase()];\n                            if (fieldInfo && fieldInfo.origName) {\n\t\t\t\t\t\t\t\tfieldName = fieldInfo.origName;\n                            }\n                        }\n                        if (sortDir === \"desc\") {\n                            fieldName += \" DESC\";\n                        }\n                        sortFields += fieldName;\n                        if (index < params.sort.length - 1) {\n                            sortFields += \",\";\n                        }                     \n\t\t\t\t\t}                                                                             \n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (params.filter) {\n                    // If filter is specified as string, then no conversion is necessary\n                    if (typeof params.filter === 'string') {\n                        doConversion = false;\n                    }\n                    \n                    params.tableRef = tableName;\n                    \n                    if (doConversion && (params.tableRef === undefined)) {\n                        throw new Error(msg.getMsgText(\"jsdoMSG045\", \"fill() or read()\", \"params\", \n                                                       \"tableRef\"));\n\t\t\t\t\t}  \n                       \n                    if (reqCapabilities[\"filter\"].mapping === \"ablFilter\") {\n                        if (doConversion) {\n                            ablFilter = progress.util._convertToABLWhereString(\n                                        jsdo._buffers[params.tableRef], params.filter);\n                        }\n                        else {\n                            ablFilter = params.filter;\n                        }\n                    }\n                    else if (reqCapabilities[\"filter\"].mapping === \"sqlQuery\") {\n                        if (doConversion) {\n                            sqlQuery = progress.util._convertToSQLQueryString(\n                                        jsdo._buffers[params.tableRef], params.filter, true);\n                        }\n                        else {\n                            sqlQuery = params.filter;\n                        }\n                    }\n\t\t\t\t}\n                \n\t\t\t\tfilter = JSON.stringify({\n\t\t\t\t\tablFilter: ablFilter,\n                    sqlQuery: sqlQuery,\n\t\t\t\t\torderBy: sortFields,\n\t\t\t\t\tskip: params.skip,\n\t\t\t\t\ttop: params.top\n\t\t\t\t\t});\t\t\t\t\n\t\t\t\t\n\t\t\t\tparams = {filter: filter};\n\t\t\t}\n\t\t\treturn params;\n\t\t}\n\t});\n\t\n    if (typeof progress.ui == 'undefined')\n        progress.ui = {};\n    progress.ui.UITableRef = function UITableRef(tableRef) {\n        this._tableRef = tableRef;\n        this._listview = null;\n        this._detailPage = null;\n        this._listviewContent = undefined;\n\n        this.addItem = function (format) {\n            var detailForm;\n\n            if (!this._tableRef.record)\n                throw new Error(msg.getMsgText(\"jsdoMSG002\", this._name));\n\n            if (!this._listview) return;\n\n            format = format ? format : this._listview.format;\n            detailForm = (this._detailPage && this._detailPage.name) ? this._detailPage.name : \"\";\n\n            if (this._listviewContent === undefined) {\n                this.clearItems();\n            }\n            var text = this._listview.itemTemplate ? \n                this._listview.itemTemplate : progress.ui.UIHelper._itemTemplate;\n\n            text = text.replace(new RegExp('{__format__}', 'g'), format);\n            text = text.replace(new RegExp('{__id__}', 'g'), this._tableRef.record.data._id);\n            text = text.replace(new RegExp('{__page__}', 'g'), detailForm);\n\n            for (var field in this._tableRef.record.data) {\n                var value = this._tableRef.record.data[field];\n                text = text.replace(new RegExp('{' + field + '}', 'g'), \n                                            (value !== undefined && value !== null) ? value : \"\");\n            }\n\n            this._listviewContent += text;\n        };\n\n        this.clearItems = function () {\n            if (this._listview) {\n                this._listviewContent = '';\n                var listviewElement = document.getElementById(this._listview.name);\n                if (listviewElement) {\n                    listviewElement.innerHTML = '';\n                }\n            }\n        };\n\n        this._getFormFieldValue = function (fieldName, detailPageName) {\n            var value = null;\n\n            if (detailPageName === undefined) {\n                if (this._detailPage && this._detailPage.name)\n                    detailPageName = this._detailPage.name;\n            }\n\n            if (typeof($) == 'function' && detailPageName) {\n                field = $(\"#\" + detailPageName + \" #\" + fieldName);\n                if (!field || field.length === 0)\n                    field = $(\"#\" + detailPageName + ' [dsid=\"' + fieldName + '\"]');\n                if (field && field.length == 1)\n                    value = field.val();\n            }\n            else {\n                field = document.getElementById(fieldName);\n                if (field) {\n                    value = field.value;\n                }\n            }\n\n            return value;\n        };\n\n        this._setFormField = function (fieldName, value, detailPageName) {\n            var field = null;\n\n            if (detailPageName === undefined) {\n                if (this._detailPage && this._detailPage.name)\n                    detailPageName = this._detailPage.name;\n            }\n\n            if (typeof($) == 'function' && detailPageName) {\n                field = $(\"#\" + detailPageName + \" #\" + fieldName);\n                if (!field || field.length === 0)\n                    field = $(\"#\" + detailPageName + ' [dsid=\"' + fieldName + '\"]');\n                if (field && field.length == 1)\n                    field.val(value);\n            }\n            else {\n                field = document.getElementById(fieldName);\n                if (field) {\n                    field.value = value;\n                }\n            }\n        };\n\n        /*\n         * Assigns field values from the form.\n         */\n        this.assign = function (detailPageName) {\n            if (!this._tableRef.record)\n                throw new Error(msg.getMsgText(\"jsdoMSG002\", this._tableRef._name));\n            if ((arguments.length !== 0) && (typeof detailPageName != 'string'))\n                throw new Error(msg.getMsgText(\"jsdoMSG024\", \"UIHelper\", \"assign()\"));\n\n            // Ensure creation of before image record\n            this._tableRef.record.assign(null);\n\n            var fieldName;\n            var schema = this._tableRef.getSchema();\n            for (var i = 0; i < schema.length; i++) {\n                fieldName = schema[i].name;\n                if (fieldName == '_id') continue;\n                var value = this._getFormFieldValue(fieldName, detailPageName);\n                // CR OE00241289 Should always copy over field value unless undefined, \n                // user may have explicitly set it to blank\n                if (typeof value != 'undefined') {\n                    if (typeof value == 'string' && schema[i].type != 'string') {\n                        value = this._tableRef._jsdo._convertType(value,\n                            schema[i].type,\n                            schema[i].items ? schema[i].items.type : null);\n                    }\n                    this._tableRef.record.data[fieldName] = value;\n                }\n            }\n\n            // Ensure order of record\n            this._tableRef.record._sortRecord();\n\n            return true;\n        };\n\n        this.display = function (pageName) {\n            if (!this._tableRef.record)\n                throw new Error(msg.getMsgText(\"jsdoMSG002\", this._tableRef._name));\n\n            // Display record to form\n            var schema = this._tableRef.getSchema();\n            for (var i = 0; i < schema.length; i++) {\n                this._setFormField(schema[i].name, this._tableRef.record.data[schema[i].name], pageName);\n            }\n            this._setFormField('_id', this._tableRef.record.data._id, pageName);\n        };\n\n        this.showListView = function () {\n            if (!this._listview) return;\n\n            var uiTableRef = this;\n            var listviewElement;\n            if (typeof($) == 'function') {\n                listviewElement = $(\"#\" + this._listview.name);\n                if (listviewElement && listviewElement.length == 1) {\n                    listviewElement.html(this._listviewContent ? this._listviewContent : '');\n                    try {\n                        if (listviewElement.attr(\"data-filter\") === \"true\"\n                            && typeof listviewElement.filterable === \"function\") {\n                            listviewElement.filterable(\"refresh\");\n                        }\n                        else {\n                            listviewElement.listview(\"refresh\");\n                        }\n                    }\n                    catch (e) {\n                        // Workaround for issue with JQuery Mobile throwning exception on refresh\n                    }\n                }\n\n                if (this._listview.autoLink) {\n                    // Add trigger for 'tap' event to items\n                    $(\"#\" + this._listview.name + \" li\").each(\n                        function (/* index */) {\n                            $(this).bind('click',\n                                function (/* event, ui */) {\n                                    var jsrecord = uiTableRef.getListViewRecord(this);\n                                    uiTableRef.display();\n                                    if (typeof(uiTableRef._listview.onSelect) == 'function') {\n                                        uiTableRef._listview.onSelect(event, this, jsrecord);\n                                    }\n                                });\n                        });\n                }\n            }\n            else {\n                listviewElement = document.getElementById(this._listview.name);\n                if (listviewElement) {\n                    listviewElement.innerHTML = this._listviewContent;\n                }\n\n                if (this._listview.autoLink) {\n                    var element = document.getElementById(this._listview.name);\n                    if (element && element.childElementCount > 0) {\n                        for (var i = 0; i < element.children.length; i++) {\n                            element.children[i].onclick = function () {\n                                var jsrecord = uihelper.getListViewRecord(this);\n                                uihelper.display();\n                                if (typeof(uiTableRef._listview.onSelect) == 'function') {\n                                    uiTableRef._listview.onSelect(event, this, jsrecord);\n                                }\n                            };\n                        }\n                    }\n                }\n            }\n\n            this._listviewContent = undefined;\n        };\n\n        this.getFormFields = function (fields) {\n            if (!this._tableRef._schema)\n                return '';\n            if (!(fields instanceof Array))\n                fields = null;\n            else {\n                var tmpFields = {};\n                for (var i = 0; i < fields.length; i++) {\n                    tmpFields[fields[i]] = fields[i];\n                }\n                fields = tmpFields;\n            }\n            var htmltext;\n            if (!fields || fields['_id']) {\n                htmltext = '<input type=\"hidden\" id=\"_id\" name=\"_id\" value=\"\" />';\n            }\n            else\n                htmltext = '';\n            htmltext += '<fieldset data-role=\"controlgroup\">';\n\n            for (var i = 0; i < this._tableRef._schema.length; i++) {\n                var fieldName = this._tableRef._schema[i].name;\n                if (fieldName == '_id') continue;\n                if (fieldName.length > 0 && fieldName.charAt(0) == '_') continue;\n                if (fields && fields[fieldName] === undefined) continue;\n                var fieldLabel = this._tableRef._schema[i].title ?\n                    this._tableRef._schema[i].title : this._tableRef._schema[i].name;\n                var text = (this._detailPage && this._detailPage.fieldTemplate) ? \n                    this._detailPage.fieldTemplate : progress.ui.UIHelper._fieldTemplate;\n                text = text.replace(new RegExp('{__label__}', 'g'), fieldLabel);\n                text = text.replace(new RegExp('{__name__}', 'g'), this._tableRef._schema[i].name);\n                htmltext += text;\n            }\n            htmltext += '</fieldset>';\n            fields = null;\n            return htmltext;\n        };\n\n        this.getListViewRecord = function (htmlIElement) {\n            var id = htmlIElement.getAttribute('data-id');\n            return this._tableRef.findById(id);\n        };\n\n        this.getFormRecord = function (detailPageName) {\n            var id = this._getFormFieldValue('_id', detailPageName);\n            return this._tableRef.findById(id);\n        };\n\n        this._getIdOfElement = function (name) {\n            if (typeof($) == 'function') {\n                var element = $(\"#\" + name);\n                if (!element || element.length === 0) {\n                    element = $('[dsid=\"' + name + '\"]');\n                    if (element && element.length == 1) {\n                        var id = element.attr(\"id\");\n                        if (id)\n                            return id;\n                    }\n                }\n            }\n            return name;\n        };\n\n        this.setDetailPage = function setDetailPage(obj) {\n            if (!obj || (typeof(obj) != 'object'))\n                throw new Error(msg.getMsgText(\"jsdoMSG012\", arguments.callee.name, \"object\"));\n            if (!obj.name || (typeof(obj.name) != 'string'))\n                throw new Error(msg.getMsgText(\"jsdoMSG012\", arguments.callee.name, \"name\"));\n            this._detailPage = obj;\n            this._detailPage.name = this._getIdOfElement(this._detailPage.name);\n        };\n        this.setListView = function setListView(obj) {\n            if (!obj || (typeof(obj) != 'object'))\n                throw new Error(msg.getMsgText(\"jsdoMSG012\", arguments.callee.name, \"object\"));\n            if (!obj.name || (typeof(obj.name) != 'string'))\n                throw new Error(msg.getMsgText(\"jsdoMSG012\", arguments.callee.name, \"name\"));\n            if (obj.format && (typeof(obj.name) != 'string'))\n                throw new Error(msg.getMsgText(\"jsdoMSG012\", arguments.callee.name, \"format\"));\n\n            this._listview = obj;\n            this._listview.name = this._getIdOfElement(this._listview.name);\n            if (!this._listview.format) {\n                if (typeof($) == 'function') {\n                    for (var i = 0; i < this._tableRef._schema.length; i++) {\n                        var fieldName = this._tableRef._schema[i].name;\n\n                        field = $(\"#\" + this._listview.name + ' [dsid=\"' + fieldName + '\"]');\n                        if (field && field.length == 1) {\n                            field.html('{' + fieldName + '}');\n                        }\n                    }\n                }\n                var text = document.getElementById(this._listview.name).innerHTML;\n                var pos = text.indexOf('<li ');\n                if (pos != -1) {\n                    // Add data-id so that getListViewRecord() can obtain the _id of the record\n                    text = text.substring(0, pos) + '<li data-id=\"{__id__}\"' + text.substring(pos + 3);\n                }\n                this._listview.itemTemplate = text;\n            }\n        };\n\n    };\n\n    progress.ui.UIHelper = function UIHelper() {\n\n        if (typeof(arguments[0]) == \"object\") {\n            var args = arguments[0];\n            for (var v in args) {\n                if (v == 'jsdo') {\n                    this._jsdo = args[v];                   \n                }\n                else {\n                    this[v] = args[v];\n                }\n            }\n        }\n\n        this._defaultUITableRef = null;\n        this._uiTableRef = {};\n        var cnt = 0;\n        for (var buf in this._jsdo._buffers) {\n            this[buf] = this._uiTableRef[buf] = new progress.ui.UITableRef(this._jsdo._buffers[buf]);\n            if (!this._defaultUITableRef)\n                this._defaultUITableRef = this._uiTableRef[buf];\n            cnt++;\n        }\n        if (cnt != 1) {\n            this._defaultUITableRef = null;\n        }\n\n        this.addItem = function (format) {\n            if (this._defaultUITableRef) {\n                this._defaultUITableRef.addItem(format);\n            }\n            else\n                throw new Error(msg.getMsgText(\"jsdoMSG011\", \"addItem()\"));\n        };\n\n        this.clearItems = function () {\n            if (this._defaultUITableRef) {\n                this._defaultUITableRef.clearItems();\n            }\n            else\n                throw new Error(msg.getMsgText(\"jsdoMSG011\", \"clearItems()\"));\n        };\n\n        this.assign = function (detailPageName) {\n            if (arguments.length !== 0)\n                throw new Error(msg.getMsgText(\"jsdoMSG024\", \"UIHelper\", \"assign()\"));\n            if (this._defaultUITableRef) {\n                return this._defaultUITableRef.assign(detailPageName);\n            }\n            else\n                throw new Error(msg.getMsgText(\"jsdoMSG011\", \"assign()\"));\n        };\n\n        this.display = function (detailPageName) {\n            if (this._defaultUITableRef) {\n                this._defaultUITableRef.display(detailPageName);\n            }\n            else\n                throw new Error(msg.getMsgText(\"jsdoMSG011\", \"display()\"));\n        };\n\n        this.showListView = function () {\n            if (this._defaultUITableRef) {\n                this._defaultUITableRef.showListView();\n            }\n            else\n                throw new Error(msg.getMsgText(\"jsdoMSG011\", \"showListView()\"));\n        };\n\n        this.getFormFields = function (fields) {\n            if (this._defaultUITableRef) {\n                return this._defaultUITableRef.getFormFields(fields);\n            }\n            else\n                throw new Error(msg.getMsgText(\"jsdoMSG011\", \"getFormFields()\"));\n        };\n\n        this.getListViewRecord = function (htmlIElement) {\n            if (this._defaultUITableRef) {\n                return this._defaultUITableRef.getListViewRecord(htmlIElement);\n            }\n            else\n                throw new Error(msg.getMsgText(\"jsdoMSG011\", \"getListViewRecord()\"));\n        };\n\n        this.getFormRecord = function (detailPageName) {\n            if (this._defaultUITableRef) {\n                return this._defaultUITableRef.getFormRecord(detailPageName);\n            }\n            else\n                throw new Error(msg.getMsgText(\"jsdoMSG011\", \"getFormRecord()\"));\n        };\n\n        this.setDetailPage = function (obj) {\n            if (this._defaultUITableRef)\n                return this._defaultUITableRef.setDetailPage(obj);\n            throw new Error(msg.getMsgText(\"jsdoMSG011\", \"setDetailPage()\"));\n        };\n\n        this.setListView = function (obj) {\n            if (this._defaultUITableRef)\n                return this._defaultUITableRef.setListView(obj);\n            throw new Error(msg.getMsgText(\"jsdoMSG011\", \"setListView()\"));\n        };\n\n    };\n    progress.ui.UIHelper._defaultItemTemplate = '<li data-theme=\"c\" data-id=\"{__id__}\">' +\n        '<a href=\"#{__page__}\" class=\"ui-link\" data-transition=\"slide\">{__format__}</a></li>';\n    progress.ui.UIHelper._defaultFieldTemplate = '<div data-role=\"fieldcontain\">' + \n        '<label for=\"{__name__}\">{__label__}</label>' +\n        '<input id=\"{__name__}\" name=\"{__name__}\" placeholder=\"\" value=\"\" type=\"text\" /></div>';\n    progress.ui.UIHelper._itemTemplate = progress.ui.UIHelper._defaultItemTemplate;\n    progress.ui.UIHelper._fieldTemplate = progress.ui.UIHelper._defaultFieldTemplate;\n\n    progress.ui.UIHelper.setItemTemplate = function (template) {\n        progress.ui.UIHelper._itemTemplate = template ? template : progress.ui.UIHelper._defaultItemTemplate;\n    };\n\n    progress.ui.UIHelper.setFieldTemplate = function (template) {\n        progress.ui.UIHelper._fieldTemplate = \n            template ? template : progress.ui.UIHelper._defaultFieldTemplate;\n    };\n\n})();\n\n//this is so that we can see the code in Chrome's Source tab when script is loaded via XHR\n//# sourceURL=progress.jsdo.js\n\n/* \nprogress.session.js    Version: 4.3.0-23\n\nCopyright (c) 2012-2016 Progress Software Corporation and/or its subsidiaries or affiliates.\n \nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n \n    http://www.apache.org/licenses/LICENSE-2.0\n \nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n */\n\n(function () {\n\n    /* define these if not defined yet - they may already be defined if\n     progress.js was included first */\n    if (typeof progress === \"undefined\") {\n        progress = {};\n    }\n    if (typeof progress.data === \"undefined\") {\n        progress.data = {};\n    }\n\n    progress.data.ServicesManager = {};\n    progress.data.ServicesManager._services = [];\n    progress.data.ServicesManager._resources = [];\n    progress.data.ServicesManager._data = [];\n    progress.data.ServicesManager._sessions = [];\n    /*\n     progress.data.ServicesManager.put = function(id, jsdo) {\n     progress.data.ServicesManager._data[id] = jsdo;\n     };\n     progress.data.ServicesManager.get = function(id) {\n     return progress.data.ServicesManager._data[id];\n     };\n     */\n\n    progress.data.ServicesManager.addResource = function (id, resource) {\n        if (progress.data.ServicesManager._resources[id] === undefined)\n            progress.data.ServicesManager._resources[id] = resource;\n        else\n            throw new Error(\"A resource named '\" + id + \"' was already loaded.\");\n    };\n    progress.data.ServicesManager.getResource = function (id) {\n        return progress.data.ServicesManager._resources[id];\n    };\n    progress.data.ServicesManager.addService = function (id, service) {\n        if (progress.data.ServicesManager._services[id] === undefined)\n            progress.data.ServicesManager._services[id] = service;\n        else\n            throw new Error(\"A service named '\" + id + \"' was already loaded.\");\n    };\n    progress.data.ServicesManager.getService = function (id) {\n        return progress.data.ServicesManager._services[id];\n    };\n    progress.data.ServicesManager.addSession = function (catalogURI, session) {\n        if (progress.data.ServicesManager._sessions[catalogURI] === undefined)\n            progress.data.ServicesManager._sessions[catalogURI] = session;\n        else\n            throw new Error(\"Cannot load catalog '\" + catalogURI + \"' multiple times.\");\n    };\n    progress.data.ServicesManager.getSession = function (catalogURI) {\n        try {\n            return progress.data.ServicesManager._sessions[catalogURI];\n        }\n        catch (e) {\n            return null;\n        }\n    };\n\n    /*\n     * Scans URL for parameters of the form {name}\n     * Returns array with the names\n     */\n    function extractParamsFromURL(url) {\n        var urlParams = [];\n        if (typeof(url) == 'string') {\n            var paramName = null;\n            for (var i = 0; i < url.length; i++) {\n                if (url.charAt(i) == '{') {\n                    paramName = \"\";\n                }\n                else if (url.charAt(i) == '}') {\n                    if (paramName)\n                        urlParams.push(paramName);\n                    paramName = null;\n                }\n                else if (paramName !== null) {\n                    paramName += url.charAt(i);\n                }\n            }\n        }\n        return urlParams;\n    }\n\n    /*\n     * Adds the catalog.json file provided by the catalog parameter, which is a JSDO\n     * that has loaded the catalog\n     */\n    progress.data.ServicesManager.addCatalog = function (services, session) {\n        if (!services) {\n            throw new Error(\"Cannot find 'services' property in catalog file.\");\n        }\n        if (services instanceof Array) {\n\n            // first check if there are duplicates before we add them to our cache,\n            // which only handles unique values\n            for (var j = 0; j < services.length; j++) {\n                // don't allow services with the same name across sessions\n                if (progress.data.ServicesManager.getService(services[j].name) !== undefined)\n                    throw new Error(\"A service named '\" + services[j].name + \"' was already loaded.\");\n\n                var resources = services[j].resources;\n\n                if (resources instanceof Array) {\n                    for (var i = 0; i < resources.length; i++) {\n                        if (progress.data.ServicesManager.getResource(resources[i].name) !== undefined)\n                            throw new Error(\"A resource named '\" + resources[i].name + \n                                \"' was already loaded.\");\n                    }\n                }\n                else {\n                    throw new Error(\"Missing 'resources' array in catalog.\");\n                }\n            }\n\n            for (var j = 0; j < services.length; j++) {\n                services[j]._session = session;\n                this.addService(services[j].name, services[j]); // Register the service\n                var resources = services[j].resources;\n                var baseAddress = services[j].address;\n                if (resources instanceof Array) {\n                    for (var i = 0; i < resources.length; i++) {\n                        var resource = resources[i];\n                        resource.fn = {};\n                        resource.service = services[j];\n                        resources[i].url = baseAddress + resources[i].path;\n                        // Register resource\n                        progress.data.ServicesManager.addResource(resources[i].name, resources[i]);\n\n                        // Process schema\n                        resource.fields = null;\n                        resource.primaryKeys = null;\n                        if (resource.schema) {\n                            resource.fields = {};\n                            resource.primaryKeys = {};\n                            resource._dataSetName = undefined;\n                            resource._tempTableName = undefined;\n                            var properties = null;\n\n                            try {\n                                if (typeof resource.schema.properties != 'undefined') {\n                                    var keys = Object.keys(resource.schema.properties);\n                                    properties = resource.schema.properties;\n                                    if (keys.length == 1) {\n                                        if (typeof resource.schema.properties[keys[0]].properties != \n                                            'undefined') {\n                                            // Schema corresponds to a DataSet\n                                            resource._dataSetName = keys[0];\n                                        }\n                                        else if (typeof resource.schema.properties[keys[0]].items != \n                                            'undefined') {\n                                            // Schema corresponds to a temp-table\n                                            resource.dataProperty = keys[0];\n                                            properties = resource.schema.properties[keys[0]].items.properties;\n                                            resource._tempTableName = resource.dataProperty;\n                                            resource.primaryKeys[resource._tempTableName] = \n                                                resource.schema.properties[keys[0]].primaryKey;\n                                        }\n                                    }\n                                }\n                                else {\n                                    var keys = Object.keys(resource.schema);\n                                    if (keys.length == 1) {\n                                        resource.dataProperty = keys[0];\n                                        if (typeof resource.schema[keys[0]].items != 'undefined') {\n                                            // Catalog format correspond to Table Schema\n                                            properties = resource.schema[keys[0]].items.properties;\n                                            resource._tempTableName = resource.dataProperty;\n                                            resource.primaryKeys[resource._tempTableName] = \n                                                resource.schema[keys[0]].primaryKey;\n                                        }\n                                        else if (typeof resource.schema[keys[0]].properties != 'undefined') {\n                                            // Catalog format correspond to DataSet Schema\n                                            resource._dataSetName = keys[0];\n                                            resource.dataProperty = null;\n                                            properties = resource.schema;\n                                        }\n                                    }\n                                }\n                            }\n                            catch (e) {\n                                throw new Error(\"Error parsing catalog file.\");\n                            }\n                            if (properties) {\n                                if (resource._dataSetName) {\n                                    properties = properties[resource._dataSetName].properties;\n                                    for (var tableName in properties) {\n                                        resource.fields[tableName] = [];\n                                        resource.primaryKeys[tableName] = properties[tableName].primaryKey;\n                                        var tableProperties;\n                                        if (properties[tableName].items\n                                            && properties[tableName].items.properties) {\n                                            tableProperties = properties[tableName].items.properties;\n                                        }\n                                        else {\n                                            tableProperties = properties[tableName].properties;\n                                        }\n                                        for (var field in tableProperties) {\n                                            tableProperties[field].name = field;\n                                            if (field != '_id')\n                                                resource.fields[tableName].push(tableProperties[field]);\n                                        }\n                                    }\n                                }\n                                else {\n                                    var tableName = resource.dataProperty ? resource.dataProperty : \"\";\n                                    resource.fields[tableName] = [];\n                                    for (var field in properties) {\n                                        properties[field].name = field;\n                                        if (field != '_id')\n                                            resource.fields[tableName].push(properties[field]);\n                                    }\n                                }\n                            }\n                            else\n                                throw new Error(\"Error parsing catalog file.\");\n                        }\n                        else\n                            resource.fields = null;\n\n                        // Validate relationship property\n                        if ((resource.relations instanceof Array)\n                            && resource.relations[0]\n                            && resource.relations[0].RelationName) {\n                            throw new Error(\n                                \"Relationship properties in catalog must begin with lowercase.\");\n                        }\n                        // Process operations\n                        resource.generic = {};\n                        if (resource.operations) {\n                            for (var idx = 0; idx < resource.operations.length; idx++) {\n                                if (resource.operations[idx].path) {\n                                    resource.operations[idx].url = \n                                        resource.url + resource.operations[idx].path;\n                                }\n                                else {\n                                    resource.operations[idx].url = resource.url;\n                                }\n                                if (!resource.operations[idx].params) {\n                                    resource.operations[idx].params = [];\n                                }\n                                if (!resource.operations[idx].type) {\n                                    resource.operations[idx].type = \"INVOKE\";\n                                }\n\n                                // Set opname - validation of opname is done later\n                                var opname = resource.operations[idx].type.toLowerCase();\n\n                                // Set default verb based on operation\n                                if (!resource.operations[idx].verb) {\n                                    switch (opname) {\n                                        case 'create':\n                                            resource.operations[idx].verb = \"POST\";\n                                            break;\n                                        case 'read':\n                                            resource.operations[idx].verb = \"GET\";\n                                            break;\n                                        case 'update':\n                                        case 'invoke':\n                                        case 'submit':\n                                        case 'count':\n                                            resource.operations[idx].verb = \"PUT\";\n                                            break;\n                                        case 'delete':\n                                            resource.operations[idx].verb = \"DELETE\";\n                                            break;\n                                        default:\n                                            break;\n                                    }\n                                }\n\n                                // Point fn to operations\n                                var func = function fn(object, async) {\n                                    var deferred;\n                                    \n                                    // Add static variable fnName to function\n                                    if (typeof fn.fnName == 'undefined') {\n                                        fn.fnName = arguments[0]; // Name of function\n                                        fn.definition = arguments[1]; // Operation definition\n                                        return;\n                                    }\n                                                                        \n                                    var reqBody = null;\n                                    var url = fn.definition.url;\n                                    var jsdo = this;\n                                    var xhr = null;\n\n                                    var request = {};\n                                    if (object) {\n                                        if (typeof(object) != \"object\") {\n                                            throw new Error(\"Catalog error: Function '\" + \n                                                fn.fnName + \"' requires an object as a parameter.\");\n                                        }\n                                        var objParam;\n                                        if (object instanceof XMLHttpRequest) {\n                                            jsdo = object.jsdo;\n                                            xhr = object;\n                                            objParam = xhr.objParam;\n\n                                            // use the request from the xhr request if possible\n                                            request = xhr.request;\n                                        }\n                                        else {\n                                            objParam = object;\n                                        }\n\n                                        if (typeof async == 'undefined') {\n                                            async = this._async;\n                                        }\n                                        else {\n                                            async = Boolean(async);\n                                        }\n\n                                        request.objParam = objParam;\n                                        \n\n                                        // Process objParam\n                                        var isInvoke = (fn.definition.type.toUpperCase() == 'INVOKE');\n                                        for (var i = 0; i < fn.definition.params.length; i++) {\n                                            var name = fn.definition.params[i].name;\n                                            switch (fn.definition.params[i].type) {\n                                                case 'PATH':\n                                                case 'QUERY':\n                                                case 'MATRIX':\n                                                    var value = null;\n                                                    if (objParam)\n                                                        value = objParam[name];\n                                                    if (!value)\n                                                        value = \"\";\n                                                    if (url.indexOf('{' + name + '}') == -1) {\n                                                        throw new Error(\"Catalog error: Reference to \" + \n                                                            fn.definition.params[i].type + \" parameter '\" + \n                                                            name + \"' is missing in path.\");\n                                                    }\n                                                    url = url.replace(\n                                                        new RegExp('{' + name + '}', 'g'),\n                                                        encodeURIComponent(value));\n                                                    break;\n                                                case 'REQUEST_BODY':\n                                                case 'REQUEST_BODY,RESPONSE_BODY':\n                                                case 'RESPONSE_BODY,REQUEST_BODY':\n                                                    if (xhr && !reqBody) {\n                                                        reqBody = objParam;\n                                                    }\n                                                    else {\n                                                        var reqParam = objParam[name];\n                                                        if (isInvoke\n                                                            && (fn.definition.params[i].xType \n                                                            && (\"DATASET,TABLE\".indexOf(\n                                                                fn.definition.params[i].xType) != -1))) {\n                                                            var unwrapped = (jsdo._resource.service.settings \n                                                                && jsdo._resource.service.settings.unwrapped);\n                                                            if (unwrapped) {\n                                                                // Remove extra level if found\n                                                                if ((typeof(reqParam) == 'object')\n                                                                    && (Object.keys(reqParam).length == 1)\n                                                                    && (typeof(reqParam[name]) == 'object'))\n                                                                    reqParam = reqParam[name];\n                                                            }\n                                                            else {\n                                                                // Add extra level if not found\n                                                                if ((typeof(reqParam) == 'object')\n                                                                    && (typeof(reqParam[name])=='undefined')){\n                                                                    reqParam = {};\n                                                                    reqParam[name] = objParam[name];\n                                                                }\n                                                            }\n                                                        }\n                                                        if (!reqBody) {\n                                                            reqBody = {};\n                                                        }\n                                                        reqBody[name] = reqParam;\n                                                    }\n                                                    break;\n                                                case 'RESPONSE_BODY':\n                                                    break;\n                                                default:\n                                                    throw new Error(\"Catalog error: \" + \n                                                        \"Unexpected parameter type '\" + \n                                                        fn.definition.params[i].type + \"'.\");\n                                            }\n                                        }\n\n                                        // URL has parameters\n                                        if (url.indexOf('{') != -1) {\n                                            var paramsFromURL = extractParamsFromURL(url);\n                                            for (var i = 0; i < paramsFromURL.length; i++) {\n                                                var name = paramsFromURL[i];\n                                                var value = null;\n                                                if (objParam)\n                                                    value = objParam[name];\n                                                if (!value)\n                                                    value = \"\";\n                                                if (typeof(value) === \"object\") {\n                                                    value = JSON.stringify(value);\n                                                }\n                                                url = url.replace(\n                                                    new RegExp('{' + name + '}', 'g'),\n                                                    encodeURIComponent(value));\n                                            }\n                                        }\n                                    }\n\n                                    request.fnName = fn.fnName;\n                                    request.async = async;\n                                    \n                                    if (request.deferred === undefined &&\n                                        typeof($) == 'function' && typeof($.Deferred) == 'function') {\n                                        deferred = $.Deferred();\n                                        request.deferred = deferred;\n                                    }\n\n                                    var data = jsdo._httpRequest(xhr, fn.definition.verb, \n                                        url, reqBody, request, async);\n                                    return data;\n                                };\n                                // End of Function Definition\n\n                                switch (resource.operations[idx].verb.toLowerCase()) {\n                                    case 'get':\n                                    case 'post':\n                                    case 'put':\n                                    case 'delete':\n                                        break;\n                                    default:\n                                        throw new Error(\"Catalog error: Unexpected HTTP verb '\" + \n                                            resource.operations[idx].verb + \n                                            \"' found while parsing the catalog.\");\n                                }\n\n                                switch (opname) {\n                                    case 'invoke':\n                                        break;\n                                    case 'create':\n                                    case 'read':\n                                    case 'update':\n                                    case 'delete':\n                                    case 'submit':\n                                    case 'count':                                                                                \n                                        if (typeof(resource.generic[opname]) == \"function\") {\n                                            throw new Error(\"Catalog error: Multiple '\" + \n                                                resource.operations[idx].type + \n                                                \"' operations specified in the catalog for resource '\" + \n                                                resource.name + \"'.\");\n                                        }\n                                        else\n                                            resource.generic[opname] = func;\n                                        break;\n                                    default:\n                                        throw new Error(\"Catalog error: Unexpected operation '\" + \n                                            resource.operations[idx].type + \n                                            \"' found while parsing the catalog.\");\n                                }\n\n                                // Set fnName\n                                var name = resource.operations[idx].name;\n                                if (opname === \"invoke\" || opname === \"count\") {\n                                    resource.fn[name] = {};\n                                    resource.fn[name][\"function\"] = func;\n                                }\n                                else {\n                                    name = \"_\" + opname;\n                                }\n                                func(name, resource.operations[idx]);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            throw new Error(\"Missing 'services' array in catalog.\");\n        }\n\n    };\n\n    /*\n     * Prints debug information about the ServicesManager.\n     */\n    progress.data.ServicesManager.printDebugInfo = function (resourceName) {\n        if (resourceName) {\n            //console.log(\"** ServicesManager **\");\n            //console.log(\"** BEGIN **\");\n            var resource = progress.data.ServicesManager.getResource(resourceName);\n            if (resource) {\n                var cSchema = \"Schema:\\n\";\n                var cOperations = \"Operations: \" + resource.operations.length + \"\\n\";\n                for (var field in resource.schema.properties) {\n                    cSchema += \"\\nName: \" + field\n                    + \"\\n\";\n                }\n\n                for (var i = 0; i < resource.operations.length; i++) {\n                    cOperations += \"\\n\" + i\n                    + \"\\nName: \" + resource.operations[i].name\n                    + \"\\nURL: \" + resource.operations[i].url\n                    + \"\\ntype: \" + resource.operations[i].type\n                    + \"\\nverb: \" + resource.operations[i].verb\n                    + \"\\nparams: \" + resource.operations[i].params.length\n                    + \"\\n\";\n                }\n                console.log(\"** DEBUG INFO **\\nResource name: %s\\nURL:%s\\n%s\\n%s\\n\\n\",\n                    resource.name, resource.url, cSchema, cOperations);\n            }\n            else\n                console.log(\"Resource not found\");\n            //console.log(\"** END **\");\n        }\n    };\n\n\n    /*\n     * Contains information about a server-side Mobile service.\n     * Properties of args parameter for constructor:\n     * @param name   the name of the service\n     * @param uri    the URI of the service\n     */\n    progress.data.MobileServiceObject = function MobileServiceObject(args) {\n        var _name = args.name;\n        Object.defineProperty(this, 'name',\n            {\n                get: function () {\n                    return _name;\n                },\n                enumerable: true\n            });\n\n        var _uri = args.uri;\n        Object.defineProperty(this, 'uri',\n            {\n                get: function () {\n                    return _uri;\n                },\n                enumerable: true\n            });\n    };\n\n    /* \n        An object that maintains the X-CLIENT-PROPS header string\n        The data for the string is stored in the internal variable named contextObject and is\n        always up to date. The internal var contextString isn't created until the first time it's\n        needed (the first get of the contextHeader property), and then it's updated an cached\n        A call to setContext or setContextProperty updates contextObject but sets contextString to\n        null, which signals that it needs to be updated. If contextObject is an empty object,\n        contextString is set to undefined to indicate that no header is to be sent\n     */\n    progress.data.ContextProperties = function() {\n        var contextObject = {},\n            contextString; // if null, contextObject has been changed but string wasn't updated yet\n            \n            //  the string to be sent in the X-CLIENT-PROPS header (unless Session.xClientProps has been set)\n        Object.defineProperty(this, 'contextHeader',\n            {\n                get: function () {\n                    var header;\n                    \n                    if (contextString === null) {  // needs to be updated\n                        header = JSON.stringify( contextObject );\n                        if (header === \"{}\") {\n                            contextString = undefined;\n                        }\n                        else {\n                            contextString = header;\n                        }\n                    }                        \n                    // else (contextString === undefined || has a usable value) \n\n                    return contextString;\n                },\n                enumerable: true\n            });\n\n        /* determine whether the property is already present, and -\n            add it if it's not present\n            remove it if propertyValue is explicitly passed as undefined\n            otherwise replace its value (even if the new value is null or \"\")\n        */\n        this.setContextProperty = function( propertyName, propertyValue) {\n            if (arguments.length < 2) {\n                // {1}: Incorrect number of arguments in {2} call. There should be {3}.\n                throw new Error(progress.data._getMsgText(\"jsdoMSG122\", 'Session', \n                                                           'setContextProperty', 2)); \n            }\n            if (arguments.length !== 2) {\n                // {1}: Incorrect number of arguments in {2} call. There should be only {3}.\";\n                throw new Error(progress.data._getMsgText(\"jsdoMSG122\", \"Session\",\n                                                          \"setContextProperty\", 2)); \n            }\n            if (typeof propertyName !== \"string\") {\n                // {1}: Parameter {1} must be of type {3} in {4} call.\n                throw new Error(progress.data._getMsgText(\"jsdoMSG121\", 'Session', 1, 'string',\n                                                          'setContextProperty')); \n            }\n\n            if ( propertyValue === undefined ) {\n                delete contextObject[propertyName]; // OK if it doesn't exist -- no error\n            }\n            else {\n                contextObject[propertyName] = propertyValue;\n            }\n            contextString = null; // must be updated on next get of this.contextHeader\n        };\n\n        this.setContext = function( context ) {\n            var prop;\n\n            if (arguments.length < 1) {\n                // {1}: Incorrect number of arguments in {2} call. There should be {3}.\n                throw new Error(progress.data._getMsgText(\"jsdoMSG122\", 'Session', 'setContext', 1)); \n            }\n            if (arguments.length > 1) {\n                // {1}: Incorrect number of arguments in {2} call. There should be only {3}.\";\n                throw new Error(progress.data._getMsgText(\"jsdoMSG122\", 'Session', 'setContext', 1)); \n            }\n            if ( typeof context == \"object\" ) {\n                /* Copy the properties of the context passed in as an argument into\n                 * an internal contextObject. (Note that if the context object passed in\n                 * has a prototype, this code copies them, too)\n                 */\n                contextObject = {};\n                for (prop in context) {\n                    if( context.hasOwnProperty(prop) )  {\n                        if (typeof context[prop] !== \"function\" ) {\n                            contextObject[prop] = context[prop];\n                        }\n                    }\n                }\n            }\n            else if ( (context === undefined) || (context === null) ) {\n                contextObject = {};\n            }\n            else {\n                // {1}: Parameter {1} must be of type {3} in {4} call.\n                throw new Error(progress.data._getMsgText(\"jsdoMSG121\", 'Session', 1, 'Object',\n                                                          'setContextProperty')); \n            }\n            contextString = null; // must be updated on next get of this.contextHeader\n        };\n        \n        this.getContext = function( ) {\n            if (arguments.length > 0) {\n                // {1}: Incorrect number of arguments in {2} call. There should be {3}.\";\n                throw new Error(progress.data._getMsgText(\"jsdoMSG122\", 'Session', 'getContext', 0)); \n            }\n            return contextObject;\n        };\n        \n        this.getContextProperty = function( propertyName) {\n            if (arguments.length < 1) {\n                // {1}: Incorrect number of arguments in {2} call. There should be {3}.\n                throw new Error(progress.data._getMsgText(\"jsdoMSG122\", 'Session', 'getContextProperty', 1)); \n            }\n            if (arguments.length > 1) {\n                // {1}: Incorrect number of arguments in {2} call. There should be only {3}.\";\n                throw new Error(progress.data._getMsgText(\"jsdoMSG122\", 'Session', 'getContextProperty', 1)); \n            }\n            return contextObject[propertyName];\n        };\n        \n    };  // end of ContextProperties\n    \n    /*\n     * Manages authentication and session ID information for a service.\n     *\n     * Use:  OE mobile developer instantiates a session and calls addCatalog() to load\n     *       information for one or more services defined in a catalog file.\n     *\n     *       Developer instantiates JDSOs as needed.\n     *       Usually all of the JSDOs will use the same session, but if a client-side\n     *       service needs resources from more than one REST app, there would need to be more\n     *       than one session\n     *\n     */\n    progress.data.Session = function Session(options) {\n\n        var defPropSupported = false;\n        if ((typeof Object.defineProperty) == 'function') {\n            defPropSupported = true;\n        }\n        \n        var myself = this,\n            isUserAgentiOS = false,  // checked just below this var statement\n            isFirefox = false,  // checked just below this var statement\n            isEdge = false,  // checked just below this var statement\n            isIE = false,  // checked just below this var statement\n            canPassCredentialsToOpenWithCORS = false,  // False will always work if creds are correct\n            defaultiOSBasicAuthTimeout = 4000,\n            deviceIsOnline = true,  // online until proven offline\n            restApplicationIsOnline = false,  // was the Mobile Web Application that this Session object\n                                              // connects to online the last time it was checked?\n                                              // (value is always false if session is not logged in)\n            oepingAvailable = false,\n            defaultPartialPingURI = \"/rest/_oeping\",\n            partialPingURI = defaultPartialPingURI,\n            _storageKey;\n\n        if (typeof navigator  !== \"undefined\") {\n            if (typeof navigator.userAgent !== \"undefined\") {\n                isUserAgentiOS = navigator.userAgent.match(/(iPad)|(iPhone)|(iPod)/i);\n                isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;\n                // detect that we're running in MS Edge browser\n                isEdge = navigator.userAgent.indexOf('Edge/') > -1;\n                // detect that we're running in IE 11 (or IE 11 in pre-11 mode) or IE 10 browser\n                isIE = ( (navigator.userAgent.indexOf('Trident/')) > -1 || (navigator.userAgent.indexOf('MSIE 10') > -1));\n            }\n        }\n        \n        // Firefox, Edge, and IE will throw an error on the send() if CORS is being used for the request\n        // and we have included credentials in the URI (which is what passing them to open() does),\n        canPassCredentialsToOpenWithCORS = !(isFirefox || isEdge || isIE);\n        \n        // When using basic authentication, we can pass the user name and password to the XMLHttpRequest.open()\n        // method. However, in some browsers, passing credentials to open() will result in the xhr's .send() \n        // method throwing an error. The goal of this function is to figure out whether it's safe to include\n        // the credentials. It returns false if there could be a problem, true otherwise.\n        // Note: currently it does this solely on the basis of what browser we are running in, regardless\n        // of whether the request will actually use the CORS protocol. Ideally, we should take into account whether \n        // the request will actually require CORS. The question is whether we can reliably do that.\n        // The reason for taking the specific request into account is that there are drawbacks to not passing the\n        // credentials when we are NOT using CORS, namely that if the credentials are invalid, some browsers will \n        // put up their own prompt for credentials in non-CORS situations (those browsers are IE, Edge, and Chrome)\n        function canPassCredentialsToOpen() {\n            return canPassCredentialsToOpenWithCORS;\n        }\n        \n        this._onlineHandler = function () {\n            setDeviceIsOnline(true);\n            myself.trigger(\"online\", myself, null);\n        };\n\n        this._offlineHandler = function () {\n            setDeviceIsOnline(false);\n            myself.trigger(\"offline\", myself, progress.data.Session.DEVICE_OFFLINE, null);\n        };\n\n        if ((typeof window != 'undefined' ) && (window.addEventListener)) {\n            window.addEventListener(\"online\", this._onlineHandler, false);\n            window.addEventListener(\"offline\", this._offlineHandler, false);\n        }\n\n        /* constants and properties - define them as properties via the defineProperty()\n         * function, which has \"writable\" and \"configurable\" parameters that both\n         * default to false, so these calls create properties that are read-only\n         *\n         * IF WE DECIDE THAT WE CAN ASSUME WE ALWAYS RUN WITH A VERSION OF JAVASCRIPT THAT SUPPORTS\n         * Object.DefineProperty(), WE CAN DELETE THE defPropSupported VARIABLE, THE TEST OF IT BELOW,\n         * AND THE 'ELSE' CLAUSE BELOW AND ALL THE setXxxx functions (AND CHANGE THE CALLS TO THE setXxxx\n         * FUNCTIONS SO THEY JUST REFER TO THE PROPERTY)\n         *\n         */\n\n        // define these unconditionally so we don't get a warning on the push calls that they might\n        // have been uninitialized\n        var _catalogURIs = [];\n        var _services = [];\n        var _jsdos = [];\n\n        this.onOpenRequest = null;\n\n        var _password = null;\n\n        if (defPropSupported) {\n            var _userName = null;\n            Object.defineProperty(this, 'userName',\n                {\n                    get: function () {\n                        return _userName;\n                    },\n                    enumerable: true\n                });\n\n            var _loginTarget = '/static/home.html';\n            Object.defineProperty(this, 'loginTarget',\n                {\n                    get: function () {\n                        return _loginTarget;\n                    },\n                    enumerable: true\n                });\n\n            var _serviceURI = null;\n            Object.defineProperty(this, 'serviceURI',\n                {\n                    get: function () {\n                        return _serviceURI;\n                    },\n                    enumerable: true\n                });\n\n            Object.defineProperty(this, 'catalogURIs',\n                {\n                    get: function () {\n                        return _catalogURIs;\n                    },\n                    enumerable: true\n                });\n\n            Object.defineProperty(this, 'services',\n                {\n                    get: function () {\n                        return _services;\n                    },\n                    enumerable: true\n                });\n\n            var _loginResult = null;\n            Object.defineProperty(this, 'loginResult',\n                {\n                    get: function () {\n                        return _loginResult;\n                    },\n                    enumerable: true\n                });\n\n            var _loginHttpStatus = null;\n            Object.defineProperty(this, 'loginHttpStatus',\n                {\n                    get: function () {\n                        return _loginHttpStatus;\n                    },\n                    enumerable: true\n                });\n\n            var _clientContextId = null;\n            Object.defineProperty(this, 'clientContextId',\n                {\n                    get: function () {\n                        return _clientContextId;\n                    },\n                    enumerable: true\n                });\n\n            var _authenticationModel = progress.data.Session.AUTH_TYPE_ANON;\n            Object.defineProperty(this, 'authenticationModel',\n                {\n                    get: function () {\n                        return _authenticationModel;\n                    },\n                    set: function (newval) {\n                        if (newval) {\n                            newval = newval.toLowerCase();\n                        }\n                        switch (newval) {\n                            case progress.data.Session.AUTH_TYPE_FORM :\n                            case progress.data.Session.AUTH_TYPE_BASIC :\n                            case progress.data.Session.AUTH_TYPE_ANON :\n                            case null :\n                                _authenticationModel = newval;\n                                storeSessionInfo(\"authenticationModel\", newval);\n\n                                break;\n                            default:\n                                throw new Error(\"Error setting Session.authenticationModel. '\" + \n                                    newval + \"' is an invalid value.\");\n                        }\n                    },\n                    enumerable: true\n                });\n\n            var _lastSessionXHR = null;\n            Object.defineProperty(this, 'lastSessionXHR',\n                {\n                    get: function () {\n                        return _lastSessionXHR;\n                    },\n                    enumerable: true\n                });\n\n            Object.defineProperty(this, 'connected',\n                {\n                    get: function () {\n                        return     (this.loginResult === progress.data.Session.LOGIN_SUCCESS)\n                                && restApplicationIsOnline \n                                && deviceIsOnline;\n                    },\n                    enumerable: true\n                });\n\n            Object.defineProperty(this, 'JSDOs',\n                {\n                    get: function () {\n                        return _jsdos;\n                    },\n                    enumerable: true\n                });\n\n            var _pingInterval = 0;\n            var _timeoutID = null;\n            Object.defineProperty(this, 'pingInterval',\n                {\n                    get: function () {\n                        return _pingInterval;\n                    },\n                    set: function (newval) {\n                        if ( (typeof newval === \"number\") && (newval >= 0) ) {\n                            _pingInterval = newval;\n                            storeSessionInfo(\"pingInterval\", newval);\n                            if (newval > 0) {\n                                // if we're logged in, start autopinging\n                                if (this.loginResult === progress.data.Session.LOGIN_SUCCESS) {\n                                    _timeoutID = setTimeout(this._autoping, newval);\n                                }\n                            }\n                            else if (newval === 0) {\n                                clearTimeout(_timeoutID);\n                                _pingInterval = 0;\n                            }\n                        }\n                        else {\n                            throw new Error(\"Error setting Session.pingInterval. '\" + \n                                newval + \"' is an invalid value.\");\n                        }\n                    },\n                    enumerable: true\n                });\n\n            var _contextProperties = new progress.data.ContextProperties();\n            Object.defineProperty( this, \n                                   \"_contextProperties\",\n                                   {  \n                                       get: function () {\n                                            return _contextProperties;\n                                       },\n                                       enumerable: false\n                                   }\n                                 );\n        }\n        else {\n            this.userName = null;\n            this.loginTarget = '/static/home.html';\n            this.serviceURI = null;\n            this.catalogURIs = [];\n            this.services = [];\n            this.loginResult = null;\n            this.loginHttpStatus = null;\n            this.clientContextId = null;\n            this.authenticationModel = progress.data.Session.AUTH_TYPE_ANON;\n            this.lastSessionXHR = null;\n        }\n\n        // stores data value using the JSDOSession's storage key plus the infoName\n        // argument as a key. If there is no infoName, just uses the storage key\n        // by itself (the latter case is inetnded to serev as a flag that we have\n        // stored this JSDOSession's data before)\n        // \n        function storeSessionInfo(infoName, value) {\n            var key;\n            if (myself.loginResult === progress.data.Session.LOGIN_SUCCESS &&\n                typeof (sessionStorage) === 'object' && _storageKey) {\n                    \n                key = _storageKey;\n                if (infoName) {\n                    key = key + \".\" + infoName;\n                }\n                if (typeof (value) !== 'undefined') {\n                    sessionStorage.setItem(key, JSON.stringify(value));\n                }\n            }\n        }\n        \n        function retrieveSessionInfo(infoName) {\n            var key,\n                jsonStr,\n                value = null;\n            if (typeof (sessionStorage) === 'object' && _storageKey) {\n                key = _storageKey;\n                if (infoName) {\n                    key = key + \".\" + infoName;\n                }\n                jsonStr = sessionStorage.getItem(key);\n                if (jsonStr !== null) {\n                    try {\n                        value = JSON.parse(jsonStr);\n                    } catch (e) {\n                        value = null;\n                    }\n                }\n                return value;\n            }\n        }\n        \n        function clearSessionInfo(infoName) {\n            var key;\n            if (typeof (sessionStorage) === 'object' && _storageKey) {\n                key = _storageKey;\n                if (infoName) {\n                    key = key + \".\" + infoName;\n                    sessionStorage.removeItem(key);\n                }\n            }\n        }\n\n        function storeAllSessionInfo() {\n            if (_storageKey) {\n                storeSessionInfo(\"loginResult\", myself.loginResult);\n                storeSessionInfo(\"userName\", myself.userName);\n                storeSessionInfo(\"serviceURI\", myself.serviceURI);\n                storeSessionInfo(\"loginHttpStatus\", myself.loginHttpStatus);\n                storeSessionInfo(\"authenticationModel\", myself.authenticationModel);\n                storeSessionInfo(\"pingInterval\", myself.pingInterval);\n                storeSessionInfo(\"oepingAvailable\", oepingAvailable);\n                storeSessionInfo(\"partialPingURI\", partialPingURI);\n                storeSessionInfo(\"clientContextId\", myself.clientContextId);\n                storeSessionInfo(\"deviceIsOnline\", deviceIsOnline);\n                storeSessionInfo(\"restApplicationIsOnline\", restApplicationIsOnline);\n                storeSessionInfo(_storageKey, true);\n            }\n        }\n        \n        function clearAllSessionInfo() {\n            if (_storageKey) {\n                if (retrieveSessionInfo(_storageKey)) {\n                    clearSessionInfo(\"loginResult\");\n                    clearSessionInfo(\"userName\");\n                    clearSessionInfo(\"serviceURI\");\n                    clearSessionInfo(\"loginHttpStatus\");\n                    clearSessionInfo(\"clientContextId\");\n                    clearSessionInfo(\"deviceIsOnline\");\n                    clearSessionInfo(\"restApplicationIsOnline\");\n                    clearSessionInfo(\"authenticationModel\");\n                    clearSessionInfo(\"pingInterval\");\n                    clearSessionInfo(\"oepingAvailable\");\n                    clearSessionInfo(\"partialPingURI\");\n                    clearSessionInfo(_storageKey);\n                }\n            }\n        }\n        \n        function setSessionInfoFromStorage(key) {\n            if (retrieveSessionInfo(key)) {\n                setLoginResult(retrieveSessionInfo(\"loginResult\"), this);\n                setUserName(retrieveSessionInfo(\"userName\"), this);\n                setServiceURI(retrieveSessionInfo(\"serviceURI\"), this);\n                setLoginHttpStatus(retrieveSessionInfo(\"loginHttpStatus\"), this);\n                setClientContextID(retrieveSessionInfo(\"clientContextId\"), this);\n                setDeviceIsOnline(retrieveSessionInfo(\"deviceIsOnline\"));\n                setRestApplicationIsOnline(retrieveSessionInfo(\"restApplicationIsOnline\"));\n                myself.authenticationModel = retrieveSessionInfo(\"authenticationModel\");\n                myself.pingInterval = retrieveSessionInfo(\"pingInterval\");\n                setOepingAvailable(retrieveSessionInfo(\"oepingAvailable\"));\n                setPartialPingURI(retrieveSessionInfo(\"partialPingURI\"));\n            }\n        }\n\n        function setUserName(newname, sessionObject) {\n            if (defPropSupported) {\n                _userName = newname;\n            }\n            else {\n                sessionObject.userName = newname;\n            }\n\n            storeSessionInfo(\"userName\", newname);\n        }\n\n        function setLoginTarget(target, sessionObject) {\n            if (defPropSupported) {\n                _loginTarget = target;\n            }\n            else {\n                sessionObject.loginTarget = target;\n            }\n        }\n\n        function setServiceURI(url, sessionObject) {\n            if (defPropSupported) {\n                _serviceURI = url;\n            }\n            else {\n                sessionObject.serviceURI = url;\n            }\n            \n            storeSessionInfo(\"serviceURI\", url);\n        }\n\n        function pushCatalogURIs(url, sessionObject) {\n            if (defPropSupported) {\n                _catalogURIs.push(url);\n            }\n            else {\n                sessionObject.catalogURIs.push(url);\n            }\n        }\n\n        function pushService(serviceObject, sessionObject) {\n            if (defPropSupported) {\n                _services.push(serviceObject);\n            }\n            else {\n                sessionObject.services.push(serviceObject);\n            }\n        }\n\n        function findService(serviceName) {\n            for (var prop in _services) {\n                var srv = _services[prop];\n                if (srv.name === serviceName) {\n                    return srv;\n                }\n            }\n            return null;\n        }\n\n        function setLoginResult(result, sessionObject) {\n            if (defPropSupported) {\n                _loginResult = result;\n            } else {\n                sessionObject.loginResult = result;\n            }\n\n            \n            if (result === progress.data.Session.LOGIN_SUCCESS) {\n                storeSessionInfo(\"loginResult\", result);\n            } else {\n                // Let's clear sessionStorage since we logged out or something went bad!\n                clearAllSessionInfo();\n            }\n        }\n\n        function setLoginHttpStatus(status, sessionObject) {\n            if (defPropSupported) {\n                _loginHttpStatus = status;\n            }\n            else {\n                sessionObject.loginHttpStatus = status;\n            }\n\n            storeSessionInfo(\"loginHttpStatus\", status);\n        }\n\n        function setClientContextIDfromXHR(xhr, sessionObject) {\n            if (xhr) {\n                setClientContextID(getResponseHeaderNoError(xhr, \"X-CLIENT-CONTEXT-ID\"), sessionObject);\n            }\n        }\n\n        function setClientContextID(ccid, sessionObject) {\n            if (defPropSupported) {\n                _clientContextId = ccid;\n            }\n            else {\n                sessionObject.clientContextId = ccid;\n            }\n                \n            storeSessionInfo(\"clientContextId\", ccid);\n        }\n\n        function setLastSessionXHR(xhr, sessionObject) {\n            if (defPropSupported) {\n                _lastSessionXHR = xhr;\n            }\n            else {\n                sessionObject.lastSessionXHR = xhr;\n            }\n        }\n\n        function setDeviceIsOnline(value) {\n            deviceIsOnline = value;\n\n            storeSessionInfo(\"deviceIsOnline\", value);\n        }\n\n        function setRestApplicationIsOnline(value) {\n            restApplicationIsOnline = value;\n\n            storeSessionInfo(\"restApplicationIsOnline\", value);\n        }\n\n        function setOepingAvailable(value) {\n            oepingAvailable = value;\n\n            storeSessionInfo(\"oepingAvailable\", value);\n        }\n\n        function setPartialPingURI(value) {\n            partialPingURI = value;\n\n            storeSessionInfo(\"partialPingURI\", value);\n        }\n        \n        /*\n            When using CORS, if the client asks for a response header that is not among \n            the headers exposed by the Web application, the user agent may write an error\n            to the console, e.g., \"REFUSED TO GET UNSAFE HEADER\". This function checks for \n            a given response header in a way that will avoid the error message. It does this\n            by requesting all headers and then checking to see whether the desired header\n            is present (it will not be present, even if the server sent it, if the server has not\n            also allowed that header). The function caches the string returned by getAllResponseHeaders\n            by storing it on the xhr that was used in the request. It does the caching in\n            case there is another header to be checked.\n          */\n        function getResponseHeaderNoError(xhr, headerName) {\n            var allHeaders = xhr._pdsResponseHeaders,\n                regExp;\n\n            if (allHeaders === undefined) {\n                allHeaders = xhr.getAllResponseHeaders();\n                if ( allHeaders ) {\n                    xhr._pdsResponseHeaders = allHeaders;\n                }\n                else {\n                    xhr._pdsResponseHeaders = null;\n                }\n            }\n            if ( allHeaders ) {\n                regExp = new RegExp(\"^\" + headerName + \":\", \"m\");\n                if ( allHeaders.match(regExp) ) {\n                    return xhr.getResponseHeader(headerName);\n                }\n            }\n\n            return null;\n        }\n\n        // \"Methods\"\n\n        this._pushJSDOs = function (jsdo) {\n            _jsdos.push(jsdo);\n        };\n\n\n        /* _openRequest  (intended for progress.data library use only)\n         * calls open() for an xhr -- the assumption is that this is an xhr for a JSDO, and we need to add\n         * some session management information for the request, such as user credentials and a session ID if\n         * there is one\n         */\n        this._openRequest = function (xhr, verb, url, async) {\n\n            if (this.loginResult !== progress.data.Session.LOGIN_SUCCESS && this.authenticationModel) {\n                throw new Error(\"Attempted to make server request when there is no active session.\");\n            }\n\n            // if resource url is not absolute, add the REST app url to the front\n            var urlPlusCCID = this._prependAppURL(url);\n\n            // add CCID as JSESSIONID query string to url\n            urlPlusCCID = this._addCCIDtoURL(urlPlusCCID);\n\n            // add time stamp to the url\n            if (progress.data.Session._useTimeStamp) {\n                urlPlusCCID = this._addTimeStampToURL(urlPlusCCID);\n            }\n            \n            this._setXHRCredentials(xhr, verb, urlPlusCCID, this.userName, _password, async);\n            if (this.authenticationModel === progress.data.Session.AUTH_TYPE_FORM) {\n                _addWithCredentialsAndAccept(xhr, \"application/json\");\n            }\n\n            // add CCID header\n            if (this.clientContextId && (this.clientContextId !== \"0\")) {\n                xhr.setRequestHeader(\"X-CLIENT-CONTEXT-ID\", this.clientContextId);\n            }\n            // set X-CLIENT-PROPS header\n            setRequestHeaderFromContextProps(this, xhr);\n            \n            if (typeof this.onOpenRequest === 'function') {\n                var params = {\n                    \"xhr\": xhr,\n                    \"verb\": verb,\n                    \"uri\": urlPlusCCID,\n                    \"async\": async,\n                    \"formPreTest\": false,\n                    \"session\": this\n                };\n                this.onOpenRequest(params);\n                // xhr = params.xhr; //Note that, currently, this would have no effect in the caller.\n            }\n        };\n\n        /* login\n         *\n         */\n\n        // callback used in login to determine whether ping is available on server\n        this.pingTestCallback = function (cbArgs) {\n            var foundOeping = cbArgs.pingResult ? true : false;\n\n            setOepingAvailable(foundOeping);\n        };\n\n        // generic async callback, currently used by login(), addCatalog(), and logout()\n        this._onReadyStateChangeGeneric = function () {\n            var xhr = this;\n            var result;\n            var errorObject;\n            \n            clearTimeout(xhr._requestTimeout); // for the iOS Basic Auth bug\n\n            if (xhr.readyState == 4) {\n                result = null;\n                errorObject = null;\n\n                // initial processing of the response from the Web application\n                if ((typeof xhr.onResponseFn) == 'function') {\n                    try {\n                        result = xhr.onResponseFn(xhr);\n                        // ( note that result will remain null if this is a logout() )\n                    }\n                    catch (e) {\n                        errorObject = e;\n                    }\n                }\n                // handle the results of the processing (e.g., fire any events required)\n                if ((typeof xhr.onResponseProcessedFn) == 'function') {\n                    if (!result) {\n                        result = progress.data.Session.GENERAL_FAILURE;\n                    }\n                    xhr.onResponseProcessedFn(xhr.pdsession, result, errorObject, xhr);\n                }\n            }\n        };\n\n        // store password here until successful login; only then do we store it in the Session object\n        var pwSave = null;\n        // store user name here until successful login; only then do we store it in the Session object\n        var unameSave = null;\n        this.login = function (serviceURI, loginUserName, loginPassword, loginTarget) {\n            var uname,\n                pw,\n                isAsync = false,\n                args = [],\n                deferred,\n                jsdosession,\n                iOSBasicAuthTimeout,\n                uriForRequest;   // \"decorated\" version of serviceURI, used to actually send the request\n\n            pwSave = null;   // in case these are left over from a previous login\n            unameSave = null;\n\n            if (this.loginResult === progress.data.Session.LOGIN_SUCCESS) {\n                throw new Error(\"Attempted to call login() on a Session object that is already logged in.\");\n            }\n\n            if (!defPropSupported) {\n                // this is here on the presumably slim chance that we're running with a\n                // version of JavaScript that doesn't support defineProperty (otherwise\n                // the lower casing will have already happened). When we decide that it's\n                // OK to remove our conditionalization of property definitions, we should\n                // get rid of this whole conditional\n                this.authenticationModel = this.authenticationModel.toLowerCase();\n            }\n\n            if (arguments.length > 0) {\n                if (arguments[0] && typeof(arguments[0]) === 'object') {\n                    if (arguments[0].serviceURI) {\n                        args[0] = arguments[0].serviceURI;\n                        args[1] = arguments[0].userName;\n                        args[2] = arguments[0].password;\n                        args[3] = arguments[0].loginTarget;\n                        args[4] = arguments[0].async;\n                        \n                        /* Special for JSDOSession: if this method was called by a JSDOSession object, \n                            it passes deferred and jsdosession and we need to eventually attach them \n                            to the XHR we use so that the promise created by the JSDOSession will work\n                            correctly\n                        */ \n                        deferred = arguments[0].deferred;\n                        jsdosession = arguments[0].jsdosession;\n                        \n                        iOSBasicAuthTimeout = arguments[0].iOSBasicAuthTimeout;\n                        if ( typeof iOSBasicAuthTimeout === 'undefined' ) {\n                            iOSBasicAuthTimeout = defaultiOSBasicAuthTimeout;\n                        }\n                        else if (iOSBasicAuthTimeout && (typeof iOSBasicAuthTimeout != 'number')) {\n                            throw new Error(progress.data._getMsgText(\"jsdoMSG033\", 'Session', 'login', \n                                'The iOSBasicAuthTimeout argument was invalid.'));\n                        }\n                    }\n                }\n                else {\n                    args = arguments;\n                }\n            }\n\n            if (args.length > 0) {\n                if (args[0]) {\n                    var restURLtemp = args[0];\n\n                    // get rid of trailing '/' because appending service url that starts with '/'\n                    // will cause request failures\n                    if (restURLtemp[restURLtemp.length - 1] === \"/\") {\n                        restURLtemp = restURLtemp.substring(0, restURLtemp.length - 1);\n                    }\n                    setServiceURI(restURLtemp, this);\n                }\n                else {\n                    setLoginResult(progress.data.Session.LOGIN_GENERAL_FAILURE, this);\n                    throw new Error(\"Session.login() is missing the serviceURI argument.\");\n                }\n\n                if (args[1]) {\n                    uname = args[1];\n                }\n\n                if (args[2]) {\n                    pw = args[2];\n                }\n\n                if (args[3]) {\n                    setLoginTarget(args[3], this);\n                }\n\n                if (args[4]) {\n                    if (typeof(args[4]) === 'boolean') {\n                        isAsync = args[4];\n                    }\n                    else {\n                        throw new Error(\"Session.login() was passed an async setting that is not a boolean.\");\n                    }\n                }\n            }\n            else {\n                setLoginResult(progress.data.Session.LOGIN_GENERAL_FAILURE, this);\n                throw new Error(\"Session.login() is missing the serviceURI argument.\");\n            }\n\n            // use these temp cred variables later; if login succeeds, we'll use them to set the\n            // real credentials\n            unameSave = uname;\n            pwSave = pw;\n\n            if (this.authenticationModel === progress.data.Session.AUTH_TYPE_ANON ||\n                this.authenticationModel === progress.data.Session.AUTH_TYPE_FORM) {\n                /* anonymous should NOT have a username and password passed (this is\n                 probably unnecessary because the XHR seems to send the request without\n                 credentials first, then intercept the 401 if there is one and try again,\n                 this time with credentials. Just making sure.\n                 */\n                /* For form authentication, we may as well not send the user name and password\n                 * on this request, since we are just trying to test whether the authentication\n                 *  has already happened and they are therefore irrelevant\n                 */\n                uname = null;\n                pw = null;\n            }\n\n            var xhr = new XMLHttpRequest();\n            xhr.pdsession = this;\n\n            try {\n                uriForRequest = this.serviceURI + this.loginTarget;\n                if (progress.data.Session._useTimeStamp) {\n                    uriForRequest = this._addTimeStampToURL(uriForRequest);\n                }               \n                this._setXHRCredentials(xhr, 'GET', uriForRequest, uname, pw, isAsync);\n\n                xhr.setRequestHeader(\"Cache-Control\", \"no-cache\");\n                xhr.setRequestHeader(\"Pragma\", \"no-cache\");\n                // set X-CLIENT-PROPS header\n                setRequestHeaderFromContextProps(this, xhr);\n                if (this.authenticationModel === progress.data.Session.AUTH_TYPE_FORM) {\n                    _addWithCredentialsAndAccept(xhr, \n                        \"application/json,text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\");\n                }\n\n                xhr._isAsync = isAsync;\n                if (isAsync) {\n                    xhr.onreadystatechange = this._onReadyStateChangeGeneric;\n                    if (this.authenticationModel === progress.data.Session.AUTH_TYPE_FORM) {\n                        xhr.onResponseFn = this._afterFormPretestLogin;\n                    }\n                    else {\n                        xhr.onResponseFn = this._processLoginResult;\n                        xhr.onResponseProcessedFn = this._loginComplete;\n                    }\n                    if (    this.authenticationModel === progress.data.Session.AUTH_TYPE_BASIC \n                         && isUserAgentiOS\n                         && iOSBasicAuthTimeout > 0 ) { \n                        xhr._requestTimeout = setTimeout(  function (){\n                                                        clearTimeout(xhr._requestTimeout);\n                                                        xhr._iosTimeOutExpired = true;\n                                                        xhr.abort();\n                                                    }, \n                                                    iOSBasicAuthTimeout);\n                    }\n                    xhr._jsdosession = jsdosession;  // in case the caller is a JSDOSession\n                    xhr._deferred = deferred;  // in case the caller is a JSDOSession\n                }\n\n                if (typeof this.onOpenRequest === 'function') {\n                    var isFormPreTest = false;\n                    if (this.authenticationModel === progress.data.Session.AUTH_TYPE_FORM) {\n                        isFormPreTest = true;\n                    }\n\n                    //  set this here in case onOpenRequest checks it\n                    setLastSessionXHR(xhr, this);\n                    var params = {\n                        \"xhr\": xhr,\n                        \"verb\": \"GET\",\n                        \"uri\": this.serviceURI + this.loginTarget,\n                        \"async\": false,\n                        \"formPreTest\": isFormPreTest,\n                        \"session\": this\n                    };\n                    this.onOpenRequest(params);\n                    xhr = params.xhr; // just in case it has been changed\n                }\n                setLastSessionXHR(xhr, this);\n                xhr.send(null);\n            }\n            catch (e) {\n                clearTimeout(xhr._requestTimeout);                \n                setLoginHttpStatus(xhr.status, this);\n                setLoginResult(progress.data.Session.LOGIN_GENERAL_FAILURE, this);\n                unameSave = null;\n                pwSave = null;\n                throw e;\n            }\n\n            if (isAsync) {\n                return progress.data.Session.ASYNC_PENDING;\n            }\n            else {\n                setLoginHttpStatus(xhr.status, this);\n                if (this.authenticationModel === progress.data.Session.AUTH_TYPE_FORM) {\n                    return (this._afterFormPretestLogin(xhr) );\n                }\n                else {\n                    return (this._processLoginResult(xhr) );\n                }\n            }\n        };\n\n\n        this._afterFormPretestLogin = function (xhr) {\n            var pdsession = xhr.pdsession;\n            setLoginHttpStatus(xhr.status, xhr.pdsession);\n\n            var formLoginParams = {\n                \"xhr\": xhr,\n                \"pw\": pwSave,\n                \"uname\": unameSave,\n                \"theSession\": pdsession\n            };\n            try {\n                return doFormLogin(formLoginParams);\n            }\n            catch (e) {\n                pwSave = null;\n                unameSave = null;\n                throw e;\n            }\n        };\n\n        /* doFormLogin\n         * This function handles logging in to a service that uses form-based authentication. It's separate\n         * from the main login function because it's long. One of the things it does is examine the\n         * response from an initial attempt to get the login target without credentials (done in the main\n         * login() function) to determine whether the user has already been authenticated. Although a\n         * current OE Mobile Web application (as of 5/30/2013) will return an error if authentication\n         * failed on a form login, previous versions and non-OE servers return a\n         * redirect to a login page and the user agent (browser or native wrapper)\n         * usually then fetches the redirect location and returns it along with a\n         * 200 Success status, when in fcat it was an authentication failure. Hence\n         * the need to analyze the response to try to figure out what we get back.\n         *\n         */\n        function doFormLogin(args) {\n            var xhr = args.xhr;\n            var theSession = args.theSession;\n            var oldXHR;\n\n            // check whether we got the OE REST Form based error response\n            var contentType = null;\n            var needAuth = false;\n            var params = {\n                \"session\": theSession,\n                \"xhr\": xhr,\n                \"statusFromjson\": null\n            };\n\n            contentType = xhr.getResponseHeader(\"Content-Type\");\n\n            if (contentType && contentType.indexOf(\"application/json\") >= 0) {\n                handleJSONLoginResponse(params);\n                if (    !params.statusFromjson \n                     || (params.statusFromjson >= 400 && params.statusFromjson < 500) \n                   )  {\n                    needAuth = true;\n                }\n                else {\n                    // either the response shows that we're already authenticated, or\n                    // there's some error other than an authentication error\n                    setLoginHttpStatus(params.statusFromjson, theSession);\n                }\n            }\n            else {\n                // need to do only 200 for async to work with MWA down\n                if (theSession.loginHttpStatus == 200) {  \n                    if (_gotLoginForm(xhr)) {\n                        needAuth = true;\n                    }\n                    // else we are assuming we truly retrieved the login target and\n                    // therefore we were previously authenticated\n                }\n                // else had an error, just return it\n            }\n\n            if (needAuth) {\n                // create new XHR, because if this is an async call we don't want to\n                // confuse things by using this xhr to send another request while we're\n                // still processing its old request (this function, doFormLogin(), may\n                // have been called from onReadyStateChangeGeneric and it's conceivable\n                // that that function has more code to execute involving this xhr)\n                oldXHR = xhr;\n                xhr = new XMLHttpRequest();\n                args.xhr = xhr;\n                params.xhr = xhr;\n\n                // need to transfer any properties that the Session code stored in the\n                // the xhr that need to persist across the 2 requests made by a our\n                // login implementation for Form auth\n                xhr.pdsession = oldXHR.pdsession;\n                xhr._isAsync = oldXHR._isAsync;\n                xhr._deferred = oldXHR._deferred;  // special for JSDOSession \n                xhr._jsdosession = oldXHR._jsdosession;  // special for JSDOSession \n\n                xhr.open('POST', theSession.serviceURI + \"/static/auth/j_spring_security_check\",xhr._isAsync);\n                xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n                xhr.setRequestHeader(\"Cache-Control\", \"max-age=0\");\n                // set X-CLIENT-PROPS header\n                setRequestHeaderFromContextProps(theSession, xhr);\n\n                _addWithCredentialsAndAccept(xhr, \"application/json\");\n\n                try {\n\n                    // Note: this gives a developer a way to change certain aspects of how we do the \n                    // form-based login, but we will still be assuming that we are going directly to\n                    // j_spring_security_check and including credentials in the body. They really should not\n                    // try to change that.\n                    //\n                    if (typeof theSession.onOpenRequest === 'function') {\n                        var cbparams = {\n                            \"xhr\": xhr,\n                            \"verb\": \"POST\",\n                            \"uri\": theSession.serviceURI + \"/static/auth/j_spring_security_check\",\n                            \"async\": xhr._isAsync,\n                            \"formPreTest\": false,\n                            \"session\": theSession\n                        };\n                        theSession.onOpenRequest(cbparams);\n                        xhr = cbparams.xhr;\n                    }\n\n                    if (xhr._isAsync) {\n                        xhr.onreadystatechange = theSession._onReadyStateChangeGeneric;\n                        xhr.onResponseFn = theSession._afterFormLogin;\n                        xhr.onResponseProcessedFn = theSession._loginComplete;\n                    }\n\n                    // j_username=username&j_password=password&submit=Submit\n                    xhr.send(\"j_username=\" + args.uname + \"&j_password=\" + args.pw + \"&submit=Submit\");\n                }\n                catch (e) {\n                    setLoginResult(progress.data.Session.LOGIN_GENERAL_FAILURE, theSession);\n                    setLoginHttpStatus(xhr.status, theSession);\n                    // null the temporary credentials variables\n                    unameSave = null;\n                    pwSave = null;\n                    throw e;\n                }\n\n            }\n\n            if (xhr._isAsync && !needAuth) {\n                xhr.onResponseProcessedFn = theSession._loginComplete;\n                return theSession._afterFormLogin(xhr);\n            }\n            if (!xhr._isAsync) {\n                return theSession._afterFormLogin(xhr);\n            }\n\n        }\n\n        this._afterFormLogin = function (xhr) {\n            // check what we got\n            var theSession = xhr.pdsession;\n            var params = {\n                \"session\": theSession,\n                \"xhr\": xhr,\n                \"statusFromjson\": null\n            };\n            var contentType = xhr.getResponseHeader(\"Content-Type\");\n\n            if (contentType && contentType.indexOf(\"application/json\") >= 0) {\n                handleJSONLoginResponse(params);\n                if (!params.statusFromjson) {\n                    throw new Error(\n                        \"Internal OpenEdge Mobile client error handling login response. HTTP status: \" + \n                        xhr.status + \".\");\n                }\n                else {\n                    setLoginHttpStatus(params.statusFromjson, theSession);\n                }\n            }\n            else {\n                if (xhr.status === 200) {\n                    // Was the response actually the login failure page or the login page itself (in case\n                    // the appSecurity config file sets the login failure url so the server sends the login\n                    // page again)? If so, call it an error because the credentials apparently failed to be\n                    // authenticated\n                    if (_gotLoginFailure(xhr) || _gotLoginForm(xhr)) {\n                        setLoginHttpStatus(401, theSession);\n                    }\n                    else {\n                        setLoginHttpStatus(xhr.status, theSession);\n                    }\n                }\n            }\n\n            return theSession._processLoginResult(xhr);\n        };\n\n\n        this._processLoginResult = function (xhr) {\n            /* OK, one way or another, by hook or by crook, the Session object's loginHttpStatus\n             * has been set to the value that indicates the real outcome of the\n             * login, after adjusting for form-based authentication and anything\n             * else. At this point, it should be just a matter of examining\n             * this.loginHttpStatus, using it to set this.loginResult, maybe doing\n             * some other work appropriate to the outcome of the login, and returning\n             * this.loginResult.\n             */\n            var pdsession = xhr.pdsession;\n                \n            setLoginHttpStatus(xhr.status, xhr.pdsession);\n\n            if (pdsession.loginHttpStatus === 200) {\n                setLoginResult(progress.data.Session.LOGIN_SUCCESS, pdsession);\n                setRestApplicationIsOnline(true);\n                setUserName(unameSave, pdsession);\n                _password = pwSave;\n                pdsession._saveClientContextId(xhr);\n                storeAllSessionInfo();  // save info to persistent storage \n                \n                var pingTestArgs = {\n                    pingURI: null, async: true, onCompleteFn: null,\n                    fireEventIfOfflineChange: true, onReadyStateFn: pdsession._pingtestOnReadyStateChange\n                };\n                pingTestArgs.pingURI = pdsession._makePingURI();\n                pdsession._sendPing(pingTestArgs);  // see whether the ping feature is available\n            }\n            else {\n                if (pdsession.loginHttpStatus == 401) {\n                    setLoginResult(progress.data.Session.LOGIN_AUTHENTICATION_FAILURE, pdsession);\n                }\n                else {\n                    setLoginResult(progress.data.Session.LOGIN_GENERAL_FAILURE, pdsession);\n                }\n            }\n            setLastSessionXHR(xhr, pdsession);\n            updateContextPropsFromResponse(pdsession, xhr);\n\n            // null the temporary credentials variables\n            unameSave = null;\n            pwSave = null;\n            if (xhr._iosTimeOutExpired) {\n                throw new Error( progress.data._getMsgText(\"jsdoMSG047\", \"login\") );\n            }\n\n            // return loginResult even if it's an async operation -- the async handler\n            // (e.g., onReadyStateChangeGeneric) will just ignore\n            return pdsession.loginResult;\n        };\n\n\n        this._loginComplete = function (pdsession, result, errObj, xhr) {\n            pdsession.trigger(\"afterLogin\", pdsession, result, errObj, xhr);\n        };\n\n\n        /* logout\n         *\n         */\n        this.logout = function (args) {\n            var isAsync = false,\n                errorObject = null,\n                xhr,\n                deferred,\n                jsdosession,\n                params;\n\n            if (this.loginResult !== progress.data.Session.LOGIN_SUCCESS && this.authenticationModel) {\n                throw new Error(\"Attempted to call logout when there is no active session.\");\n            }\n\n            if (typeof(args) === 'object') {\n                isAsync = args.async;\n                if (isAsync && (typeof isAsync !== 'boolean')) {\n                    throw new Error( progress.data._getMsgText(\"jsdoMSG033\", \n                                                               \"Session\", \n                                                               'logout', \n                                                               'The async argument was invalid.'));\n                }\n                /* Special for JSDOSession: if this method was called by a JSDOSession object, it passes\n                    deferred and jsdosession and we need to eventually attach them to the XHR we use \n                    so that the promise created by the JSDOSession will work correctly\n                */ \n                deferred = args.deferred;\n                jsdosession = args.jsdosession;                    \n            }\n\n            xhr = new XMLHttpRequest();\n            xhr.pdsession = this;\n            try {\n                /* logout when auth model is anonymous is a no-op on the server side \n                   (but we need to set _jsdosession and _deferred anyway to amke promise work\n                    if logout was called by a JSDOSession) */\n                xhr._jsdosession = jsdosession;  // in case the caller is a JSDOSession\n                xhr._deferred = deferred;  // in case the caller is a JSDOSession\n                if (this.authenticationModel === progress.data.Session.AUTH_TYPE_FORM ||\n                    this.authenticationModel === progress.data.Session.AUTH_TYPE_BASIC) {\n                    if (isAsync) {\n                        xhr.onreadystatechange = this._onReadyStateChangeGeneric;\n                        xhr.onResponseFn = this._processLogoutResult;\n                        xhr.onResponseProcessedFn = this._logoutComplete;\n                    }\n                    \n                    \n                    xhr.open('GET', this.serviceURI + \"/static/auth/j_spring_security_logout\", isAsync);\n\n                    /* instead of calling _addWithCredentialsAndAccept, we code the withCredentials\n                     * and setRequestHeader inline so we can do it slightly differently. That\n                     * function deliberately sets the request header inside the try so we don't\n                     * run into a FireFox oddity that would give us a successful login and then\n                     * a failure on getCatalog (see the comment on that function). On logout,\n                     * however, we don't care -- just send the Accept header so we can get a 200\n                     * response\n                     */\n                    try {\n                        xhr.withCredentials = true;\n                    }\n                    catch (e) {\n                    }\n\n                    xhr.setRequestHeader(\"Accept\", \"application/json\");\n                    \n                    // set X-CLIENT-PROPS header\n                    setRequestHeaderFromContextProps(this, xhr);\n\n                    if (typeof this.onOpenRequest === 'function') {\n                        setLastSessionXHR(xhr, this);\n                        params = {\n                            \"xhr\": xhr,\n                            \"verb\": \"GET\",\n                            \"uri\": this.serviceURI + \"/static/auth/j_spring_security_logout\",\n                            \"async\": false,\n                            \"formPreTest\": false,\n                            \"session\": this\n                        };\n                        this.onOpenRequest(params);\n                        xhr = params.xhr;\n                    }\n\n                    setLastSessionXHR(xhr, this);\n                    xhr.send();\n                }\n                else {\n                    xhr._anonymousLogoutOK = true;\n                }\n            }\n            catch (e) {\n                this._reinitializeAfterLogout(this, false);\n                throw e;\n            }\n\n            if (!isAsync) {\n                try {\n                    this._processLogoutResult(xhr);\n                }\n                catch (e) {\n                    throw e;\n                }\n            }\n\n            if (isAsync && this.authenticationModel === progress.data.Session.AUTH_TYPE_ANON) {\n                // fake async for Anonymous -- fire afterLogout event\n                try {\n                    this._processLogoutResult(xhr);\n                }\n                catch (e) {\n                    errorObject = e;\n                }\n                this._logoutComplete(this, null, errorObject, xhr);\n            }\n\n        };\n\n        this._logoutComplete = function (pdsession, result, errorObject, xhr) {\n            // ignore result, it doesn't apply to logout -- is probably null or GENERAL_FAILURE\n            // we include it so onReadyStateChangeGeneric calls this correctly\n            pdsession.trigger(\"afterLogout\", pdsession, errorObject, xhr);\n        };\n\n        this._processLogoutResult = function (xhr) {\n            var logoutSucceeded;\n            var pdsession = xhr.pdsession;\n            var basicStatusOK = false;\n\n            if (xhr._anonymousLogoutOK) {\n                logoutSucceeded = true;\n            }\n            else if (xhr.status !== 200) {\n                /* Determine whether an error returned from the server is really an error\n                 */\n                if (pdsession.authenticationModel === progress.data.Session.AUTH_TYPE_BASIC) {\n                    /* If the Auth model is Basic, we probably got back a 404 Not found.\n                     * But that's OK, because logout from Basic is meaningless on the\n                     * server side unless it happens to be stateful, which is the only\n                     * reason we even try calling j_spring_security_logout\n                     */\n                    if (xhr.status === 404) {\n                        logoutSucceeded = true;\n                    }\n                    else {\n                        logoutSucceeded = false;\n                        throw new Error(\"Error logging out, HTTP status = \" + xhr.status);\n                    }\n                }\n                else {\n                    // for Form auth, any error on logout is an error\n                    logoutSucceeded = false;\n\n            // page refresh - we should call _reinitializeAfterLogout, or do something, so that \n            // caller can try logging in again (this is not a problem specific to page refresh,\n            // but the case of a page refresh after a server has gone down emphasizes it)\n\n                    throw new Error(\"Error logging out, HTTP status = \" + xhr.status);                    \n                }\n            }\n            else {\n                logoutSucceeded = true;\n            }\n\n            updateContextPropsFromResponse(pdsession, xhr);\n            pdsession._reinitializeAfterLogout(pdsession, logoutSucceeded);\n        };\n\n        this._reinitializeAfterLogout = function (pdsession, success) {\n            setLoginResult(null, pdsession);\n            setLoginHttpStatus(null, pdsession);\n            setClientContextID(null, pdsession);\n            setUserName(null, pdsession);\n            _password = null;\n\n            if (success) {\n                setRestApplicationIsOnline(false);\n                setOepingAvailable(false);\n                setPartialPingURI(defaultPartialPingURI);\n                setLastSessionXHR(null, pdsession);\n                clearTimeout(_timeoutID);   //  stop autopinging \n            }\n        };\n\n\n        /* addCatalog\n         *\n         */\n        this.addCatalog = function () {\n            var catalogURI,\n                catalogUserName,\n                catalogPassword,\n                isAsync = false,\n                xhr,\n                deferred,\n                jsdosession,\n                iOSBasicAuthTimeout,\n                catalogIndex;\n\n            // check whether the args were passed in a single object. If so, copy them\n            // to the named arguments and a variable\n            if (arguments.length > 0) {\n                if (typeof(arguments[0]) === 'object') {\n                    \n                    // check whether OK to get catalog if offline\n                    if ( !arguments[0].offlineAddCatalog) {\n                        if (this.loginResult !== \n                              progress.data.Session.LOGIN_SUCCESS && this.authenticationModel) {\n                            throw new Error(\"Attempted to call addCatalog when there is no active session.\");\n                        }\n                    }\n                        \n                    catalogURI = arguments[0].catalogURI;\n                    if (!catalogURI || (typeof catalogURI != 'string')) {\n                        throw new Error(progress.data._getMsgText(\"jsdoMSG033\", 'Session', 'addCatalog', \n                                                    'The catalogURI argument was missing or invalid.'));\n                    }\n                    catalogUserName = arguments[0].userName;\n                    if (catalogUserName && (typeof catalogUserName != 'string')) {\n                        throw new Error(progress.data._getMsgText(\"jsdoMSG033\", 'Session', 'addCatalog', \n                            'The catalogUserName argument was invalid.'));\n                    }\n                    catalogPassword = arguments[0].password;\n                    if (catalogPassword && (typeof catalogPassword != 'string')) {\n                        throw new Error(progress.data._getMsgText(\"jsdoMSG033\", 'Session', 'addCatalog', \n                            'The catalogPassword argument was invalid.'));\n                    }\n                    isAsync = arguments[0].async;\n                    if (isAsync && (typeof isAsync != 'boolean')) {\n                        throw new Error(progress.data._getMsgText(\"jsdoMSG033\", 'Session', 'addCatalog', \n                            'The async argument was invalid.'));\n                    }\n                    iOSBasicAuthTimeout = arguments[0].iOSBasicAuthTimeout;\n                    if ( typeof iOSBasicAuthTimeout == 'undefined' ) {\n                        iOSBasicAuthTimeout = defaultiOSBasicAuthTimeout;\n                    }\n                    else if (iOSBasicAuthTimeout && (typeof iOSBasicAuthTimeout != 'number')) {\n                        throw new Error(progress.data._getMsgText(\"jsdoMSG033\", 'Session', 'addCatalog', \n                            'The iOSBasicAuthTimeout argument was invalid.'));\n                    }\n                    \n                    /* Special for JSDOSession: if this method was called by a JSDOSession object, it passes\n                        deferred, jsdosession, and catalogIndex and we need to eventually attach them to the \n                        XHR we use so that the promise created by the JSDOSession will work correctly\n                    */ \n                    deferred = arguments[0].deferred;\n                    jsdosession = arguments[0].jsdosession;\n                    catalogIndex = arguments[0].catalogIndex;\n                }\n                else {\n                    catalogURI = arguments[0];\n                    if (typeof catalogURI != 'string') {\n                      throw new Error(\"First argument to Session.addCatalog must be the URL of the catalog.\");\n                    }\n                    catalogUserName = arguments[1];\n                    if (catalogUserName && (typeof catalogUserName != 'string')) {\n                      throw new Error(\"Second argument to Session.addCatalog must be a user name string.\");\n                    }\n                    catalogPassword = arguments[2];\n                    if (catalogPassword && (typeof catalogPassword != 'string')) {\n                      throw new Error(\"Third argument to Session.addCatalog must be a password string.\");\n                    }\n                }\n            }\n            else {\n                throw new Error(\"Session.addCatalog is missing its first argument, the URL of the catalog.\");\n            }\n\n            if (!catalogUserName) {\n                catalogUserName = this.userName;\n            }\n\n            if (!catalogPassword) {\n                catalogPassword = _password;\n            }\n\n            xhr = new XMLHttpRequest();\n            xhr.pdsession = this;\n            xhr._catalogURI = catalogURI;\n\n            // for now we don't support multiple version of the catalog across sessions\n            if (progress.data.ServicesManager.getSession(catalogURI) !== undefined) {\n                if (isAsync) {\n                    /*\n                        Attempt to get the event to fire AFTER this call returns ASYNC_PENDING\n                        (and if the method was called from a JSDOSession, create an xhr to communicate \n                         information related to promises back to its afterAddCatalog handler). Note that \n                         the xhr is never used to make a request, it just carries data in the way \n                         expected by the handler)\n                     */\n                    // in case the caller is a JSDOSession \n                    xhr._jsdosession = jsdosession;\n                    xhr._deferred = deferred;\n                    xhr._catalogIndex = catalogIndex;\n                    \n                    setTimeout(this._addCatalogComplete, 10, this, \n                        progress.data.Session.CATALOG_ALREADY_LOADED, null, xhr );\n                    return progress.data.Session.ASYNC_PENDING;\n                }\n                return progress.data.Session.CATALOG_ALREADY_LOADED;\n            }\n\n            this._setXHRCredentials(xhr, 'GET', catalogURI, catalogUserName, catalogPassword, isAsync);\n            // Note that we are not adding the CCID to the URL or as a header, because the catalog may not\n            // be stored with the REST app and even if it is, the AppServer ID shouldn't be relevant\n\n            /* This is here as much for CORS situations as the possibility that there might be an out of date\n             * cached version of the catalog. The CORS problem happens if you have accessed the catalog\n             * locally and then run an app on a different server that requests the catalog. \n             * Your browser already has the catalog,\n             * but the request used to get it was a non-CORS request and the browser will\n             * raise an error\n             */\n            xhr.setRequestHeader(\"Cache-Control\", \"no-cache\");\n            xhr.setRequestHeader(\"Pragma\", \"no-cache\");\n            // set X-CLIENT-PROPS header\n            setRequestHeaderFromContextProps(this, xhr);\n            if (this.authenticationModel === progress.data.Session.AUTH_TYPE_FORM) {\n                _addWithCredentialsAndAccept(xhr, \"application/json\");\n            }\n\n            if (isAsync) {\n                xhr.onreadystatechange = this._onReadyStateChangeGeneric;\n                xhr.onResponseFn = this._processAddCatalogResult;\n                xhr.onResponseProcessedFn = this._addCatalogComplete;\n                \n                if (    this.authenticationModel === progress.data.Session.AUTH_TYPE_BASIC\n                     && isUserAgentiOS\n                     && iOSBasicAuthTimeout ) { \n                    xhr._requestTimeout = setTimeout(  function (){\n                                                    clearTimeout(xhr._requestTimeout);\n                                                    xhr._iosTimeOutExpired = true;\n                                                    xhr.abort();\n                                                }, \n                                                iOSBasicAuthTimeout);\n                }                \n                \n                // in case the caller is a JSDOSession\n                xhr._jsdosession = jsdosession;\n                xhr._deferred = deferred;  \n                xhr._catalogIndex = catalogIndex;\n            }\n\n            try {\n                if (typeof this.onOpenRequest === 'function') {\n                    setLastSessionXHR(xhr, this);\n                    var params = {\n                        \"xhr\": xhr,\n                        \"verb\": \"GET\",\n                        \"uri\": catalogURI,\n                        \"async\": false,\n                        \"formPreTest\": false,\n                        \"session\": this\n                    };\n                    this.onOpenRequest(params);\n                    xhr = params.xhr;\n                }\n\n                setLastSessionXHR(xhr, this);\n                xhr.send(null);\n            }\n            catch (e) {\n                throw new Error(\"Error retrieving catalog '\" + catalogURI + \"'.\\n\" + e.message);\n            }\n            if (isAsync) {\n                return progress.data.Session.ASYNC_PENDING;\n            }\n            else {\n                return this._processAddCatalogResult(xhr);\n            }\n        };\n\n        this._processAddCatalogResult = function (xhr) {\n            var _catalogHttpStatus = xhr.status;\n            var theSession = xhr.pdsession;\n            var servicedata;\n            var catalogURI = xhr._catalogURI,\n                serviceURL;\n\n            setLastSessionXHR(xhr, theSession);\n            updateContextPropsFromResponse(theSession, xhr);\n            \n            if ((_catalogHttpStatus == 200) || (_catalogHttpStatus === 0) && xhr.responseText) {\n                servicedata = theSession._parseCatalog(xhr);\n                try {\n                    progress.data.ServicesManager.addCatalog(servicedata, theSession);\n                }\n                catch (e) {\n                    if (progress.data.ServicesManager.getSession(catalogURI) !== undefined) {\n                        /* this failed because the catalog had already been loaded, but the code\n                           in addCatalog did not catch that, probably because we are executing\n                           the JSDOSession addCatalog with multiple catalogURIs passed, and 2 \n                           are the same\n                         */\n                        return progress.data.Session.CATALOG_ALREADY_LOADED;\n                    }\n                    // different catalogs, with same resource name\n                    throw new Error(\"Error processing catalog '\" + catalogURI + \"'. \\n\" + e.message);\n                }\n                // create a mobile service object and add it to the Session's array of same\n                for (var i = 0; i < servicedata.length; i++) {\n                    serviceURL = theSession._prependAppURL(servicedata[i].address);\n                    pushService(new progress.data.MobileServiceObject(\n                            {\n                                name: servicedata[i].name,\n                                uri: serviceURL\n                            }),\n                        theSession);\n\n                    if (servicedata[i].settings\n                        && servicedata[i].settings.useXClientProps\n                        && !theSession.xClientProps) {\n                        console.warn(\"Catalog warning: Service settings property 'useXClientProps' \" +\n                            \"is true but 'xClientProps' property has not been set.\");\n                    }\n                }\n                pushCatalogURIs(catalogURI, theSession);\n                progress.data.ServicesManager.addSession(catalogURI, theSession);\n            }\n            else if (_catalogHttpStatus == 401) {\n                return progress.data.Session.AUTHENTICATION_FAILURE;\n            }\n            else if (xhr._iosTimeOutExpired) { \n                throw new Error( progress.data._getMsgText(\"jsdoMSG047\", \"addCatalog\") );\n            }\n            else {\n                throw new Error(\"Error retrieving catalog '\" + catalogURI + \n                    \"'. Http status: \" + _catalogHttpStatus + \".\");\n            }\n\n            return progress.data.Session.SUCCESS;\n        };\n\n        this._addCatalogComplete = function (pdsession, result, errObj, xhr) {\n            pdsession.trigger(\"afterAddCatalog\", pdsession, result, errObj, xhr);\n        };\n\n\n        /*\n         *  ping -- determine whether the Mobile Web Application that the Session object represents\n         *  is available, which includes determining whether its associated AppServer is running\n         *  Also determine whether the Mobile services managed by this Session object are available\n         *  (which means simply that they're known to the Mobile Web Application)\n         *  (Implementation note: be sure that this Session object's \"connected\"\n         *  property retains its current value until the end of this function, where\n         *  it gets updated, if necessary, after calling _isOnlineStateChange\n         *\n         *  Signatures :\n         *  @param arg\n         *  There are 2 signatures --\n         *   -  no argument -- do an async ping of the Session's Mobile Web application. The only effect\n         *                     of the ping will be firing an offline or an online event, if appropriate\n         *                     The ping function itself will return false to the caller\n         *   -  object argument -- the object's properties provide the input args. They are all\n         *          optional (if for some reason the caller passes an object that has no properties, it's\n         *          the same as passing no argument at all). The properties may be:\n         *            async -- tells whether to execute the ping asynchronously (which is the default)\n         *            onCompleteFn -- if async, this will be called when response returns\n         *            doNotFireEvent -- used internally, controls whether the ping method causes an offline\n         *                 or online event to be fired if there has been a change (the default is that it\n         *                 does, but our Session._checkServiceResponse() sets this to true so that it can\n         *                 control the firing of the event)\n         *            offlineReason -- if present, and if the ping code discovers that teh server is offline,\n         *                 the ping code will set this with its best guess \n         *                 as to the reason the server is offline\n         */\n        this.ping = function (args) {\n            var pingResult = false;\n            var pingArgs = {\n                pingURI: null, async: true, onCompleteFn: null,\n                fireEventIfOfflineChange: true, onReadyStateFn: this._onReadyStateChangePing,\n                offlineReason: null\n            };\n\n            if (this.loginResult !== progress.data.Session.LOGIN_SUCCESS) {\n                throw new Error(\"Attempted to call ping when not logged in.\");\n            }\n            \n            if (args) {\n                if (args.async !== undefined) {\n                    // when we do background pinging (because pingInterval is set),\n                    // we pass in an arg that is just an object that has an async property,\n                    // set to true. This can be expanded to enable other kinds of ping calls\n                    // to be done async (so that application developers can do so, if we decide\n                    // to support that)\n                    pingArgs.async = args.async;\n                }\n\n                if (args.doNotFireEvent !== undefined) {\n                    pingArgs.fireEventIfOfflineChange = !args.doNotFireEvent;\n                }\n\n                if (args.onCompleteFn && (typeof args.onCompleteFn) == 'function') {\n                    pingArgs.onCompleteFn = args.onCompleteFn;\n                }\n                /* Special for JSDOSession: if this method was called by a JSDOSession object, it passes\n                    deferred and jsdosession and we need to eventually attach them to the XHR we use so that\n                    the promise created by the JSDOSession will work correctly\n                */ \n                pingArgs.deferred = args.deferred;\n                pingArgs.jsdosession = args.jsdosession;\n\n            }\n\n\n            /* Ping the Mobile Web Application (this will also determine whether AppServer is available)\n             * Call _processPingResult() if we're synchronous, otherwise the handler for the xhr.send()\n             * will call it\n             */\n            pingArgs.pingURI = myself._makePingURI();\n            myself._sendPing(pingArgs);\n            if (!pingArgs.async) {\n                if (pingArgs.xhr) {\n                    pingResult = myself._processPingResult(pingArgs);\n                    if (args.offlineReason !== undefined) {\n                        args.offlineReason = pingArgs.offlineReason;\n                    }\n                }\n                else {\n                    pingResult = false; // no xhr returned from _sendPing, something must have gone wrong\n                }\n                if ( args.xhr !== undefined ) {\n                    // if it's a sync ping, return the xhr if caller indicates they want it\n                    // (there's almost guaranteed to be one, even if the ping was never sent\n                    // if for some reason there isn't, we give them the null or undefined we ended up with)\n                    args.xhr = pingArgs.xhr;  \n                }\n            }\n            // else it's async, deliberately returning false \n            // so developer not misled into thinking the ping succeeded\n\n            return pingResult;\n        };\n\n\n        // \"protected\" Functions\n\n        /*\n         * given a value of true or false for being online for the Mobile Web Application\n         * managed by this Session object, determine whether that changes the current\n         * state of being offline or online.\n         * Returns true if the input state is a change from the current state\n         *\n         * Signature :\n         * @param isOnline  Required. True to determine whether online is a state change, false to\n         *                  determine whether offline constitutes a state change. Boolean.\n         *\n         */\n        this._isOnlineStateChange = function (isOnline) {\n            var stateChanged = false;\n\n            if (isOnline && !(this.connected)) {\n                stateChanged = true;\n            }\n            else if (!isOnline && ( this.connected )) {\n                stateChanged = true;\n            }\n\n            return stateChanged;\n        };\n\n\n        /*\n         * given information about the response from a request made to a service,\n         * do the following:\n         *\n         * determine whether the online status of the Session has changed, and\n         * set the Session's Connected property accordingly\n         * if the Session's online status has changed, fire the appropriate event\n         *\n         * Signature :\n         * @param xhr      Required. The xhr that was used to make the request. Object\n         * @param success  Required. True if caller regards the request as having succeeded. Boolean\n         * @param request  Required. The JSDO request object created for making the request. Object.\n         *\n         */\n        this._checkServiceResponse = function (xhr, success, request) {\n            var offlineReason = null,\n                wasOnline = this.connected;\n            updateContextPropsFromResponse(this, xhr);\n\n            /* first of all, if there are no subscriptions to offline or online events, don't\n             * bother -- we don't want to run the risk of messing things up by calling ping\n             * if the app developer isn't interested (especially because that may mean that\n             * ping isn't enabled on the server, anyway)\n             */\n            if (!this._events) {\n                return;\n            }\n            var offlineObservers = this._events[\"offline\"] || [];\n            var onlineObservers = this._events[\"online\"] || [];\n            if ((offlineObservers.length === 0) && (onlineObservers.length === 0)) {\n                return;\n            }\n\n            /* even though this function gets called as a result of trying to\n             * contact the server, don't bother to change anything if we already\n             * know that the device (or user agent, or client machine) is offline.\n             * We can't assume anything about the state of the server if we can't\n             * even get to the internet from the client\n             */\n\n            // if the call to the server was a success, we will assume we are online,\n            // both server and device\n            if (success) {\n                setRestApplicationIsOnline(true);\n                setDeviceIsOnline(true);  // presumably this is true (probably was already true)\n            }\n            else {\n                /* Request failed, determine whether it's because server is offline\n                 * Do this even if the Session was already in an offline state, because\n                 * we need to determine whether the failure was due to still being\n                 * offline, or whether it's now possible to communicate with the\n                 * server but the problem was something else.\n                 */\n\n                if (deviceIsOnline) {\n                    /* ping the server to get better information on whether this is an offline case\n                     * NB: synchronous ping for simplicity, maybe should consider async so as not\n                     * to potentially freeze UI\n                     */\n                    var localPingArgs = {\n                        doNotFireEvent: true,  // do in this fn so we have the request\n                        offlineReason: null,\n                        async: false\n                    };\n                    if (!(myself.ping(localPingArgs) )) {\n                        offlineReason = localPingArgs.offlineReason;\n                        setRestApplicationIsOnline(false);\n                    }\n                    else {\n                        // ping returned true, so even though the original request failed,\n                        // we are online and the failure must have been due to something else\n                        setRestApplicationIsOnline(true);\n                    }\n                }\n                // else deviceIsOnline was already false, so the offline event should already have\n                // been fired for that reason and there is no need to do anything else\n            }\n\n            if (wasOnline && !this.connected) {\n                this.trigger(\"offline\", this, offlineReason, request);\n            }\n            else if (!wasOnline && this.connected) {\n                this.trigger(\"online\", this, request);\n            }\n        };\n\n        /* Decide whether, on the basis of information returned by a server request, the\n         * Mobile Web Application managed by this Session object is online, where online\n         * means that the ping response was a 200 and, IF the body of the response contains\n         * JSON with an AppServerStatus property, that AppServerStatus Status property has\n         * a pingStatus property set to true\n         *     i.e., the body has an AppServerStatus.PingStatus set to true\n         * (if the body doesn't contain JSON with an AppServerStatus, we use just the HTTP\n         * response status code to decide)\n         * \n         * Returns:  true if the response meets the above conditions, false if it doesn't\n         *   \n         * Parameters:\n         *   args, with properties:\n         *      xhr - the XMLHttpRequest used to make the request\n         *      offlineReason - if the function determines that the app is offline,\n         *                      it sets offlineReason to the reason for that decision,\n         *                      for the use of the caller\n         *      fireEventIfOfflineChange - if true, the function fires an offline or online\n         *                      event if there has been a change (i.e., the online state determined \n         *                      by the function is different from what it had been when the function\n         *                      began executing)\n         *      usingOepingFormat - OPTIONAL. The function's default assumption is that the value\n         *                      of the session's internal oepingAvailable variable indicates whether the\n         *                      the response body will be in the format used by the OpenEdge oeping service.\n         *                      A caller can override this assumption by using this property to true or false.\n         *                     (the isAuthorized code sets this to false because it doesn't use oeping \n         *                     but does call this function)\n         */\n        this._processPingResult = function (args) {\n            var xhr = args.xhr,\n                pingResponseJSON,\n                appServerStatus = null,\n                wasOnline = this.connected,\n                connectedBeforeCallback,\n                assumeOepingFormat;\n                \n            if (args.hasOwnProperty('usingOepingFormat')) {\n                assumeOepingFormat = args.usingOepingFormat;\n            } else {\n                assumeOepingFormat = oepingAvailable;\n            }\n\n\n            /* first determine whether the Web server and the Mobile Web Application (MWA)\n             * are available\n             */\n            if (xhr.status >= 200 && xhr.status < 300) {\n                updateContextPropsFromResponse(this, xhr);\n                if (assumeOepingFormat) {\n                    try {\n                        pingResponseJSON = JSON.parse(xhr.responseText);\n                        appServerStatus = pingResponseJSON.AppServerStatus;\n                    }\n                    catch (e) {\n                        /* We got a successful response from calling our ping URI, but it\n                         * didn't return valid JSON. If we think that the oeping REST API\n                         * is available on the server (so we should have gotten valid\n                         * json), log this to the console.\n                         *\n                         */\n                        console.error(\"Unable to parse ping response.\");\n                    }\n                }\n                setRestApplicationIsOnline(true);\n            }\n            else {\n                if (deviceIsOnline) {\n                    if (xhr.status === 0) {\n                        args.offlineReason = progress.data.Session.SERVER_OFFLINE;\n                        setRestApplicationIsOnline(false);\n                    }\n                    else if ((xhr.status === 404) || (xhr.status === 410)) {\n                        /* if we get a 404, it means the Web server is up, but it\n                         * can't find the resource we requested (either _oeping or\n                         * the login target), therefore the Mobile Web application\n                         * must be unavailable (410 is Gone)\n                         */\n                        args.offlineReason = progress.data.Session.WEB_APPLICATION_OFFLINE;\n                        setRestApplicationIsOnline(false);\n                    }\n                    else {\n                        /* There's some error, but we can't say for sure that it's because\n                         * the Web application is unavailable. May be an authentication problem,\n                         * internal server error, or for some reason our ping request was\n                         * invalid (unlikely to happen if it previously succeeded).\n                         * In particular, if the server uses Form authentication, it\n                         * may have come back online but now the session id\n                         * is no longer valid.\n                         */\n                        setRestApplicationIsOnline(true);\n                    }\n                }\n                else {\n                    args.offlineReason = progress.data.Session.DEVICE_OFFLINE;\n                }\n            }\n\n            // is the AppServer online? appServerStatus will be non-null only\n            // if the ping request returned 200, meaning the other things are OK\n            // (connection to server, Tomcat, Mobile Web application)\n            if (appServerStatus) {\n                if (appServerStatus.PingStatus === \"false\") {\n                    args.offlineReason = progress.data.Session.APPSERVER_OFFLINE;\n                    setRestApplicationIsOnline(false);\n                }\n                else {\n                    setRestApplicationIsOnline(true);\n                }\n            }\n\n            /* We call any async ping callback handler and then, after that returns, fire an\n               offline or online event if necessary. \n               When deciding whether to fire an event, the responsibility of this _processPingResult()\n               function is to decide about the event on the basis of the data returned from the ping\n               that it is currently processing. Therefore, since the ping callback that is just about\n               to be called could change the outcome of the event decision (for example, if the handler\n               calls logout(), thus setting Session.connected to false)), we save the current value of\n               Session.connected and use that saved value to decide about the event after the ping \n               handler returns.\n               (If the application programmer wants to get an event fired as a result of something\n               that happens in the ping handler, they should call a ping() *after* that. \n             */\n            connectedBeforeCallback = this.connected;\n\n            if ((typeof xhr.onCompleteFn) == 'function') {\n                xhr.onCompleteFn({\n                    pingResult: this.connected,\n                    xhr: xhr,\n                    offlineReason: args.offlineReason\n                });\n            }\n\n            // decide whether to fire an event, and if so do it\n            if (args.fireEventIfOfflineChange) {\n                if (wasOnline && !connectedBeforeCallback) { \n                    myself.trigger(\"offline\", myself, args.offlineReason, null);\n                }\n                else if (!wasOnline && connectedBeforeCallback) {\n                    myself.trigger(\"online\", myself, null);\n                }\n            }\n\n            return this.connected;\n        };\n\n\n        this._onReadyStateChangePing = function () {\n            var xhr = this;\n            var args;\n\n            if (xhr.readyState == 4) {\n                args = {\n                    xhr: xhr,\n                    fireEventIfOfflineChange: true,\n                    offlineReason: null\n                };\n                myself._processPingResult(args);\n                if (_pingInterval > 0) {\n                    _timeoutID = setTimeout(myself._autoping, _pingInterval);\n                }\n            }\n        };\n\n        this._pingtestOnReadyStateChange = function () {\n            var xhr = this;\n\n            if (xhr.readyState == 4) {\n                var foundOeping = false;\n                if (xhr.status >= 200 && xhr.status < 300) {\n                    foundOeping = true;\n                }\n                else {\n                    setPartialPingURI(myself.loginTarget);\n                    console.warn(\"Default ping target not available, will use loginTarget instead.\");\n                }\n                setOepingAvailable(foundOeping);\n                \n                // If we're here, we've just logged in. If pingInterval has been set, we need\n                // to start autopinging\n                if (_pingInterval > 0) {\n                    _timeoutID = setTimeout(myself._autoping, _pingInterval);\n                }\n            }\n        };\n\n        /*\n         * args: pingURI\n         *       async\n         *       onCompleteFn     used only if async is true\n         *\n         *  (deliberately not catching thrown error)\n         */\n        this._sendPing = function (args) {\n            var xhr = new XMLHttpRequest();\n            try {\n                this._setXHRCredentials(xhr, \"GET\", args.pingURI, this.userName, _password, args.async);\n                if (args.async) {\n                    xhr.onreadystatechange = args.onReadyStateFn;\n                    xhr.onCompleteFn = args.onCompleteFn;\n                    xhr._jsdosession = args.jsdosession;  // in case the caller is a JSDOSession\n                    xhr._deferred = args.deferred;  // in case the caller is a JSDOSession\n                }\n                xhr.setRequestHeader(\"Cache-Control\", \"no-cache\");\n                xhr.setRequestHeader(\"Pragma\", \"no-cache\");\n                // set X-CLIENT-PROPS header\n                setRequestHeaderFromContextProps(this, xhr);\n                if (this.authenticationModel === progress.data.Session.AUTH_TYPE_FORM) {\n                    _addWithCredentialsAndAccept(xhr, \n                        \"application/json,text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\");\n                }\n                xhr.send(null);\n            }\n            catch (e) {\n                args.error = e;\n            }\n            \n            args.xhr = xhr;\n        };\n\n        this._makePingURI = function () {\n            var pingURI = this.serviceURI + partialPingURI;\n            // had caching problem with Firefox in its offline mode\n            if (progress.data.Session._useTimeStamp) {\n                pingURI = this._addTimeStampToURL(pingURI);  \n            }\n            return pingURI;\n        };\n\n\n        /*\n         *  autoping -- callback\n         */\n        this._autoping = function () {\n            myself.ping({async: true});\n        };\n\n\n        /*   _setXHRCredentials  (intended for progress.data library use only)\n         *  set credentials as needed, both via the xhr's open method and setting the\n         *  Authorization header directly\n         */\n        this._setXHRCredentials = function (xhr, verb, uri, userName, password, async) {\n\n            // note that we do not set credentials if userName is null. \n            // Null userName indicates that the developer is depending on the browser to\n            // get and manage the credentials, and we need to make sure we don't interfere with that\n            if (userName\n                && this.authenticationModel === progress.data.Session.AUTH_TYPE_BASIC) {\n\n                // See the comment at the definition of the canPassCredentialsToOpen() function\n                // for why we pass credentials to open() in some cases but not others. (If we're not using\n                // Basic auth, we never pass credentials)\n                if (canPassCredentialsToOpen()) {\n                    xhr.open(verb, uri, async, userName, password);\n                }\n                else {\n                    xhr.open(verb, uri, async);\n                }\n                \n                // set Authorization header\n                var auth = _make_basic_auth(userName, password);\n                xhr.setRequestHeader('Authorization', auth);\n            }\n            else {\n                xhr.open(verb, uri, async);\n            }\n        };\n\n        /*   _addCCIDtoURL  (intended for progress.data library use only)\n         *  Add the Client Context ID being used by a session on an OE REST application, if we have\n         *  previously stored one from a response from the server\n         */\n        this._addCCIDtoURL = function (url) {\n            var urlPart1,\n                urlPart2,\n                jsessionidStr,\n                index;\n                \n            if (this.clientContextId && (this.clientContextId !== \"0\")) {\n                // Should we test protocol, \n                // host and port in addition to path to ensure that jsessionid is only sent\n                // when request applies to the REST app (it might not be if the catalog is somewhere else)\n                if (url.substring(0, this.serviceURI.length) == this.serviceURI) {\n                    jsessionidStr = \";\" + \"JSESSIONID=\" + this.clientContextId;\n                    index = url.indexOf('?');\n                    if (index == -1) {\n                        url += jsessionidStr;  // just append the jsessionid path parameter to the path\n                    }\n                    else {\n                        // insert jsessionid path parameter before the first query parameter\n                        urlPart1 = url.substring(0, index);\n                        urlPart2 = url.substring(index);\n                        url = urlPart1 + jsessionidStr + urlPart2;\n                    }\n                }\n            }\n            return url;\n        };\n\n        var SEQ_MAX_VALUE = 999999999999999;\n        /* 15 - 9 */\n        var _tsseq = SEQ_MAX_VALUE;\n        /* Initialized to SEQ_MAX_VALUE to initialize values. */\n        var _tsprefix1 = 0;\n        var _tsprefix2 = 0;\n\n        this._getNextTimeStamp = function () {\n            var seq = ++_tsseq;\n            if (seq >= SEQ_MAX_VALUE) {\n                _tsseq = seq = 1;\n                var t = Math.floor(( Date.now ? Date.now() : (new Date().getTime())) / 10000);\n                if (_tsprefix1 == t) {\n                    _tsprefix2++;\n                    if (_tsprefix2 >= SEQ_MAX_VALUE) {\n                        _tsprefix2 = 1;\n                    }\n                }\n                else {\n                    _tsprefix1 = t;\n                    Math.random(); // Ignore call to random\n                    _tsprefix2 = Math.round(Math.random() * 10000000000);\n                }\n            }\n\n            return _tsprefix1 + \"-\" + _tsprefix2 + \"-\" + seq;\n        };\n\n        /*\n         * _addTimeStampToURL (intended for progress.data library use only)\n         * Add a time stamp to the a URL to prevent caching of the request.\n         * Set progress.data.Session._useTimeStamp = false to turn off.\n         */\n        this._addTimeStampToURL = function (url) {\n            var timeStamp = \"_ts=\" + this._getNextTimeStamp();\n            url += ((url.indexOf('?') == -1) ? \"?\" : \"&\") + timeStamp;\n            return url;\n        };\n\n        /*   _saveClientContextId  (intended for progress.data library use only)\n         *  If the CCID hasn't been set for the session yet, check the xhr for it and store it.\n         *  (If it has been set, assume that the existing one is correct and do nothing. We could\n         *   enhance this function by checking to see whether the new one matches the existing one.\n         *  Not sure what to do if that's the case -- overwrite the old one? ignore the new one?\n         *   Should at least log a warning or error\n         */\n        this._saveClientContextId = function (xhr) {\n            // do this unconditionally (even if there is already a client-context-id), because\n            // if basic authentication is set up such that it uses sessions, and cookies are disabled,\n            // the server will generate a different session on each request and the X-CLIENT-CONTEXT-ID\n            // will therefore be different\n            setClientContextIDfromXHR(xhr, this);\n        };\n\n        this._parseCatalog = function (xhr) {\n            var jsonObject;\n            var catalogdata;\n\n            try {\n                jsonObject = JSON.parse(xhr.responseText);\n                catalogdata = jsonObject.services;\n            }\n            catch (e) {\n                console.error(\"Unable to parse response. Make sure catalog has correct format.\");\n                catalogdata = null;\n            }\n\n            return catalogdata;\n        };\n\n        /* _prependAppURL\n         * Prepends the URL of the Web application \n         * (the 1st parameter passed to login, stored in this.serviceURI)\n         * to whatever string is passed in. If the string passed in is an absolute URL, this function does\n         * nothing except return a copy. This function ensures that the resulting URL has the correct number\n         * of slashes between the web app url and the string passed in (currently that means that if what's\n         * passed in has no initial slash, the function adds one)\n         */\n        this._prependAppURL = function (oldURL) {\n            if (!oldURL) {\n                /* If oldURL is null, just return the app URL. (It's not the responsibility of this\n                 * function to decide whether having a null URL is an error. Its only responsibility\n                 * is to prepend the App URL to whatever it gets passed \n                 * (and make sure the result is a valid URL)\n                 */\n                return this.serviceURI;\n            }\n            var newURL = oldURL;\n            var pat = /^https?:\\/\\//i;\n            if (!pat.test(newURL)) {\n                if (newURL.indexOf(\"/\") !== 0) {\n                    newURL = \"/\" + newURL;\n                }\n\n                newURL = this.serviceURI + newURL;\n            }\n            return newURL;\n        };\n\n\n        // Functions\n\n        // Set an XMLHttpRequest object's withCredentials attribute and Accept header,\n        // using a try-catch so that if setting withCredentials throws an error it doesn't\n        // interrupt execution (this is a workaround for the fact that Firefox doesn't\n        // allow you to set withCredentials when you're doing a synchronous operation)\n        // The setting of the Accept header is included here, and happens after the\n        // attempt to set withCredentials, to make the behavior in 11.3.0 match\n        // the behavior in 11.2.1 -- for Firefox, in a CORS situation, login() will\n        // fail. (If we allowed the Accept header to be set, login() would succeed\n        // because of that but addCatalog() would fail because no JSESSIONID would\n        // be sent due to withCredentials not being true)\n        function _addWithCredentialsAndAccept(xhr, acceptString) {\n            try {\n                xhr.withCredentials = true;\n                xhr.setRequestHeader(\"Accept\", acceptString);\n            }\n            catch (e) {\n            }\n        }\n\n\n        // from http://coderseye.com/2007/how-to-do-http-basic-auth-in-ajax.html\n        function _make_basic_auth(user, pw) {\n            var tok = user + ':' + pw;\n//        var hash = base64_encode(tok);\n            var hash = btoa(tok);\n            return \"Basic \" + hash;\n        }\n\n        /* The next 2 functions, _gotLoginForm() and _gotLoginFailure(), attempt to determine whether\n         * a server response consists of\n         * the application's login page or login failure page. Currently (release 11.2), this\n         * is the only way we have of determining that a request made to the server that's\n         * configured for form-based authentication failed due to authentication (i.e.,\n         * authentication hadn't happened before the request and either invalid credentials or\n         * no credentials were sent to the server). That's because, due to the fact that the browser\n         * or native wrapper typically intercepts the redirect involved in an unauthenticated request\n         * to a server that's using using form auth, all we see in the XHR is a success status code\n         * plus whatever page we were redirected to.\n         * In the future, we expect to enhance the OE REST adapter so that it will return a status code\n         * indicating failure for form-based authentication, and we can reimplement these functions so\n         * they check for that code rather than do the simplistic string search.\n         */\n\n        // Determines whether the content of the xhr is the login page. Assumes\n        // use of a convention for testing for login page\n        var loginFormIDString = \"j_spring_security_check\";\n\n        function _gotLoginForm(xhr) {\n            // is the response contained in an xhr actually the login page?\n            return _findStringInResponseHTML(xhr, loginFormIDString);\n        }\n\n        // Determines whether the content of the xhr is the login failure page. Assumes\n        // use of a convention for testing for login fail page\n        var loginFailureIdentificationString = \"login failed\";\n\n        function _gotLoginFailure(xhr) {\n            return _findStringInResponseHTML(xhr, loginFailureIdentificationString);\n        }\n\n        // Does a given xhr contain html and does that html contain a given string?\n        function _findStringInResponseHTML(xhr, searchString) {\n            if (!xhr.responseText) {\n                return false;\n            }\n            var contentType = xhr.getResponseHeader(\"Content-Type\");\n\n            if ((contentType.indexOf(\"text/html\") >= 0) &&\n                (xhr.responseText.indexOf(searchString) >= 0)) {\n                return true;\n            }\n\n            return false;\n        }\n\n        /* sets the statusFromjson property in the params object to indicate\n         * the status of a response from an OE Mobile Web application that has\n         * to do with authentication (the response to a login request, or a\n         * response to a request for a resource where there was an error having\n         * to do with authentication */\n        function handleJSONLoginResponse(params) {\n            // Parse the json in the response to see whether it's the special OE REST service\n            // response. If it is, check the result (which should be consistent with the status from\n            // the xhr)\n            var jsonObject;\n            params.statusFromjson = null;\n            try {\n                jsonObject = JSON.parse(params.xhr.responseText);\n\n                if (jsonObject.status_code !== undefined\n                    && jsonObject.status_txt !== undefined) {\n                    params.statusFromjson = jsonObject.status_code;\n                }\n            }\n            catch (e) {\n                // invalid json\n                setLoginResult(progress.data.Session.LOGIN_GENERAL_FAILURE, params.session);\n                setLoginHttpStatus(xhr.status, params.session);\n                throw new Error(\"Unable to parse login response from server.\");\n            }\n\n        }\n\n        function setRequestHeaderFromContextProps(session, xhr) {\n            if (session.xClientProps) {\n                xhr.setRequestHeader(\"X-CLIENT-PROPS\", session.xClientProps);\n            }\n            else if (session._contextProperties.contextHeader !== undefined) {\n                xhr.setRequestHeader(\"X-CLIENT-PROPS\", session._contextProperties.contextHeader);\n            }\n        }\n        \n        function updateContextPropsFromResponse(session, xhr) {\n            /* determine whether the response contains an X-CLIENT_PROPS header and, if so, \n               set the Session's context\n             */\n            var contextString,\n                context;\n                \n            if (xhr) {\n                contextString = getResponseHeaderNoError(xhr, \"X-CLIENT-PROPS\");\n                if (contextString) {\n                    try {\n                        context = JSON.parse( contextString );\n                    }\n                    catch(e) {\n                    }\n                    if (typeof context === \"object\") {\n                        session._contextProperties.setContext( context );\n                    }\n                    else {\n                        //{1}: A server response included an invalid {2} header.\n                        throw new Error(progress.data._getMsgText(\"jsdoMSG123\", 'Session', 'X-CLIENT-PROPS'));\n                    }\n                }\n                else if (contextString === \"\") {\n                    // If header is \"\", clear the X-CLIENT-PROPS context, \n                    session._contextProperties.setContext( {} );\n                }\n                // if header is absent (getResponseHeader will return null), don't change _contextProperties\n            }\n        }        \n\n        \n        // process constructor options and do other initialization\n        \n        // If a storage key (name property of a JSDOSession) was passed to the constructor, \n        // use it to try to retrieve state data from a previous JSDOSession instance that \n        // had the same name. This code was introduced to handle page refreshes, but could\n        // be used for other purposes.\n        if (typeof (options) === 'object') {\n            var authModel,\n                storedURI,\n                newURI;\n            \n            _storageKey = options._storageKey;\n            if (_storageKey) {\n                if (retrieveSessionInfo(_storageKey)) {\n                    authModel = retrieveSessionInfo(\"authenticationModel\");\n                    uri = retrieveSessionInfo(\"serviceURI\");\n                    newURI = options.serviceURI;\n                    \n                    if (newURI[newURI.length - 1] === \"/\") {\n                        newURI = newURI.substring(0, newURI.length - 1);\n                    }\n                \n                    if ((authModel !== options.authenticationModel) ||\n                        (uri !== newURI)) {\n                            clearAllSessionInfo();\n                    } else {\n                            setSessionInfoFromStorage(_storageKey);\n                    }\n                }\n                // _storageKey is in essence the flag for page refresh; we are not supporting page refresh for Basic\n                // auth, so clear it even if it was passed in. \n                // (But had to set and keep _storageKey until this point so that the above validation of\n                // serviceURI and auth model will be done even in the case where there's a mismatch and\n                // the new auth model is Basic. This statement will go away when we support page refresh with\n                // Basic)\n                if (options.authenticationModel === progress.data.Session.AUTH_TYPE_BASIC) {\n                    _storageKey = undefined;\n                }\n            }\n        }\n        \n    }; // End of Session\n    progress.data.Session._useTimeStamp = true;\n\n// Constants for progress.data.Session\n    if ((typeof Object.defineProperty) == 'function') {\n        Object.defineProperty(progress.data.Session, 'LOGIN_AUTHENTICATION_REQUIRED', {\n            value: 0, enumerable: true\n        });\n        Object.defineProperty(progress.data.Session, 'LOGIN_SUCCESS', {\n            value: 1, enumerable: true\n        });\n        Object.defineProperty(progress.data.Session, 'LOGIN_AUTHENTICATION_FAILURE', {\n            value: 2, enumerable: true\n        });\n        Object.defineProperty(progress.data.Session, 'LOGIN_GENERAL_FAILURE', {\n            value: 3, enumerable: true\n        });\n        Object.defineProperty(progress.data.Session, 'CATALOG_ALREADY_LOADED', {\n            value: 4, enumerable: true\n        });\n        Object.defineProperty(progress.data.Session, 'ASYNC_PENDING', {\n            value: 5, enumerable: true\n        });\n\n        Object.defineProperty(progress.data.Session, 'SUCCESS', {\n            value: 1, enumerable: true\n        });\n        Object.defineProperty(progress.data.Session, 'AUTHENTICATION_FAILURE', {\n            value: 2, enumerable: true\n        });\n        Object.defineProperty(progress.data.Session, 'GENERAL_FAILURE', {\n            value: 3, enumerable: true\n        });\n\n        Object.defineProperty(progress.data.Session, 'AUTH_TYPE_ANON', {\n            value: \"anonymous\", enumerable: true\n        });\n        Object.defineProperty(progress.data.Session, 'AUTH_TYPE_BASIC', {\n            value: \"basic\", enumerable: true\n        });\n        Object.defineProperty(progress.data.Session, 'AUTH_TYPE_FORM', {\n            value: \"form\", enumerable: true\n        });\n\n        Object.defineProperty(progress.data.Session, 'DEVICE_OFFLINE', {\n            value: \"Device is offline\", enumerable: true\n        });\n        Object.defineProperty(progress.data.Session, 'SERVER_OFFLINE', {\n            value: \"Cannot contact server\", enumerable: true\n        });\n        Object.defineProperty(progress.data.Session, 'WEB_APPLICATION_OFFLINE', {\n            value: \"Mobile Web Application is not available\", enumerable: true\n        });\n        Object.defineProperty(progress.data.Session, 'SERVICE_OFFLINE', {\n            value: \"REST web Service is not available\", enumerable: true\n        });\n        Object.defineProperty(progress.data.Session, 'APPSERVER_OFFLINE', {\n            value: \"AppServer is not available\", enumerable: true\n        });\n    }\n    else {\n        progress.data.Session.LOGIN_SUCCESS = 1;\n        progress.data.Session.LOGIN_AUTHENTICATION_FAILURE = 2;\n        progress.data.Session.LOGIN_GENERAL_FAILURE = 3;\n        progress.data.Session.CATALOG_ALREADY_LOADED = 4;\n\n        progress.data.Session.SUCCESS = 1;\n        progress.data.Session.AUTHENTICATION_FAILURE = 2;\n        progress.data.Session.GENERAL_FAILURE = 3;\n\n        progress.data.Session.AUTH_TYPE_ANON = \"anonymous\";\n        progress.data.Session.AUTH_TYPE_BASIC = \"basic\";\n        progress.data.Session.AUTH_TYPE_FORM = \"form\";\n\n        /* deliberately not including the \"offline reasons\" that are defined in the\n         * 1st part of the conditional. We believe that we can be used only in environments where\n         * ECMAScript 5 is supported, so let's put that assumption to the test\n         */\n    }\n\n//setup inheritance for Session -- specifically for incorporating an Observable object \n    progress.data.Session.prototype = new progress.util.Observable();\n    progress.data.Session.prototype.constructor = progress.data.Session;\n    function validateSessionSubscribe(args, evt, listenerData) {\n        listenerData.operation = undefined;\n        var found = false;\n\n        // make sure this event is one that we support\n        for (var i = 0; i < this._eventNames.length; i++) {\n            if (evt === this._eventNames[i].toLowerCase()) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            throw new Error(progress.data._getMsgText(\"jsdoMSG042\", evt));\n        }\n\n        if (args.length < 2) {\n            throw new Error(progress.data._getMsgText(\"jsdoMSG038\", 2));\n        }\n\n        if (typeof args[0] !== 'string') {\n            throw new Error(progress.data._getMsgText(\"jsdoMSG039\"));\n        }\n\n        if (typeof args[1] !== 'function') {\n            throw new Error(progress.data._getMsgText(\"jsdoMSG040\"));\n        }\n        else {\n            listenerData.fn = args[1];\n        }\n\n        if (args.length > 2) {\n            if (typeof args[2] !== 'object') {\n                throw new Error(progress.data._getMsgText(\"jsdoMSG041\", evt));\n            }\n            else {\n                listenerData.scope = args[2];\n            }\n        }\n    }\n    // events supported by Session\n    progress.data.Session.prototype._eventNames = \n        [\"offline\", \"online\", \"afterLogin\", \"afterAddCatalog\", \"afterLogout\"];  \n    // callback to validate subscribe and unsubscribe\n    progress.data.Session.prototype.validateSubscribe = validateSessionSubscribe;\n    progress.data.Session.prototype.toString = function (radix) {\n        return \"progress.data.Session\";\n    };\n    \n    \n    /*\n        progress.data.JSDOSession\n            Like progress.data.Session, but the methods are async-only and return promises.\n            (first implementation uses progress.data.Session to do the work, but conceivably\n            that implementation could be changed to something different)\n            The JSDOSession object keeps the same underlying pdsession object for the lifetime\n            of the JSDOSession object -- i.e., even after logout and subsequent login, the pdsession\n            is re-used rather than re-created.\n    */\n    progress.data.JSDOSession = function JSDOSession( options ){\n        var _pdsession,\n            _serviceURI,\n            _myself = this,\n            _name;\n\n        // PROPERTIES\n        // Approach: Use the properties of the underlying progress.data.Session object whenever\n        // possible. One exception is serviceURI, since it is set in the JSDOSession constructor\n        // but can only be set in the Session at login, so JSDOSession must use its own unless\n        // the pdsession is logged in\n        Object.defineProperty(this, 'authenticationModel',\n            {\n                get: function () {\n                    return _pdsession ? _pdsession.authenticationModel : undefined;\n                },\n                enumerable: true\n            });        \n\n        Object.defineProperty(this, 'catalogURIs',\n            {\n                get: function () {\n                    return _pdsession ? _pdsession.catalogURIs: undefined;\n                },\n                enumerable: true\n            });        \n        \n        Object.defineProperty(this, 'clientContextId',\n            {\n                get: function () {\n                    return _pdsession ? _pdsession.clientContextId: undefined;\n                },\n                enumerable: true\n            });        \n        \n        Object.defineProperty(this, 'connected',\n            {\n                get: function () {\n                    return _pdsession ? _pdsession.connected: undefined;\n                },\n                enumerable: true\n            });        \n                \n        Object.defineProperty(this, 'JSDOs',\n            {\n                get: function () {\n                    return _pdsession ? _pdsession.JSDOs: undefined;\n                },\n                enumerable: true\n            });        \n        \n        Object.defineProperty(this, 'loginResult',\n            {\n                get: function () {\n                    return _pdsession ? _pdsession.loginResult: undefined;\n                },\n                enumerable: true\n            });        \n        \n        Object.defineProperty(this, 'loginHttpStatus',\n            {\n                get: function () {\n                    return _pdsession ? _pdsession.loginHttpStatus: undefined;\n                },\n                enumerable: true\n            });        \n        \n        Object.defineProperty(this, 'onOpenRequest',\n            {\n                get: function () {\n                    return _pdsession ? _pdsession.onOpenRequest: undefined;\n                },\n                set: function (newval) {\n                    if (_pdsession) {\n                        _pdsession.onOpenRequest = newval;\n                    }\n                },\n                enumerable: true\n            });        \n        \n        Object.defineProperty(this, 'pingInterval',\n            {\n                get: function () {\n                    return _pdsession ? _pdsession.pingInterval: undefined;\n                },\n                set: function (newval) {\n                    if (_pdsession) {\n                        _pdsession.pingInterval = newval;\n                    }\n                },\n                enumerable: true\n            });        \n        \n        Object.defineProperty(this, 'services',\n            {\n                get: function () {\n                    return _pdsession ? _pdsession.services: undefined;\n                },\n                enumerable: true\n            });        \n        \n        Object.defineProperty(this, 'serviceURI',\n            {\n                get: function () {\n                    if (_pdsession && _pdsession.serviceURI) {\n                        return _pdsession.serviceURI;\n                    }\n                    else {\n                        return _serviceURI;\n                    }\n                },\n                enumerable: true\n            });        \n        \n        Object.defineProperty(this, 'userName',\n            {\n                get: function () {\n                    return _pdsession ? _pdsession.userName: undefined;\n                },\n                enumerable: true\n            });        \n        \n        Object.defineProperty(this, 'name',\n            {\n                get: function () {\n                    return _name;\n                },\n                enumerable: true\n            });        \n        \n        // PRIVATE FUNCTIONS\n        function onAfterLogin ( pdsession, result, errorObject, xhr ) {\n            if (xhr && xhr._deferred) {\n                if (result === progress.data.Session.SUCCESS) {\n                    xhr._deferred.resolve(   xhr._jsdosession, \n                                             result, \n                                             { errorObject: errorObject,\n                                               xhr: xhr } );\n                }\n                else {\n                    xhr._deferred.reject(   xhr._jsdosession, \n                                            result, \n                                            { errorObject: errorObject,\n                                              xhr: xhr });\n                }\n            }     \n        }\n\n        function onAfterAddCatalog( pdsession, result, errorObject, xhr ) {\n            var deferred;\n            \n            if (xhr && xhr._deferred) {           \n                deferred  = xhr._deferred;\n                \n                /* add the result for this addCatalog to the result array. */\n                if ( result !== progress.data.Session.SUCCESS &&\n                     result !== progress.data.Session.CATALOG_ALREADY_LOADED ) {\n                \n                     result = result || progress.data.Session.GENERAL_FAILURE;\n                     \n                     /* Set a property on the deferred to indicates that the \"overall\" result was \n                        a failure. When we decide whether to reject or resolve the promise, we reject \n                        if it's set to GENERAL_FAILURE, otherwise we resolve the promise\n                        (really only need to set this once, but simpler code if we just set (or possibly \n                        re-set) it whenever we find an error, plus if, at some point while we're still\n                        processing, it's important to know whether we've already had an error, we can \n                        check the property)\n                      */\n                     deferred._overallCatalogResult = progress.data.Session.GENERAL_FAILURE;\n                }\n                \n                deferred._results[xhr._catalogIndex] = { catalogURI : xhr._catalogURI,\n                                                       result : result,\n                                                       errorObject : errorObject,\n                                                       xhr : xhr};\n                deferred._numCatalogsProcessed += 1;\n                if ( deferred._numCatalogsProcessed  === deferred._numCatalogs ) {\n                    deferred._processedPromise = true;\n                    if ( !deferred._overallCatalogResult ) {\n                        xhr._deferred.resolve( xhr._jsdosession, \n                                               progress.data.Session.SUCCESS,\n                                               xhr._deferred._results );\n                    }\n                    else {\n                        xhr._deferred.reject(  xhr._jsdosession, \n                                               progress.data.Session.GENERAL_FAILURE, \n                                               xhr._deferred._results ); \n                    }\n                }\n            }\n        }\n        \n        function onAfterLogout ( pdsession, errorObject, xhr ) {\n            if (xhr && xhr._deferred) {\n                /* Note: loginResult gets cleared on successful logout, so testing it for false\n                         to confirm that logout succeeded\n                 */\n                 if ( !errorObject && !pdsession.loginResult ) {\n                    xhr._deferred.resolve( xhr._jsdosession, \n                                           progress.data.Session.SUCCESS,\n                                           { errorObject: errorObject, \n                                             xhr: xhr } );\n                }\n                else {\n                    xhr._deferred.reject( xhr._jsdosession, \n                                          progress.data.Session.SUCCESS,\n                                          { errorObject: errorObject, \n                                            xhr: xhr } );\n                }\n            }     \n        }\n\n        function onPingComplete( args ) {\n            var xhr;\n            if (args.xhr && args.xhr._deferred) {\n                xhr = args.xhr;\n                if ( args.pingResult ) {\n                    xhr._deferred.resolve( xhr._jsdosession, \n                                           args.pingResult,\n                                           { offlineReason: args.offlineReason, \n                                             xhr: xhr } );\n                }\n                else {\n                    xhr._deferred.reject(  xhr._jsdosession, \n                                           args.pingResult,\n                                           { offlineReason: args.offlineReason, \n                                             xhr: xhr } );\n                }\n            }     \n        }\n        \n        // METHODS\n        /*  login()\n            Calls the progress.data.Session method, passing arguments that cause it to\n            execute asynchronously. Throws an error if the underlying login call does not \n            make the async request, otherwise returns a promise.\n         */\n        this.login = function(username, password, options){\n            var deferred = $.Deferred(),\n                loginResult,\n                errorObject,\n                iOSBasicAuthTimeout;\n            \n            if ( typeof(options) === 'object' ) {\n                iOSBasicAuthTimeout = options.iOSBasicAuthTimeout;\n            }\n\n            try {\n                _pdsession.subscribe('afterLogin', onAfterLogin, this);\n                \n                loginResult = _pdsession.login(\n                    { serviceURI : this.serviceURI,\n                      userName : username, \n                      password : password, \n                      async : true,\n                      deferred : deferred,\n                      jsdosession : this,\n                      iOSBasicAuthTimeout: iOSBasicAuthTimeout} );\n               \n                if (loginResult !== progress.data.Session.ASYNC_PENDING) {\n                    errorObject = new Error(\"JSDOSession: Unable to send login request.\");\n                }\n            } \n            catch (e) {\n                errorObject = new Error(\"JSDOSession: Unable to send login request. \" + e.message);\n            }\n       \n            if ( errorObject ) {\n                throw errorObject;\n            }\n            else {\n                return deferred.promise();\n            }\n        };\n                            \n        this.addCatalog = function( catalogURI, username, password, options ){\n            var deferred = $.Deferred(),\n                catalogURIs,\n                numCatalogs,\n                catalogIndex,\n                addResult,\n                errorObject,\n                iOSBasicAuthTimeout;\n\n            // check whether 1st param is a string or an array\n            if ( typeof catalogURI == \"string\" ) {\n                catalogURIs = [ catalogURI ];\n            }\n            else if ( catalogURI instanceof Array ) {\n                catalogURIs = catalogURI;\n            }\n            else {\n                throw new Error(progress.data._getMsgText(\"jsdoMSG033\", \"JSDOSession\", \"addCatalog\", \n                       \"The catalogURI parameter must be a string or an array of strings.\") );\n            }\n\n            /* see whether the caller wants to override the workaround for the Cordova iOS async \n             * Basic auth bug\n             */\n            if ( typeof(options) === 'object' ) {\n                iOSBasicAuthTimeout = options.iOSBasicAuthTimeout;\n            }\n            \n            /* When we're done processing all catalogs, we pass an array of results to resolve() or\n               reject(). We're attaching this array to the deferred object, in case the app makes \n               multiple addCatalog calls (if the array was attached to the JSDOSession,\n               the 2nd call might overwrite the first)\n             */\n            \n            /*  Add properties to the deferred object for this call to store the total \n                number of catalogs that are to be done, the number that ahve been processed,\n                and a reference to an array of results.\n                Loop through the array of catalogURIs, calling addCatalog for each one. If a call\n                throws an error or returns something other than ASYNC_PENDING, create a result object\n                for that catalog and add the result object to the resultArray. Otherwise, the result \n                object will be added by the afterAddCatalog handler.\n                If all of the Session.addCatalog calls throw an error or return something other\n                than ASYNC_PENDING, this function will reject the promise and return. Otherwise \n                the afterAddCatalog handler will resolve or reject the promise after all calls have \n                been processed.\n                Note that we try to make sure that each entry in the results array is in the same position\n                as its catalogURI in the input array.\n               */\n                // if a catalogURI has no protocol, pdsession will assume it's relative to the serviceURI,\n                // if there has been a login\n                // NOTE: this means if the app is trying to load a local catalog, it MUST\n                // specify the file: protocol (and we need to make sure that works on all platforms)\n\n            _pdsession.subscribe('afterAddCatalog', onAfterAddCatalog, this); \n               \n            numCatalogs = catalogURIs.length;\n            deferred._numCatalogs = numCatalogs; \n            deferred._numCatalogsProcessed = 0; \n            deferred._results = []; \n            deferred._results.length = numCatalogs; \n        \n            for ( catalogIndex = 0; catalogIndex < numCatalogs; catalogIndex += 1) {\n                errorObject = undefined;\n                addResult = undefined;\n                try {                   \n                    addResult = _pdsession.addCatalog(\n                                       { catalogURI : catalogURIs[catalogIndex],\n                                         async : true,\n                                         userName : username,\n                                         password : password,\n                                         deferred : deferred,\n                                         jsdosession : this,\n                                         catalogIndex: catalogIndex,\n                                         iOSBasicAuthTimeout: iOSBasicAuthTimeout,\n                                         offlineAddCatalog: true } );  // OK to get catalog if offline\n                }\n                catch (e) {\n                    errorObject = new Error(\"JSDOSession: Unable to send addCatalog request. \" + e.message);\n                }\n                \n                if ( addResult !== progress.data.Session.ASYNC_PENDING ) {\n                    /* Set a property on the deferred to indicate that the \"overall\" result was \n                       a failure. When we decide whether to reject or resolve the promise, we reject \n                       if it's set to GENERAL_FAILURE, otherwise we resolve the promise\n                       (really only need to set this once, but simpler code if we just set (or possibly \n                       re-set) it whenever we find an error, plus if, at some point while we're still\n                       processing, it's important to know whether we've already had an error, we can \n                       check the property)\n                     */\n                    deferred._overallCatalogResult = progress.data.Session.GENERAL_FAILURE;\n                    if ( errorObject ) {\n                        addResult = progress.data.Session.GENERAL_FAILURE;\n                    }\n                    deferred._results[catalogIndex] = { catalogURI : catalogURIs[catalogIndex],\n                                              result : addResult,\n                                              errorObject : errorObject,\n                                              xhr : undefined };\n                    deferred._numCatalogsProcessed += 1;\n                }\n            }\n     \n            if ( (deferred._numCatalogsProcessed === numCatalogs) && !deferred._processedPromise ) {\n                /* The goal here is to handle the case where all the catalogs\n                   have been processed but the afterAddCatalog handler may not be invoked at the \n                   end (the obvious example is if there are no async requests actually made by \n                   Session.addCatalog). In that case, we have to resolve/reject from here. Chances are\n                   very good that if we're doing this here, there's been at least one error, but just\n                   to be sure, we check teh deferred._overallCatalogResult anyway\n                 */\n                if ( deferred._overallCatalogResult === progress.data.Session.GENERAL_FAILURE ) {\n                    deferred.reject( this, progress.data.Session.GENERAL_FAILURE, deferred._results );\n                }\n                else {\n                    deferred.resolve( this, progress.data.Session.SUCCESS, deferred._results ); \n                }\n            }\n            \n            return deferred.promise();\n        };\n        \n        this.logout = function(){\n            var deferred = $.Deferred();\n\n            try {\n                _pdsession.subscribe('afterLogout', onAfterLogout, this);\n                _pdsession.logout( {async: true,\n                                    deferred : deferred,\n                                    jsdosession : this} );\n            } \n            catch (e) {\n                throw new Error(\"JSDOSession: Unable to send logout request. \" + e.message);\n            }\n\n            return deferred.promise();\n        };       \n\n        this.ping = function() {\n            var deferred = $.Deferred();\n            \n            try {\n                _pdsession.ping( {async: true,\n                                  deferred : deferred,\n                                  jsdosession : this,\n                                  onCompleteFn : onPingComplete } );\n            }\n            catch(e) {\n                throw new Error(\"JSDOSession: Unable to send ping request. \" + e.message);                \n            }\n\n            return deferred.promise(); \n        };\n    \n        // Determine whether the JSDOSession can currently access its web application.\n         // The use expected for this method is to determine a JSDOSession that has\n         // previously authenticated to its web application still has authorization.\n         // For example, if the JSDOSession is using Form authentication, is the server\n         // session still valid or did it expire? \n        this.isAuthorized = function () {\n            var deferred = $.Deferred(),\n                that = this,\n                xhr = new XMLHttpRequest(),\n                result;\n\n            if (this.loginResult === progress.data.Session.LOGIN_SUCCESS) {\n                _pdsession._openRequest(xhr, \"GET\", _pdsession.loginTarget, true);\n                xhr.onreadystatechange = function () {\n                    var xhr = this,  // do we need this var? The one declared in isAuthorized seems to be in scope\n                        cbresult,\n                        fakePingArgs,\n                        info;\n\n                    if (xhr.readyState === 4) {\n                        info = {xhr: xhr,\n                                offlineReason: undefined,\n                                fireEventIfOfflineChange: true,\n                                usingOepingFormat: false\n                               };\n\n                        // call _processPingResult because it has logic for \n                        // detecting change in online/offline state\n                        _pdsession._processPingResult(info);\n\n                        if (xhr.status >= 200 && xhr.status < 300) {\n                            deferred.resolve(that,\n                                             progress.data.Session.SUCCESS,\n                                             info);\n                        } else {\n                            if (xhr.status === 401) {\n                                cbresult = progress.data.Session.AUTHENTICATION_FAILURE;\n                            } else {\n                                cbresult = progress.data.Session.GENERAL_FAILURE;\n                            }\n                            deferred.reject(that, cbresult, info);\n                        }\n                    }\n                };\n\n                try {\n                    xhr.send();\n                } catch (e) {\n                    throw new Error(\"JSDOSession: Unable to validate authorization. \" + e.message);\n                }\n            } else {\n                // Never logged in (or logged in and logged out). Regardless of what the reason\n                // was that there wasn't a login, the bottom line is that authentication is required\n                result = progress.data.Session.LOGIN_AUTHENTICATION_REQUIRED;\n                deferred.reject(that, result, {xhr: xhr});\n            }\n\n            return deferred.promise();\n        };\n        \n        /* \n           set the properties that are passed between client and Web application in the \n           X-CLIENT-PROPS header. This sets the complete set of properties all at once;\n           it replaces any existing context\n         */\n        this.setContext = function( context ) {\n            _pdsession._contextProperties.setContext( context );\n        };\n\n        /* \n         *  Set or remove an individual property in the set of the properties that are passed \n         *  between client and Web application in the X-CLIENT-PROPS header. This operates only \n         *  on the property identiofied by propertyName; all other existing properties remain\n         *  as they are.\n         *  If the propertyName is not part of the context, thsi call adds it\n         *  If it is part of the context, this call updates it, unless -\n         *  If propertyValue is undefined, this call removes the property\n         */\n        this.setContextProperty = function( propertyName, propertyValue) {\n            _pdsession._contextProperties.setContextProperty( propertyName, propertyValue );\n        };\n\n        /* \n         * get the set of properties that are passed between client and Web application in the \n         * X-CLIENT-PROPS header. Returns an object that has the properties\n         */\n        this.getContext = function( ) {\n            return _pdsession._contextProperties.getContext();\n        };\n        \n        /*  get the value of an individual property that is in the set of properties passed between \n         *  client and Web application in the X-CLIENT-PROPS header\n         */\n        this.getContextProperty = function( propertyName) {\n            return _pdsession._contextProperties.getContextProperty( propertyName );\n        };\n\n        \n        this._onlineHandler = function( session, request ) {\n            _myself.trigger( \"online\", _myself, request );            \n        };    \n        \n        this._offlineHandler = function( session, offlineReason, request ) {\n            _myself.trigger( \"offline\", _myself, offlineReason, request );            \n        };    \n        \n        // PROCESS CONSTRUCTOR ARGUMENTS \n        // validate constructor input arguments\n        if ( (arguments.length > 0) && (typeof(arguments[0]) === 'object') ) {\n            \n            // (options is the name of the arguments[0] parameter)\n            if (options.serviceURI && (typeof(options.serviceURI) === \"string\" ) ) {\n                _serviceURI = options.serviceURI;\n            }\n            else {\n                throw new Error(progress.data._getMsgText(\"jsdoMSG033\", \"JSDOSession\", \"the constructor\", \n                       \"The options parameter must include a 'serviceURI' property that is a string.\") );\n            }\n            \n            if (options.authenticationModel) {\n                if (typeof(options.authenticationModel) !== \"string\" ) {\n                    throw new Error(progress.data._getMsgText(\"jsdoMSG033\", \"JSDOSession\", \"the constructor\", \n                        \"The authenticationModel property of the options parameter must be a string.\") ); \n                }\n                \n                options.authenticationModel = options.authenticationModel.toLowerCase();\n            }\n        }\n        else {\n            throw new Error(progress.data._getMsgText(\"jsdoMSG033\", \"JSDOSession\", \"the constructor\", \n                \"The options argument was missing or invalid.\") );            \n        }    \n        \n\n        if (!options.authenticationModel) {\n            options.authenticationModel = progress.data.Session.AUTH_TYPE_ANON;\n        }\n        _name = options.name;\n        \n        // Note: passing auth model and serviceURI just for validation in the case of page refresh\n        _pdsession = new progress.data.Session({_storageKey: _name,\n                                                authenticationModel: options.authenticationModel,\n                                                serviceURI: options.serviceURI});\n\n        try {\n            if (options.authenticationModel) {\n                _pdsession.authenticationModel = options.authenticationModel;\n            }\n            \n            if (options.context) {\n                this.setContext(options.context);                \n            }\n            _pdsession.subscribe( \"online\", this._onlineHandler, this);\n            _pdsession.subscribe( \"offline\", this._offlineHandler, this);\n        } catch (err) {\n            _pdsession = undefined;  // so it will be garbage collected\n            throw err;\n        }\n        \n    };   // end of JSDOSession\n    \n//set up inheritance for JSDOSession -- specifically for incorporating an Observable object \n    progress.data.JSDOSession.prototype = new progress.util.Observable();\n    progress.data.JSDOSession.prototype.constructor = progress.data.JSDOSession;\n    function validateJSDOSessionSubscribe(args, evt, listenerData) {\n        listenerData.operation = undefined;\n        var found = false;\n\n        // make sure this event is one that we support\n        for (var i = 0; i < this._eventNames.length; i++) {\n            if (evt === this._eventNames[i].toLowerCase()) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            throw new Error(progress.data._getMsgText(\"jsdoMSG042\", evt));\n        }\n\n        if (args.length < 2) {\n            throw new Error(progress.data._getMsgText(\"jsdoMSG038\", 2));\n        }\n\n        if (typeof args[0] !== 'string') {\n            throw new Error(progress.data._getMsgText(\"jsdoMSG039\"));\n        }\n\n        if (typeof args[1] !== 'function') {\n            throw new Error(progress.data._getMsgText(\"jsdoMSG040\"));\n        }\n        else {\n            listenerData.fn = args[1];\n        }\n\n        if (args.length > 2) {\n            if (typeof args[2] !== 'object') {\n                throw new Error(progress.data._getMsgText(\"jsdoMSG041\", evt));\n            }\n            else {\n                listenerData.scope = args[2];\n            }\n        }\n    }\n    // events supported by JSDOSession\n    progress.data.JSDOSession.prototype._eventNames = \n        [\"offline\", \"online\"];  \n    // callback to validate subscribe and unsubscribe\n    progress.data.JSDOSession.prototype.validateSubscribe = validateJSDOSessionSubscribe;\n    progress.data.JSDOSession.prototype.toString = function (radix) {\n        return \"progress.data.JSDOSession\";\n    };\n    \n    progress.data.getSession = function(options) {\n\n        var deferred = $.Deferred();\n        \n        // This is the reject handler for session-related operations\n        // login, addCatalog, and logout\n        function sessionRejectHandler(jsdosession, result, info) {\n            deferred.reject(result, info);\n        };\n        \n        // This is the reject handler for the login callback\n        function callbackRejectHandler(reason) {\n            deferred.reject(progress.data.Session.GENERAL_FAILURE, {\"reason\": reason});\n        }\n        \n        function loginHandler(jsdosession, result, info) {\n            jsdosession.addCatalog(options.catalogURI)\n            .then(function(jsdosession, result, info) {\n                deferred.resolve(jsdosession, progress.data.Session.SUCCESS);\n            }, sessionRejectHandler);\n        };\n        \n        // This function calls login using credentials from the appropriate source\n        // Note that as currently implemented, this should NOT be called when\n        // ANONYMOUS auth is being used, because it unconditionally returns \n        // AUTHENTICATION_FAILURE if there are no credentials and no loginCallback\n        function callLogin(jsdosession, result, info) {\n            var errorObject;\n            \n            // Use the login callback if we are passed one \n            if (typeof options.loginCallback !== 'undefined') {\n                options.loginCallback()\n                .then(function (result) {\n                    jsdosession.login(result.username, result.password)\n                    .then(loginHandler, sessionRejectHandler);\n                }, callbackRejectHandler);\n            } else if (options.username && options.password) {\n                jsdosession.login(options.username, options.password)\n                .then(loginHandler, sessionRejectHandler);\n            } else {\n                errorObject = new Error(progress.data._getMsgText(\n                    \"jsdoMSG052\",\n                    \"getSession()\"\n                ));\n                sessionRejectHandler(\n                    jsdosession,\n                    progress.data.Session.AUTHENTICATION_FAILURE,\n                    {\n                        // including an Error object to make clear why there is no xhr (normally there would\n                        // be one for an authentication failure)\n                        errorObject: errorObject\n                    }\n                );\n            }\n        }\n        \n        if (typeof options !== 'object') {\n            // getSession(): 'options' must be of type 'object'\n            throw new Error(progress.data._getMsgText(\n                \"jsdoMSG503\", \n                \"getSession()\",\n                \"options\",\n                \"object\"\n            ));\n        }\n        \n        if (typeof options.loginCallback !== 'undefined' && \n            typeof options.loginCallback !== 'function') {\n            // getSession(): 'options.loginCallback' must be of type 'function'\n            throw new Error(progress.data._getMsgText(\n                \"jsdoMSG503\", \n                \"getSession()\",\n                \"options.loginCallback\",\n                \"function\"\n            ));\n        }\n        \n        // Create the JSDOSession and let it handle the argument parsing\n        try {\n            jsdosession = new progress.data.JSDOSession(options);\n            \n            jsdosession.isAuthorized()\n            .then(function(jsdosession, result, info) {\n                // If we are logged in, then we just re-add the catalog.\n                loginHandler(jsdosession, result, info);\n            }, function(jsdosession, result, info) {\n                // If model is anon, just log in.\n                if (jsdosession.authenticationModel === progress.data.Session.AUTH_TYPE_ANON &&\n                    result !== progress.data.Session.GENERAL_FAILURE) {\n                    \n                    jsdosession.login(options.username, options.password)\n                    .then(loginHandler, sessionRejectHandler);\n                } \n                // We need to log-in with credentials.\n                else if (result === progress.data.Session.LOGIN_AUTHENTICATION_REQUIRED || \n                    result === progress.data.Session.AUTHENTICATION_FAILURE) {\n                    \n                    // If we were logged in, we need to logout\n                    if (result === progress.data.Session.AUTHENTICATION_FAILURE) {\n                        jsdosession.logout()\n                        .then(callLogin, sessionRejectHandler);\n                    } else {\n                        callLogin(jsdosession);\n                    }\n                }\n                // If we get here, it's probably because the server is down.\n                else {\n                    sessionRejectHandler(jsdosession, result, info);\n                }\n            });\n        } catch (error) {\n            throw error;\n        }\n        \n        return deferred.promise();\n    };\n})();\n\nif (typeof exports !== \"undefined\") {\n    exports.progress = progress;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jsdo/lib/progress.jsdo.js\n// module id = 1\n// module chunks = 0"],"sourceRoot":""}